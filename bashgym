#!/usr/bin/env bash
# bashgym - CLI command trainer
set -uo pipefail
[[ ${BASH_VERSINFO[0]:-0} -lt 4 || (${BASH_VERSINFO[0]} -eq 4 && ${BASH_VERSINFO[1]:-0} -lt 3) ]] && { echo "Requires bash 4.3+"; exit 1; }
_tty() { [[ -t 0 ]] || { echo "Error: requires interactive terminal" >&2; exit 1; }; }

DATA="${XDG_DATA_HOME:-$HOME/.local/share}/bashgym"; mkdir -p "$DATA"; touch "$DATA/scores"
trap 'echo; exit 0' INT
R=$'\e[31m' G=$'\e[32m' Y=$'\e[33m' C=$'\e[36m' D=$'\e[2m' B=$'\e[1m' N=$'\e[0m'
PROMPT_CHAR="${CMD_PROMPT:-$([[ $EUID -eq 0 ]] && echo '# ' || echo '$ ')}"

# Command explanations (shown on TAB)
declare -A EXP=(
  [echo]="print text to stdout" [cat]="concatenate and display file contents" [ls]="list directory contents"
  [cd]="change directory" [cp]="copy files" [mv]="move/rename files" [rm]="remove files (no undo)"
  [mkdir]="create directory" [touch]="create file/update timestamp" [head]="first N lines" [tail]="last N lines"
  [grep]="search text (regex)" [find]="find files by name/size/date" [wc]="count lines/words/bytes"
  [sort]="sort lines" [uniq]="filter duplicates" [cut]="extract columns" [tr]="translate chars"
  [diff]="compare files" [tar]="archive tool" [tee]="copy stdin to file AND stdout" [xargs]="build commands from stdin"
  [chmod]="change permissions" [kill]="signal process" [jobs]="list background jobs" [fg]="foreground job"
  [bg]="background job" [sleep]="pause N seconds" [make]="build tool" [gcc]="C compiler"
  [date]="show/set date" [du]="disk usage" [ps]="list processes" [mount]="attach filesystem"
  [dd]="low-level copy" [strings]="extract text from binary" [base64]="encode/decode base64"
  [rg]="ripgrep: fast grep" [fd]="fast find" [eza]="modern ls" [bat]="cat with highlighting"
  [sd]="simple sed" [dust]="visual du" [tree]="directory tree" [sed]="stream editor" [xxd]="hex dump"
  [md5sum]="MD5 hash (weak)" [sha256sum]="SHA256 hash" [nmap]="port scanner" [hydra]="password cracker"
  [hashcat]="GPU hash cracker" [john]="John the Ripper" [tshark]="terminal wireshark" [nikto]="web scanner"
  [sqlmap]="SQL injection" [masscan]="fast port scanner" [airmon-ng]="WiFi monitor mode"
  [airodump-ng]="capture 802.11" [aireplay-ng]="inject packets" [aircrack-ng]="crack WPA/WEP"
  [nc]="netcat" [smbclient]="SMB client" [lynis]="security audit" [binwalk]="firmware analysis"
  [foremost]="file recovery" [fls]="list disk image" [exiftool]="file metadata" [readelf]="ELF info"
  [r2]="radare2 RE framework" [volatility3]="memory forensics" [mactime]="filesystem timeline"
  [feroxbuster]="dir enumeration" [proxychains]="proxy traffic" [procs]="modern ps"
  ['$$']="current shell PID" ['$?']="last exit code" ['$!']="last background PID"
  ['$#']="argument count" ['$@']="all arguments" ['$0']="script name"
  ['!!']="repeat last command" ['!$']="last arg of prev cmd" ['!^']="first arg of prev cmd" ['!*']="all args of prev cmd"
  ['>']="redirect to file" ['>>']="append to file" ['2>']="redirect stderr" ['&>']="redirect all"
  ['2>&1']="stderr to stdout" ['<']="read from file" ['<<<']="here-string" ['|']="pipe"
  ['|&']="pipe stdout+stderr" ['&&']="run if success" ['||']="run if fail" ['&']="run in background"
  ['-r']="recursive" ['-i']="case insensitive" ['-v']="invert/verbose" ['-l']="long/list files"
  ['-n']="line numbers" ['-c']="count" ['-q']="quiet" ['-f']="follow/force" ['-p']="create parents"
  ['-e']="extension" ['-t']="type" ['-x']="execute" ['-h']="human readable" ['-s']="size/silent"
  ['-a']="all/hidden" ['-u']="unique" ['-k']="key/column" ['-d']="delimiter" ['-o']="output" ['-w']="write"
  ['-A']="aggressive scan" ['-O']="OS detection" ['-sV']="version detection" ['-sC']="default scripts"
  ['-sU']="UDP scan" ['-sn']="ping scan" ['-sT']="TCP connect" ['-Pn']="skip ping" ['-F']="fast mode"
  ['-p-']="all ports" ['-m']="hash type" ['--show']="show cracked" ['--wordlist']="dictionary file"
  ['-E']="entropy/extended regex" ['-Y']="display filter" ['-T']="tree/fields"
  ['{}']="filename placeholder" ['\;']="end -exec" ['-exec']="run on each" ['-delete']="delete matches"
  ['-name']="match filename" ['-size']="match size" ['-type']="match type" ['-mmin']="match time" ['-path']="match path" ['-not']="negate"
)
explain() {
  local tok n=0
  for tok in $1; do [[ -n "${EXP[$tok]:-}" ]] && { echo -e "${D}  ${C}${tok}${D} → ${EXP[$tok]}${N}"; ((++n)); }; done
  EXPLAIN_LINES=$n
}

# Vi mode: env > saved > ask
VI_PREF="$DATA/vi_mode"
if [[ -n "${CMD_VI:-}" ]]; then VI_MODE=$CMD_VI
elif [[ -f "$VI_PREF" ]]; then VI_MODE=$(<"$VI_PREF")
else read -rp "Enable vi keybindings? [y/N] " yn; [[ "$yn" =~ ^[Yy] ]] && VI_MODE=1 || VI_MODE=0; echo "$VI_MODE" > "$VI_PREF"; fi

# Questions: prompt|answer|alt1|alt2...
declare -a Q0=(
  # Redirections
  'Save ls output to files.txt|ls > files.txt'
  'Append "done" to log.txt|echo "done" >> log.txt'
  'Save make errors to errors.log|make 2> errors.log'
  'Save make stdout+stderr to build.log|make &> build.log|make > build.log 2>&1'
  'Send gcc errors to stdout for piping|gcc main.c 2>&1'
  'Run backup.sh silently (discard all output)|./backup.sh &> /dev/null|./backup.sh > /dev/null 2>&1'
  'Find files, suppress permission errors|find / -name "*.conf" 2> /dev/null'
  'Count lines in data.csv via stdin|wc -l < data.csv'
  'Uppercase "hello" using here string|tr a-z A-Z <<< "hello"'
  # Pipes and logic
  'Search for errors in log.txt|grep error log.txt|cat log.txt | grep error'
  'Build and capture all output to build.log|make |& tee build.log'
  'Create dir and cd into it|mkdir foo && cd foo'
  'cd to foo, create if missing|mkdir -p foo && cd foo'
  'True if "error" NOT found in log.txt|! grep -q error log.txt'
  # Job control
  'Run sleep 100 in background|sleep 100 &'
  'List background jobs|jobs'
  'Bring job 1 to foreground|fg %1'
  'Send job 1 to background|bg %1'
  'Kill job 1|kill %1'
  # Command substitution
  'Store list of .txt files in variable|files=$(ls *.txt)'
  'Print today date inline|echo "Today is $(date +%Y-%m-%d)"'
  # Subshell and grouping
  'Extract tarball in /tmp without changing dir|(cd /tmp && tar xzf archive.tar.gz)'
  'Run start/end echo with sleep in current shell|{ echo start; sleep 1; echo end; }'
  # History
  'Repeat last command|!!'
  "Run last command starting with 'git'|!git"
  'Run command number 42 from history|!42'
  'Replace foo with bar in last command|^foo^bar'
  'Reuse last argument of previous command|!$'
  'Reuse first argument of previous command|!^'
  'Reuse all arguments of previous command|!*'
  # Special variables
  'Print current shell PID|echo $$'
  'Print exit status of last command|echo $?'
  'Print PID of last background process|echo $!'
  'Print number of script arguments|echo $#'
  'Print all script arguments|echo $@'
  'Print script name|echo $0'
  # Brace expansion
  'Create a.txt b.txt c.txt|touch {a,b,c}.txt'
  'Create file1 through file5|touch file{1..5}'
  'Backup config.ini to config.ini.bak|cp config.ini{,.bak}'
  'Diff file.old vs file.new|diff file.{old,new}'
  # Process substitution
  'Diff sorted contents of file1.txt and file2.txt|diff <(sort file1.txt) <(sort file2.txt)'
)
declare -a Q1=(
  "View config.ini with syntax highlighting|cat config.ini|bat config.ini"
  "List files with size+perms|ls -l|eza -l"
  "List all files including hidden|ls -la|eza -la"
  "Show directory tree|tree|eza -T"
  "Find all .py files|find . -name '*.py'|fd -e py"
  "First 10 lines of data.txt|head -n 10 data.txt|head -10 data.txt"
  "Last 20 lines of log.txt|tail -n 20 log.txt|tail -20 log.txt"
  "Count lines in data.csv|wc -l data.csv"
  "Show disk usage of current dir|du -sh .|dust"
  "Copy config.ini to backup.ini|cp config.ini backup.ini"
)
declare -a Q2=(
  "Search for 'error' recursively|grep -r error|rg error"
  "Case-insensitive search for 'warning'|grep -ri warning|rg -i warning"
  "Search for TODO with line numbers|grep -rn TODO|rg -n TODO"
  "Count 'error' matches in log.txt|grep -c error log.txt|rg -c error log.txt"
  "Search 'panic' with 2 lines context|grep -C 2 panic|rg -C 2 panic"
  "List only filenames containing 'error'|grep -rl error|rg -l error"
  "Search 'import' in .py files only|grep -r --include='*.py' import|rg -t py import"
  "Find phone pattern XXX-XXXX|grep -E '[0-9]{3}-[0-9]{4}'|rg '\\d{3}-\\d{4}'"
  "Lines without 'error' in log.txt|grep -v error log.txt|rg -v error log.txt"
  "Literal search 'func()' in app.py|grep -F 'func()' app.py|rg -F 'func()' app.py"
)
declare -a Q3=(
  "Find all .log files|find . -name '*.log'|fd -e log"
  "Find files larger than 10M|find . -size +10M|fd -S +10M"
  "Find files modified in last hour|find . -mmin -60|fd --changed-within 1h"
  "Find directories only|find . -type d|fd -t d"
  "Find 'config' including hidden files|find . -name '*config*'|fd -H config"
  "Find all, excluding .git|find . -not -path './.git/*'|fd -E .git"
  "Find empty files|find . -type f -empty|fd -t f -S 0"
  "Find executable files|find . -type f -executable|fd -t x"
  "Find symlinks|find . -type l|fd -t l"
  "Find files matching path src/*test*|find . -path '*src/*test*'|fd -p src/.*test"
)
declare -a Q4=(
  "List files sorted by size (largest first)|ls -lS|eza -l --sort size -r"
  "List files sorted by modification time|ls -lt|eza -l --sort modified"
  "List directories only|ls -d */|eza -D"
  "List files with git status|eza -l --git"
  "Show tree 2 levels deep|tree -L 2|eza -T -L 2"
  "Follow server.log in realtime|tail -f server.log"
  "Sort and deduplicate dupes.txt|sort -u dupes.txt"
  "Extract 2nd column from data.csv|cut -d',' -f2 data.csv"
  "Sort data.txt by column 2|sort -k2 data.txt"
  "Count unique lines in data.txt|sort data.txt | uniq -c"
)
declare -a Q5=(
  "Run ls -l on each .py file found|find . -name '*.py' -exec ls -l {} \\;|fd -e py -x ls -l {}"
  "Count lines in each .txt file|find . -name '*.txt' -exec wc -l {} \\;|fd -e txt -x wc -l {}"
  "Delete all .tmp files|find . -name '*.tmp' -delete|fd -e tmp -x rm {}"
  "Make all .sh files executable|find . -name '*.sh' -exec chmod +x {} \\;|fd -e sh -x chmod +x {}"
  "Search 'error' in each .log file|find . -name '*.log' -exec grep error {} \\;|fd -e log -x rg error {}"
  "Extract and count IPs from log.txt|grep -oE '[0-9]+\\.[0-9]+\\.[0-9]+\\.[0-9]+' log.txt | sort | uniq -c|rg -o '\\d+\\.\\d+\\.\\d+\\.\\d+' log.txt | sort | uniq -c"
  "Show size of files >100M|find . -size +100M -exec du -h {} \\;|fd -S +100M -x du -h {}"
  "Replace 'old' with 'new' in config.txt|sed -i 's/old/new/g' config.txt|sd 'old' 'new' config.txt"
  "Replace 'foo' with 'bar' in all .txt files|find . -name '*.txt' -exec sed -i 's/foo/bar/g' {} \\;|fd -e txt -x sd 'foo' 'bar' {}"
  "Show process tree|ps auxf|procs --tree"
)
declare -a Q6=(
  "Scan all ports on 10.0.0.1|nmap -p- 10.0.0.1"
  "Scan top 100 ports on 10.0.0.1|nmap --top-ports 100 10.0.0.1"
  "Detect service versions on 10.0.0.1|nmap -sV 10.0.0.1"
  "Detect OS on 10.0.0.1|nmap -O 10.0.0.1"
  "UDP scan top 20 ports on 10.0.0.1|nmap -sU --top-ports 20 10.0.0.1"
  "Aggressive scan on 10.0.0.1|nmap -A 10.0.0.1"
  "Ping sweep 10.0.0.0/24 subnet|nmap -sn 10.0.0.0/24"
  "Fast scan 10.0.0.1, skip ping|nmap -Pn -F 10.0.0.1"
  "Scan 10.0.0.1, save greppable to scan.txt|nmap -oG scan.txt 10.0.0.1"
  "Scan 10.0.0.1 through proxychains|proxychains nmap -sT 10.0.0.1"
  "Run vuln scripts on 10.0.0.1|nmap --script vuln 10.0.0.1"
  "Banner grab port 80 on 10.0.0.1|nmap -sV -p 80 --script banner 10.0.0.1"
  "Enumerate SMB shares on 10.0.0.1|nmap --script smb-enum-shares 10.0.0.1"
  "Detect web server on 10.0.0.1 ports 80,443|nmap -sV -p 80,443 10.0.0.1"
  "Full scan 10.0.0.1, all output formats to full_scan|nmap -p- -oA full_scan 10.0.0.1"
)
declare -a Q7=(
  "Crack MD5 hashes in hash.txt using wordlist.txt|hashcat -m 0 hash.txt wordlist.txt"
  "Crack SHA256 hashes in hash.txt|hashcat -m 1400 hash.txt wordlist.txt"
  "Crack bcrypt hashes in hash.txt|hashcat -m 3200 hash.txt wordlist.txt"
  "Brute force 4-digit PIN for hash.txt|hashcat -m 0 -a 3 hash.txt ?d?d?d?d"
  "Crack hash.txt with best64 rules|hashcat -m 0 -r rules/best64.rule hash.txt wordlist.txt"
  "Show already cracked from hash.txt|hashcat -m 0 hash.txt --show"
  "Crack hash.txt with john default|john hash.txt"
  "Crack hash.txt with john using wordlist.txt|john --wordlist=wordlist.txt hash.txt"
  "Show cracked hashes from john|john --show hash.txt"
  "Generate MD5 hash of string 'password'|echo -n 'password' | md5sum"
  "Brute force HTTP auth on 10.0.0.1 user admin|hydra -l admin -P wordlist.txt 10.0.0.1 http-get /"
  "Brute force SSH on 10.0.0.1 user root|hydra -l root -P wordlist.txt 10.0.0.1 ssh"
  "Crack password on archive.zip|john --format=zip archive.zip"
  "Decode base64 file encoded.txt|base64 -d encoded.txt"
  "Convert hex file hex.txt to ascii|xxd -r -p hex.txt"
)
declare -a Q8=(
  "Extract strings from binary.exe|strings binary.exe"
  "Show ELF headers of binary.elf|readelf -h binary.elf"
  "Analyze binary.exe with radare2|r2 -A binary.exe"
  "Extract embedded files from firmware.bin|binwalk -e firmware.bin"
  "Analyze entropy of firmware.bin|binwalk -E firmware.bin"
  "Get system info from memory.dmp|volatility3 -f memory.dmp windows.info"
  "List processes from memory.dmp|volatility3 -f memory.dmp windows.pslist"
  "Extract network connections from memory.dmp|volatility3 -f memory.dmp windows.netscan"
  "Recover deleted files from disk.img to output/|foremost -i disk.img -o output/"
  "List filesystem of disk.img recursively|fls -r disk.img"
  "Extract metadata from photo.jpg|exiftool photo.jpg"
  "Verify checksums in checksums.txt|sha256sum -c checksums.txt"
  "Create disk image of /dev/sda to disk.img|dd if=/dev/sda of=disk.img bs=4M"
  "Mount disk.img readonly at /mnt/evidence|mount -o ro,loop disk.img /mnt/evidence"
  "Create filesystem timeline from bodyfile.txt|mactime -b bodyfile.txt"
)
declare -a Q9=(
  "Full nmap scan 10.0.0.1 with scripts, all output to 'full'|nmap -sV -sC -p- -oA full 10.0.0.1"
  "Capture traffic on eth0 to capture.pcap|tshark -i eth0 -w capture.pcap"
  "Filter HTTP traffic from capture.pcap|tshark -r capture.pcap -Y http"
  "Extract POST data from capture.pcap|tshark -r capture.pcap -Y 'http.request.method == POST' -T fields -e http.file_data"
  "Scan http://10.0.0.1 for web vulns with nikto|nikto -h http://10.0.0.1"
  "Test SQLi on http://10.0.0.1/page?id=1|sqlmap -u 'http://10.0.0.1/page?id=1' --dbs"
  "Enumerate directories on http://10.0.0.1|feroxbuster -u http://10.0.0.1"
  "Enable monitor mode on wlan0|airmon-ng start wlan0"
  "Capture handshake on channel 6 from AA:BB:CC:DD:EE:FF|airodump-ng -c 6 --bssid AA:BB:CC:DD:EE:FF -w capture wlan0mon"
  "Send 5 deauth packets to AA:BB:CC:DD:EE:FF|aireplay-ng -0 5 -a AA:BB:CC:DD:EE:FF wlan0mon"
  "Crack WPA handshake in capture.cap|aircrack-ng -w wordlist.txt capture.cap"
  "Mass scan all ports on 10.0.0.0/24 at 10k rate|masscan -p1-65535 10.0.0.0/24 --rate 10000"
  "List SMB shares on //10.0.0.1 anonymously|smbclient -L //10.0.0.1 -N"
  "Start reverse shell listener on port 4444|nc -lvnp 4444"
  "Run system security audit with lynis|lynis audit system"
)

# Normalize flags: -la == -al == -a -l
norm() {
  local parts flags=() args=() out p
  read -ra parts <<< "$1"; out="${parts[0]}"
  for p in "${parts[@]:1}"; do
    if [[ "$p" == -* ]]; then
      [[ "$p" =~ ^-[a-zA-Z]+$ && ${#p} -gt 2 ]] && { for ((j=1;j<${#p};j++)); do flags+=("-${p:j:1}"); done; } || flags+=("$p")
    else args+=("$p"); fi
  done
  readarray -t flags < <(printf '%s\n' "${flags[@]}"|LC_ALL=C sort)
  printf '%s' "$out"; printf ' %s' "${flags[@]}" "${args[@]}"; echo
}

check() {
  local inp="${1#"${1%%[![:space:]]*}"}" a b; inp="${inp%"${inp##*[![:space:]]}"}"
  IFS='|' read -ra opts <<< "$2"
  for a in "${opts[@]}"; do b="${a#"${a%%[![:space:]]*}"}"; b="${b%"${b##*[![:space:]]}"}"; [[ "$inp" == "$b" || "$(norm "$inp")" == "$(norm "$b")" ]] && return 0; done; return 1
}

LVL=0 HINT=false PROG=0 TOT=0
load() { [[ -f "$DATA/session.json" ]] && { local t; t=$(<"$DATA/session.json"); t="${t#*\"level\":}"; LVL="${t%%[!0-9]*}"; }; LVL=${LVL:-0}; }
save() { printf '{"level":%d}\n' "$LVL" > "$DATA/session.json"; }
# Score tracking: tier 0=copy, 1=blank, 2=recall (md5 hash keys avoid regex issues)
_hash() { local h; h=$(printf '%s' "$1"|md5sum); echo "${h:0:16}"; }
score_set() { local k=$(_hash "$1"); sed -i "/^$k|/d" "$DATA/scores" 2>/dev/null; echo "$k|$2">>"$DATA/scores"; }
score_get() { local k=$(_hash "$1") t; t=$(grep "^$k|" "$DATA/scores" 2>/dev/null); t="${t##*|}"; echo "${t:-0}"; }

stats() {
  local -A sc; [[ -f "$DATA/scores" ]] && while IFS='|' read -r k v; do sc[$k]=$v; done < "$DATA/scores"
  echo -e "${B}Mastery Stats${N}\n"
  for lv in {0..9}; do
    local -n qs="Q$lv"; local t0=0 t1=0 t2=0 h
    for q in "${qs[@]}"; do
      h=$(_hash "${q%%|*}"); case "${sc[$h]:-0}" in 0) ((++t0));; 1) ((++t1));; *) ((++t2));; esac
    done
    printf "Level %d: ${R}%2d${N} copy  ${Y}%2d${N} blank  ${G}%2d${N} recall\n" "$lv" "$t0" "$t1" "$t2"
  done
}

# Tier display: 0=copy, 1=blank, 2=recall
show_tier() {
  local tier=$1 ans=$2
  case $tier in
    0) echo -e "${C}Type:${N} ${ans}";;
    1) local half=$((${#ans}/2)); echo -e "${C}Complete:${N} ${ans:0:half}${D}...${N}";;
  esac
}

input="" cursor=0 mode="insert" SHOW_HINT=0 UNDO="" EXPLAIN_LINES=0 _rep=""
clear_hint() { for ((i=0;i<=EXPLAIN_LINES;i++)); do printf '\e[A\e[2K'; done; printf '\r'; }
hdr() { printf '\e[2J\e[H'; echo -e "${B}=== Level $1 ===  ${D}[$2/$3]${N}  ${D}Tab=hint Ctrl+n=skip${N}\n"; }
qdisp() { bar; echo -e "\n${D}$1${N}"; show_tier "$2" "$3"; echo; }
bar() { local f e; printf -v f '%*s' "$PROG" ''; printf -v e '%*s' "$((TOT-PROG))" ''; printf '[%s%s]' "${f// /█}" "${e// /░}"; }
draw() {
  echo -ne "\r\e[K"
  if ((SHOW_HINT)); then
    echo -ne "${D}$PROMPT_CHAR${ans}${N}"
  else
    ((VI_MODE)) && [[ $mode != insert ]] && echo -ne "\e[91m$PROMPT_CHAR\e[0m" || echo -ne "\e[97m$PROMPT_CHAR\e[0m"
    echo -n "$input"
    ((cursor<${#input})) && echo -ne "\e[$((${#input}-cursor))D"
  fi
}

# Vi helpers
_wfwd() { while ((cursor<${#input})) && [[ "${input:cursor:1}" != " " ]]; do ((++cursor)); done; while ((cursor<${#input})) && [[ "${input:cursor:1}" == " " ]]; do ((++cursor)); done; ((cursor>=${#input}&&${#input}>0)) && cursor=$((${#input}-1)); }
_wbck() { ((cursor>0)) && ((cursor--)); while ((cursor>0)) && [[ "${input:cursor:1}" == " " ]]; do ((cursor--)); done; while ((cursor>0)) && [[ "${input:cursor-1:1}" != " " ]]; do ((cursor--)); done; }
_wend() { ((cursor<${#input}-1)) && ((++cursor)); while ((cursor<${#input}-1)) && [[ "${input:cursor:1}" == " " ]]; do ((++cursor)); done; while ((cursor<${#input}-1)) && [[ "${input:cursor+1:1}" != " " ]]; do ((++cursor)); done; }
_clamp() { ((cursor>=${#input}&&cursor>0)) && cursor=$((${#input}-1)); }
_del() { # $1=motion
  local e=$cursor
  case "$1" in
    d|c) input="" cursor=0;;
    w) while ((e<${#input})) && [[ "${input:e:1}" != " " ]]; do ((++e)); done; input="${input:0:cursor}${input:e}";;
    b) ((e>0)) && ((e--)); while ((e>0)) && [[ "${input:e:1}" == " " ]]; do ((e--)); done; while ((e>0)) && [[ "${input:e-1:1}" != " " ]]; do ((e--)); done; input="${input:0:e}${input:cursor}"; cursor=$e;;
    \$) input="${input:0:cursor}";;
    0) input="${input:cursor}"; cursor=0;;
  esac; _clamp
}

run() {
  local lv=$1 shuf=() qi=0 done=0; local -n qs="Q$lv"
  local -A _sc; [[ -f "$DATA/scores" ]] && while IFS='|' read -r k v; do _sc[$k]=$v; done < "$DATA/scores"
  _sget() { local h=$(_hash "$1"); echo "${_sc[$h]:-0}"; }
  _sset() { local h=$(_hash "$1"); _sc[$h]=$2; sed -i "/^$h|/d" "$DATA/scores" 2>/dev/null; echo "$h|$2">>"$DATA/scores"; }
  TOT=${#qs[@]}; PROG=0
  # Prioritize by tier: 0 (copy) > 1 (blank) > 2 (recall)
  local t0=() t1=() t2=()
  for q in "${qs[@]}"; do
    case "$(_sget "${q%%|*}")" in 0) t0+=("$q");; 1) t1+=("$q");; *) t2+=("$q");; esac
  done
  readarray -t shuf < <({ printf '%s\n' "${t0[@]}"|shuf; printf '%s\n' "${t1[@]}"|shuf; printf '%s\n' "${t2[@]}"|shuf; })
  hdr "$lv" "$((qi+1))" "$TOT"
  while ((qi < ${#shuf[@]})); do
    local prompt="${shuf[$qi]%%|*}" answers="${shuf[$qi]#*|}"; local ans="${answers%%|*}"
    local tier; tier=$(_sget "$prompt")
    HINT=false SHOW_HINT=0 EXPLAIN_LINES=0
    qdisp "$prompt" "$tier" "$ans"
    while true; do
      input="" cursor=0 mode="insert" SHOW_HINT=0
      read -t 0.01 -rsn 1000 ||:
      draw
      while IFS= read -rsn1 c; do
        if [[ "$c" == $'\t' ]]; then
          # Toggle hint + explanation
          if ((SHOW_HINT)); then
            SHOW_HINT=0; clear_hint
          else
            SHOW_HINT=1; HINT=true; draw; echo; explain "$ans"; continue
          fi
          draw; continue
        fi
        if [[ "$mode" == "insert" ]]; then
          # Clear hint display if typing
          if ((SHOW_HINT)) && [[ "$c" != $'\x1b' && "$c" != '' ]]; then
            SHOW_HINT=0; clear_hint
          fi
          case "$c" in
            $'\x0e') echo -e "\n${D}[skipped]${N}"; ((++qi)); break 2;;  # Ctrl+N skip
            $'\x04') echo -e "\n${D}[quit]${N}"; exit 0;;  # Ctrl+D quit
            $'\x1b') ((VI_MODE)) && { mode="normal"; ((cursor>0)) && ((cursor--)); draw; };;
            $'\x7f'|$'\b') ((cursor>0)) && { input="${input:0:cursor-1}${input:cursor}"; ((cursor--)); draw; };;
            '') echo; break;;
            *) input="${input:0:cursor}${c}${input:cursor}"; ((++cursor)); draw;;
          esac
        elif ((VI_MODE)); then
          # Clear hint display if any vi command
          if ((SHOW_HINT)); then SHOW_HINT=0; clear_hint; fi
          # Number prefix: accumulate digits
          if [[ "$c" =~ ^[1-9]$ ]] || { [[ "$c" == "0" ]] && [[ -n "$_rep" ]]; }; then _rep+="$c"; continue; fi
          local _n=${_rep:-1}; _rep=""
          # Save for undo before destructive operations
          case "$c" in s|S|x|X|D|C|d|c|r) UNDO="$input:$cursor";; esac
          case "$c" in
            i) mode="insert"; draw;; a) mode="insert"; ((cursor<${#input})) && ((++cursor)); draw;;
            A) mode="insert"; cursor=${#input}; draw;; I) mode="insert"; cursor=0; draw;;
            s) ((${#input}>0)) && input="${input:0:cursor}${input:cursor+1}"; mode="insert"; draw;;
            S) input="" cursor=0 mode="insert"; draw;;
            h) for ((_i=0;_i<_n&&cursor>0;_i++)); do ((cursor--)); done; draw;;
            l) for ((_i=0;_i<_n&&cursor<${#input}-1;_i++)); do ((++cursor)); done; draw;;
            0) cursor=0; draw;; \$) cursor=$((${#input}>0?${#input}-1:0)); draw;;
            w) for ((_i=0;_i<_n;_i++)); do _wfwd; done; draw;;
            b) for ((_i=0;_i<_n;_i++)); do _wbck; done; draw;;
            e) for ((_i=0;_i<_n;_i++)); do _wend; done; draw;;
            f) IFS= read -rsn1 c2; for ((_i=0;_i<_n;_i++)); do for ((p=cursor+1;p<${#input};p++)); do [[ "${input:p:1}" == "$c2" ]] && { cursor=$p; break; }; done; done; draw;;
            F) IFS= read -rsn1 c2; for ((_i=0;_i<_n;_i++)); do for ((p=cursor-1;p>=0;p--)); do [[ "${input:p:1}" == "$c2" ]] && { cursor=$p; break; }; done; done; draw;;
            t) IFS= read -rsn1 c2; for ((_i=0;_i<_n;_i++)); do for ((p=cursor+1;p<${#input};p++)); do [[ "${input:p:1}" == "$c2" ]] && { cursor=$((p-1)); break; }; done; done; draw;;
            T) IFS= read -rsn1 c2; for ((_i=0;_i<_n;_i++)); do for ((p=cursor-1;p>=0;p--)); do [[ "${input:p:1}" == "$c2" ]] && { cursor=$((p+1)); break; }; done; done; draw;;
            x) for ((_i=0;_i<_n&&${#input}>0&&cursor<${#input};_i++)); do input="${input:0:cursor}${input:cursor+1}"; done; _clamp; draw;;
            X) for ((_i=0;_i<_n&&cursor>0;_i++)); do input="${input:0:cursor-1}${input:cursor}"; ((cursor--)); done; draw;;
            D) input="${input:0:cursor}"; ((cursor>0)) && ((cursor--)); draw;;
            C) input="${input:0:cursor}"; mode="insert"; draw;;
            r) IFS= read -rsn1 c2; [[ -n "$c2" && "$c2" != $'\x1b' ]] && { input="${input:0:cursor}${c2}${input:cursor+1}"; draw; };;
            d) IFS= read -rsn1 c2; for ((_i=0;_i<_n;_i++)); do _del "$c2"; done; draw;;
            c) IFS= read -rsn1 c2; for ((_i=0;_i<_n;_i++)); do _del "$c2"; done; mode="insert"; draw;;
            u) [[ -n "$UNDO" ]] && { input="${UNDO%:*}"; cursor="${UNDO#*:}"; UNDO=""; draw; };;  # undo
            n) echo -e "\n${D}[skipped]${N}"; ((++qi)); break 2;;  # skip in normal mode
            q) echo -e "\n${D}[quit]${N}"; exit 0;;  # quit
            \?) echo -e "\n${D}hjkl${N} move  ${D}wb${N} word  ${D}fFtT${N}+char find  ${D}0\$${N} line"; echo -e "${D}x/X${N} del char  ${D}dw/db/dd${N} del  ${D}cw/cb/cc${N} change  ${D}r${N} replace"; echo -e "${D}s/S${N} subst  ${D}i/a/I/A${N} insert  ${D}u${N} undo  ${D}n${N} skip  ${D}q${N} quit"; echo -e "${D}Tab${N} hint  ${D}Ctrl+n${N} skip  ${D}Ctrl+d${N} quit  ${D}[num]cmd${N} repeat"; read -rsn1; hdr "$lv" "$((qi+1))" "$TOT"; qdisp "$prompt" "$tier" "$ans"; draw;;
            '') echo; break;;
          esac
        fi
      done
      if check "$input" "$answers"; then
        ((++PROG))
        if $HINT; then echo -e "${Y}+1${N} ${D}(hint)${N}"; _sset "$prompt" "$tier"  # stay same tier
        else ((++done)); echo -e "${G}+1${N}"; _sset "$prompt" "$((tier<2?tier+1:2))"; fi  # tier++
        ((++qi)); save; break
      else
        ((PROG>0)) && ((PROG--)); echo -e "${R}-1${N}\n${D}answer:${N} ${C}${ans}${N}"
        _sset "$prompt" "$((tier>0?tier-1:0))"; sleep 2  # tier--
      fi
      tier=$(_sget "$prompt"); hdr "$lv" "$((qi+1))" "$TOT"; qdisp "$prompt" "$tier" "$ans"
    done
    hdr "$lv" "$((qi+1))" "$TOT"
  done
  if ((done>=TOT)); then
    echo -e "${G}${B}Level $lv Complete!${N}"
    ((lv<9)) && { echo "Enter for Level $((lv+1))..."; read -r; LVL=$((lv+1)); save; run "$LVL"; } || echo -e "${G}${B}ALL COMPLETE - CLI MASTER${N}"
  else echo -e "${Y}Need $((TOT-done)) more without hints${N}"; echo "Enter to retry..."; read -r; run "$lv"; fi
}

case "${1:-}" in
  [0-9]) _tty; LVL=$1; save; run "$LVL";;
  r|reset) rm -f "$DATA"/*.json "$DATA/vi_mode" "$DATA/scores"; echo "Reset.";;
  s|stats) stats;;
  v|version|-v|--version) echo "bashgym 1.0.0";;
  h|help|-h|--help) echo "bashgym [0-9|n|reset|stats|help|version] - CLI trainer. Tab=hint Ctrl+n=skip";;
  n|new) _tty; LVL=0; save; run "$LVL";;
  "") _tty; load; ((LVL>0)) && { read -rp "Continue Level $LVL? [Y/n] " yn; [[ "$yn" =~ ^[Nn] ]] && { LVL=0; save; }; }; run "$LVL";;
  *) echo "Usage: bashgym [0-9|reset|stats|help|version]"; exit 1;;
esac
